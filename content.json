{"meta":{"title":"YoLinDeng's blog","subtitle":"","description":"YoLinDeng blog","author":"YoLin Deng","url":"http://yolindeng.gitee.io/myblog","root":"/myblog/"},"pages":[{"title":"关于","date":"2020-06-09T10:45:44.000Z","updated":"2021-05-21T02:31:57.598Z","comments":false,"path":"about/index.html","permalink":"http://yolindeng.gitee.io/myblog/about/index.html","excerpt":"","text":"关于我 博主本名邓咏凌，来自美丽客都、世界长寿之乡梅州蕉岭。2019年毕业于广东药科大学，信息管理与信息系统专业。在成为一名出色的前端开发者的道路上不断努力，让自己变成越来越优秀。平时喜欢打篮球、短跑、唱歌、听歌，想要踏足祖国的大好河山，领略不同地域的风土人情。等到秋叶终于金黄，华发悄然苍苍，愿我们相约老地方～ 在校经历 大学四年时光是如此的短暂且美好，脑海中的点点滴滴都已成回忆，在心间不停流转。 社团生活丰富多彩，大一加入学生会组织部作为干事、校田径队短跑队员，大二成为组织部部长、加入院篮球队，大三作为学生副书记。 获得二等奖学金，及运动类、社团类奖学金。三年参加了3次校运会，分别斩获2次第三，一次第一的成绩，最好成绩11.53。 大学期间最喜欢的运动莫过于篮球，成为我大学不可或缺的伙伴。 做过家教、手机店销售等兼职 工作经历 广东万丈金数信息技术股份有限公司（2019.5 - 至今）前端开发工程师（初级、中级） 移动端活动营销页面、微信公众号页面、微信及支付宝小程序开发 活动组件平台的node后端开发（基于egg.js和mongoDB） 公司内部后台管理系统开发 百家保系列产品开发… 深圳云之家网络有限公司(金蝶云之家)（2018.12 - 2019.3）web前端开发实习生 生态圈产品移动端及管理系统功能迭代开发 配合产品、UI、UE、后端、测试，完成页面功能交互，并上线。 中山蕉神科技（2018.7 - 2018.11）H5前端开发工程师实习生 负责活动页面开发 公众号体系开发"},{"title":"About me","date":"2020-05-27T07:46:53.000Z","updated":"2020-12-15T01:45:28.823Z","comments":false,"path":"about/me.html","permalink":"http://yolindeng.gitee.io/myblog/about/me.html","excerpt":"","text":""}],"posts":[{"title":"使用Proxy实现简易的vue双向数据绑定","slug":"使用Proxy实现简易的vue双向数据绑定","date":"2021-05-21T07:52:48.000Z","updated":"2021-05-21T10:25:29.870Z","comments":true,"path":"2021/05/21/使用Proxy实现简易的vue双向数据绑定/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/%E4%BD%BF%E7%94%A8Proxy%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"在实现vue双向数据绑定之前，先了解Proxy相关的概念和用法 proxy概念Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 一些术语 handle包含捕捉器（trap）的占位符对象，可译为处理器对象 traps提供属性访问的方法。这类似于操作系统中捕获器的概念。 target被 Proxy 代理虚拟化的对象。语法const p = new Proxy(target, handler) target要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handle一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。 使用proxy实现数据劫持12345678910111213let data = &#123; name: YoLinDeng, height: '176cm'&#125;const p = new Proxy(data, &#123; get(target, prop) &#123; return Reflect.get(...arguments) &#125;, set(target, prop, newValue) &#123; return Reflect.set(...arguments) &#125;&#125;) 关于vue中数据响应式的原理对数据进行侦测 在vue2.X中，实现一个observe类，对于对象数据，通过Object.defineProperty来劫持对象的属性，实现getter和setter方法，这样就可以在getter的时候知道谁（订阅者）读取了数据，即谁依赖了当前的数据，将它通过Dep类（订阅器）收集统一管理，在setter的时候调用Dep类中的notify方法通知所以相关的订阅者进行更新视图。如果对象的属性也是一个对象的话，则需要递归调用observe进行处理。 对于数组则需要另外处理，通过实现一个拦截器类，并将它挂载到数组数据的原型上，当调用push/pop/shift/unshift/splice/sort/reverse修改数组数据时候，相当于调用的是拦截器中重新定义的方法，这样在拦截器中就可以侦测到数据改变了，并通知订阅者更新视图。 vue3中使用Proxy替代了Object.defineProperty，优点在于可以直接监听对象而非属性、可以直接监听数组的变化、多达13种拦截方法。缺点是兼容性还不够好。Proxy作为新标准将受到浏览器厂商重点持续的性能优化。对模板字符串进行编译 实现Compile解析器类，将template中的模板字符串通过正则等方式进行处理生成对应的ast（抽象语法树），通过调用定义的不同钩子函数进行处理，包括开始标签（start）并判断是否自闭和以及解析属性、结束标签（end）、文本（chars）、注释（comment） 将通过html解析与文本解析的ast进行优化处理，在静态节点上打标记，为后面dom-diff算法中性能优化使用，即在对比前后vnode的时候会跳过静态节点不作对比。 最后根据处理好的ast生产render函数，在组件挂载的时候调用render函数就可以得到虚拟dom。虚拟dom vnode的类型包括注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点，VNode可以描述的多种节点类型，它们本质上都是VNode类的实例，只是在实例化的时候传入的属性参数不同而已。 通过将模板字符串编译生成虚拟dom并缓存起来，当数据发生变化时，通过对比变化前后虚拟dom，以变化后的虚拟dom为基准，更新旧的虚拟dom，使它和新的一样。把dom-diff过程叫做patch的过程，其主要做了三件事，分别是创建/删除/更新节点。 对于子节点的更新策略，vue中为了避免双重循环数据量大时候造成时间复杂度高带来的性能问题，而选择先从子节点数组中4个特殊位置进行对比，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。如果四种情况都没有找到相同的节点，则再通过循环方式查找。实现简易的vue双向数据绑定vue的双向数据绑定主要是指，数据变化更新视图变化，视图变化更新数据。 实现代码如下*12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width= , initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"myVue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123;name&#125;&#125; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;input type=\"text\" v-model=\"test\"&gt; &lt;span&gt;&#123;&#123;test&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; let vm = new vue(&#123; el: '#app', data: &#123; name: 'YoLinDeng', message: '打篮球', test: '双向绑定数据' &#125; &#125;) // console.log(vm._data) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class vue extends EventTarget &#123; constructor(option) &#123; super() this.option = option this._data = this.option.data this.el = document.querySelector(this.option.el) this.compileNode(this.el) this.observe(this._data) &#125; // 实现监听器方法 observe(data) &#123; const context = this // 使用proxy代理，劫持数据 this._data = new Proxy(data, &#123; set(target, prop, newValue) &#123; // 自定义事件 let event = new CustomEvent(prop, &#123; detail: newValue &#125;) // 发布自定义事件 context.dispatchEvent(event) return Reflect.set(...arguments) &#125; &#125;) &#125; // 实现解析器方法，解析模板 compileNode(el) &#123; let child = el.childNodes let childArr = [...child] childArr.forEach(node =&gt; &#123; if (node.nodeType === 3) &#123; let text = node.textContent let reg = /\\&#123;\\&#123;\\s*([^\\s\\&#123;\\&#125;]+)\\s*\\&#125;\\&#125;/g if (reg.test(text)) &#123; let $1 = RegExp.$1 this._data[$1] &amp;&amp; (node.textContent = text.replace(reg, this._data[$1])) // 监听数据更改事件 this.addEventListener($1, e =&gt; &#123; node.textContent = text.replace(reg, e.detail) &#125;) &#125; &#125; else if (node.nodeType === 1) &#123; // 如果是元素节点 let attr = node.attributes // 判断属性中是否含有v-model if (attr.hasOwnProperty('v-model')) &#123; let keyName = attr['v-model'].nodeValue node.value = this._data[keyName] node.addEventListener('input', e =&gt; &#123; this._data[keyName] = node.value &#125;) &#125; // 递归调用解析器方法 this.compileNode(node) &#125; &#125;) &#125;&#125;","categories":[{"name":"框架原理","slug":"框架原理","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"}]},{"title":"手写防抖与节流函数","slug":"手写防抖与节流函数","date":"2021-05-21T07:51:32.000Z","updated":"2021-05-21T07:53:51.914Z","comments":true,"path":"2021/05/21/手写防抖与节流函数/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们经常会绑定一些持续触发的事件，比如resize、scroll、mousemove等等，如果事件调用无限制，会加重浏览器负担，导致用户体验差，我们可以使用debounce(防抖)和throttle(节流)的方式来减少频繁的调用，同时也不会影响实际的效果。 防抖的概念触发事件后n秒后才执行函数，如果在n秒内触发了事件，则会重新计算函数执行时间防抖函数可以分为立即执行，和非立即执行两个版本 非立即执行版本 1234567891011function debounce(fn, wait) &#123; let timer = null return function () &#123; const context = this const args = arguments timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125;&#125; 此函数一开始不会马上执行，而是等到用户操作结束之后等待wait秒后才执行，如果在wait之内用户又触发了事件，则会重新计算 立即执行版本 1234567891011121314function debounce(fn, wait) &#123; let timer = null return function () &#123; const args = arguments const now = !timer timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; timer = null &#125;, wait) if (now) &#123; fn.apply(this, args) &#125; &#125;&#125; 立即执行就是触发事件后马上先执行一次，直到用户停止执行事件等待wait秒后再执行一次 我们可以将两种版本合并成一种 12345678910111213141516171819202122232425/** * @desc 函数防抖 * @param fn 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表示非立即执行 */ function debounce(fn, wait, immediate) &#123; let timer = null return function () &#123; const context = this const args = arguments timer &amp;&amp; clearTimeout(timer) if (immediate) &#123; const now = !timer timer = setTimeout(() =&gt; &#123; timer = null &#125;, wait) now &amp;&amp; fn.apply(context, args) &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125; &#125; &#125; 节流的概念连续触发事件但在n秒内只执行一次函数对于节流有时间戳和定时器两种版本 时间戳版本123456789101112function throttle(fn, wait) &#123; var prev = 0 return function () &#123; let now = Date.now() let context = this let args = arguments if (now - prev &gt; wait) &#123; fn.apply(context, args) prev = now &#125; &#125;&#125; 在持续触发事件的过程中，函数会立即执行，用户在wait秒内不管执行多少次事件，都会等待wait秒后再执行。 定时器版本12345678910111213function throttle(fn, wait) &#123; var timer = null return function () &#123; const context = this const args = arguments if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null fn.apply(context, args) &#125;, wait) &#125; &#125;&#125; 在触发事件的过程中，不会立即执行，并且每wait秒执行一次，在停止触发事件后还会再执行一次。 时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 将两种方式合并 12345678910111213141516171819202122232425262728293031/** * @desc 函数节流 * @param fn 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */ function throttle(fn, wait, type) &#123; if (type === 1) &#123; var prev = 0 &#125; else &#123; var timer = null &#125; return function() &#123; const context = this const args = arguments if (type === 2) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null fn.apply(context, args) &#125;, wait) &#125; &#125; else if(type === 1) &#123; const now = Date.now() if (now - prev &gt; wait) &#123; fn.apply(context, args) prev = now &#125; &#125; &#125; &#125; 参考链接","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"sass常用方法","slug":"sass常用方法","date":"2021-05-21T07:37:26.000Z","updated":"2021-05-21T07:37:47.825Z","comments":true,"path":"2021/05/21/sass常用方法/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/sass%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、什么是sassSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，提供了许多便利的写法，大大提高的开发效率。下面总结了SASS的主要用法，想要了解更多可以查阅文档 二、安装1、由于sass依赖于Ruby，因此需要先安装Ruby，然后执行gem install sass2、若在vue-cli或react-create-app中使用，在项目中安装依赖： 12npm install node-sass --save-devnpm install sass-loader --save-dev 三、基础用法3.1 变量SASS允许使用变量，所有变量以$开头 1234$color: #ccc;div &#123; color: $color;&#125; 如果变量需要镶嵌在属性中之中，就必须需要写在#{}之中 1234$side: right;div &#123; border-#&#123;$side&#125;-radius: 10px;&#125; 3.2 计算能力SASS允许在代码中使用算式 123456$var: 10px;div &#123; width：(20px/2); top: 10px + 20px; left: $var * 2&#125; 3.3 嵌套能力一般我们写多个选择器时，一般这样： 123div h2 &#123; border:1px solid #ccc;&#125; 使用sass可以写成： 12345div &#123; h2 &#123; border:1px solid #ccc; &#125;&#125; 属性也可以嵌套,比如font-size属性，可以写成 12345div &#123; font：&#123; size：18px; &#125;&#125; 可以使用&amp;引用父元素 1234div &#123; &amp;::after &#123; &#125;&#125; 四、代码重用4.1 继承SASS允许一个选择器，继承另一个选择器 123.class1 &#123; color: #ccc;&#125; 如果要继承class1，需要使用@extend命令 1234.class2 &#123; @extend .class1; font-size: 18px;&#125; 4.2 Mixin(混合)使用@mixin声明代码块，达到重用代码块的作用，在需要用的地方使用@include调用 123456@mixin right &#123; margin-right: 20px;&#125;div &#123; @include right;&#125; @minxin可以设置参数以及参数默认值 123456@mixin left($value: 20px) &#123; margin-left: $value;&#125;div &#123; @include left(10px)&#125; 4.3 颜色函数1234lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 4.4 引入文件使用@import命令，用来引入外部文件@import 文件路径 五、进阶用法5.1 条件语句12345678div &#123; @if computed($width) &gt; 10 &#123; width: 10% &#125; @if computed($height) &gt; 10 &#123; height: 10px; &#125; @else &#123; height: 20px; &#125;&#125; 5.2 循环语句for循环: 12345@for $i from 1 to 10 &#123; .content-#&#123;$i&#125; &#123; width: #&#123;$i&#125;px; &#125; &#125; while循环: 12345 $x: 6; @while $x &gt; 0 &#123; .item-#&#123;$x&#125; &#123; width: $x + 10px; &#125; $x: $x - 1; &#125;z each: 12345@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url(\"/image/#&#123;$member&#125;.jpg\"); &#125; &#125; 自定义函数1234567 @function count($n) &#123; @return $n + 1; &#125; div &#123; width: count(5px); &#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scss","slug":"scss","permalink":"http://yolindeng.gitee.io/myblog/tags/scss/"}]},{"title":"vue-cli中使用svgIcon","slug":"vue-cli中使用svgIcon","date":"2021-05-21T03:28:04.000Z","updated":"2021-05-21T03:28:39.990Z","comments":true,"path":"2021/05/21/vue-cli中使用svgIcon/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/vue-cli%E4%B8%AD%E4%BD%BF%E7%94%A8svgIcon/","excerpt":"","text":"一、安装依赖包123npm install svg-sprite-loader -D或者yarn add svg-sprite-loader -D 二、配置vue.config.js文件在顶部写入 1234const path = require('path')function resolve (dir) &#123; return path.join(__dirname, dir)&#125; 在chainWebpack中增加下列配置 12345678910chainWebpack (config) &#123; config.module.rule('svg') .exclude.add(resolve('src/icons')) config.module.rule('icons') .test(/\\.svg$/) .include.add(resolve('./src/icons')).end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options(&#123; symbolId: 'icon-[name]' &#125;) &#125; 三、实现SvgIcon组件组件结构如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;svg :class=\"svgClass\" v-on=\"$listeners\"&gt; &lt;use :xlink:href=\"iconName\" /&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String, default: '' &#125; &#125;, computed: &#123; iconName () &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass () &#123; if (this.className) &#123; return 'svg-icon ' + this.className &#125; else &#123; return 'svg-icon' &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 四、根目录下创建icons/svg目录 用于存放我们所需要用的svg文件 五、新建plugins目录及index.js文件1234567import Vue from 'vue'import SvgIcon from '@/components/SvgIcon'const req = require.context('@/icons/svg', true, /\\.svg$/)req.keys().map(req)Vue.component('svg-icon', SvgIcon) 其作用是在Vue实例上创建SvgIcon组件，其中require.context的作用是获取一个特定的上下文,遍历文件夹中的指定文件，主要用来实现自动化导入模块 最后在main.js中引入plugins, import &#39;@/plugins&#39; 六、SvgIcon 组件的使用1&lt;svg-icon icon-class=\"icon-name\" class=\"down\"&gt;&lt;/svg-icon&gt; 其中icon-class为svg文件名， class为类名","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"},{"name":"组件化","slug":"组件化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"模块化","slug":"模块化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"vue中组件通信之findComponents","slug":"vue中组件通信之findComponents","date":"2021-05-21T03:27:02.000Z","updated":"2021-05-21T03:27:42.935Z","comments":true,"path":"2021/05/21/vue中组件通信之findComponents/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8BfindComponents/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839// 向上查找组件 context为当前组件上下文对象，componentName为组件名const findUpwardComponent = (context, componentName) =&gt; &#123; let parent = context.$parent let name = parent.$options.name while (parent &amp;&amp; (!name || !name.includes(componentName))) &#123; parent = parent.$parent if (parent) name = parent.$options.name &#125; return parent&#125;// 查找兄弟组件const findBrotherComponents = (ctx, componentName, exceptMe = true) =&gt; &#123; const $brothers = ctx.$parent.$children.filter(item =&gt; &#123; return item.$options.name &amp;&amp; item.$options.name.includes(componentName) &#125;) const index = $brothers.findIndex(item =&gt; item._uid === ctx._uid) if (exceptMe &amp;&amp; index &gt; -1) $brothers.splice(index, 1) return $brothers&#125;// 向下查找const findDownwardComponent = (context, componentName) =&gt; &#123; const $children = context.$children let bean = null if ($children.length) &#123; for (const child of $children) &#123; const name = child.$options.name if (name &amp;&amp; name.includes(componentName)) &#123; bean = child break &#125; else &#123; bean = findDownwardComponent(child, componentName) if (bean) break &#125; &#125; &#125; return bean&#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"}]},{"title":"scss实现retina屏1px边框","slug":"scss实现retina屏1px边框","date":"2021-05-21T03:25:32.000Z","updated":"2021-05-21T03:26:10.250Z","comments":true,"path":"2021/05/21/scss实现retina屏1px边框/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/scss%E5%AE%9E%E7%8E%B0retina%E5%B1%8F1px%E8%BE%B9%E6%A1%86/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// =======================// 用法： // @include retina-border(1,1,1,1);// 数值 代表 各 边框的宽度 上右下左// =======================@mixin _border-scale($dpr) &#123; width: 100% * $dpr; height: 100% * $dpr; -webkit-transform: scale(1 / $dpr); -webkit-transform-origin: 0 0; transform: scale(1 / $dpr); transform-origin: 0 0;&#125;@mixin _border-base() &#123; content: \"\"; position: absolute; top: 0; left: 0; pointer-events: none;&#125;@mixin retina-border($top: 0, $right: 0, $bottom: 0, $left: 0, $cor: #000000) &#123; position: relative; &amp;::before &#123; border-top: #&#123;$top&#125;px solid $cor; border-right: #&#123;$right&#125;px solid $cor; border-bottom: #&#123;$bottom&#125;px solid $cor; border-left: #&#123;$left&#125;px solid $cor; @include _border-base(); @media screen and (-webkit-min-device-pixel-ratio: 1) &#123; @include _border-scale(1); &#125; @media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123; @include _border-scale(1.5); &#125; @media screen and (-webkit-min-device-pixel-ratio: 2) &#123; @include _border-scale(2); &#125; @media screen and (-webkit-min-device-pixel-ratio: 3) &#123; @include _border-scale(3); &#125; &#125;&#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scss","slug":"scss","permalink":"http://yolindeng.gitee.io/myblog/tags/scss/"}]},{"title":"常用的git命令操作","slug":"常用的git命令操作","date":"2021-05-21T03:21:47.000Z","updated":"2021-05-21T03:24:39.088Z","comments":true,"path":"2021/05/21/常用的git命令操作/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","excerpt":"","text":"安装在使用git之前需要先安装它下载git 以windows系统为例子，安装完成后，鼠标右键点击桌面，出现Git Bash Here和 Git GUI Here 说明安装成功。 命令设置用户名和邮箱12git config --global user.name \"\" git config --global user.email \"\" 克隆远程仓库与代码提交1、在github上新建项目new repositories后，复制https地址或ssh2、在相应的目录，右键选择 git bash here 进入 git操作界面3、输入 git clone “复制的仓库地址”4、对仓库内存进行修改5、cd 文件夹名称（进入文件夹）6、git add .（或git add –all）7、git commit -m “需要写的提交说明”8、git push 其中git add . 与git add –all的区别是:（1）.git add –all可以提交未跟踪、修改和删除文件。（2）.git add .可以提交未跟踪和修改文件，但是不处理删除文件。 创建新的分支1git checkout -b 分支名称 （创建并切换至该分支） 注：新建的分支第一次push： git push -u origin 分支名 查看当前分支12git branch // 本地分支git branch -a // 所以分支,包括线上 删除分支12git branch -D 分支名 // 删除本地分支git push origin --delete 分支名 // 删除远程分支 切换分支1git checkout 分支名 合并分支123456789101112131415161718191、先切换到master分支 git checkout master2、拉取最新代码 git pull3、切换到自己的分支 并将master分支与自己的分支合并，然后解决冲突git merge master 解决完冲突后，git add --all git commit -m\"\"git fetch origin master// 虚拟的更新远程的mastergit merge origin/master //合并远程mastergit push 推到自己的远程分支4、切换到 master 分支5、将自己的分子合并到master 分支git merge 分支名 跟踪到远程名字相同的分支1git branch --set-upstream-to=origin/分支名 分支名 将更改加入暂存区12345git stash save \"描述信息\"git stash list : 显示保存列表。git stash pop 恢复最近保存的记录并把恢复的记录从保存列表中删除 查看与生成公钥进入该目录并列出其中内容： 12345cd ~/.sshlscat id_rsa.pub // 查看公钥 设置邮箱与用户名 123git config --global user.name \"\"git config --global user.email \"\" 清理之前的公钥 12345mkdir key_backupcp id_rsa* key_backuprm id_rsa* 生成 1ssh-keygen -t rsa -C \"邮箱号\" // C是大写 查看 1cat id_rsa.pub 版本回滚查看版本 1git log -num // num: 版本数量 回滚到指定的版本 1git reset --hard id // id: 版本id","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yolindeng.gitee.io/myblog/tags/git/"}]},{"title":"vue中实现倒计时组件与毫秒效果","slug":"vue中实现倒计时组件与毫秒效果","date":"2021-05-21T03:10:58.000Z","updated":"2021-05-21T03:20:28.928Z","comments":true,"path":"2021/05/21/vue中实现倒计时组件与毫秒效果/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%AF%AB%E7%A7%92%E6%95%88%E6%9E%9C/","excerpt":"","text":"时分秒倒计时组件template12345678910111213141516171819202122232425&lt;template&gt; &lt;!-- 倒计时组件 --&gt; &lt;div class=\"downTime-wrapper\"&gt; &lt;!-- 这里是显示还未结束时的内容，这里只是我这得布局，你可以随意。 --&gt; &lt;div class=\"time\" v-show=\"!isShow\"&gt; &lt;!-- &lt;span class=\"hour\"&gt;&#123;&#123;myDay&#125;&#125;&lt;/span&gt; : --&gt; &lt;div class=\"hour\"&gt; &lt;span&gt;&#123;&#123; getHours1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getHours2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;span class=\"dian\"&gt;:&lt;/span&gt; &lt;div class=\"minute\"&gt; &lt;span&gt;&#123;&#123; getMinutes1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getMinutes2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;span class=\"dian\"&gt;:&lt;/span&gt; &lt;div class=\"second\"&gt; &lt;span&gt;&#123;&#123; getSeconds1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getSeconds2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 这里是显示结束后的内容 --&gt; &lt;span class=\"second\" v-show=\"isShow\"&gt;&#123;&#123;clocker&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; script12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;script&gt;export default &#123; name: 'downTime', props: &#123; // 接收父组件传递过来的参数,这里传了 结束时间 - 开始时间 - 结束后显示的内容 endTime: &#123; type: Number &#125;, startTime: &#123; type: Number &#125;, endMsg: &#123; type: String &#125; &#125;, data () &#123; return &#123; isShow: false, // 控制显示结束或还未结束显示的内容 clocker: '', // 结束后显示的内容 timeObj: null, // 时间对象,下方会用到 myDay: 0, // 我定义来接收计算出来的 天 的 myHours: 0, // 我定义来接收计算出来的 小时 的 myMinutes: 0, // 我定义来接收计算出来的 分钟 的 mySeconds: 0// 我定义来接收计算出来的 秒钟 的 &#125; &#125;, computed: &#123; getHours1 () &#123; return this.myHours &lt; 10 ? 0 : parseInt((this.myHours % 100) / 10) &#125;, getHours2 () &#123; return parseInt(this.myHours % 10) &#125;, getMinutes1 () &#123; return this.myMinutes &lt; 10 ? 0 : parseInt((this.myMinutes % 100) / 10) &#125;, getMinutes2 () &#123; return parseInt(this.myMinutes % 10) &#125;, getSeconds1 () &#123; return this.mySeconds &lt; 10 ? 0 : parseInt((this.mySeconds % 100) / 10) &#125;, getSeconds2 () &#123; return parseInt(this.mySeconds % 10) &#125; &#125;, mounted () &#123; &#125;, methods: &#123; option () &#123; // 计算时间差 let timeLag = (this.endTime - this.startTime) / 1000 // 判断当前是否时分秒的值是否大于10 const add = num =&gt; &#123; return num &lt; 10 ? '0' + num : num &#125; // 时间倒计时运算的方法 const timeFunction = () =&gt; &#123; const time = timeLag-- this.timeObj = &#123; // 时间对象 seconds: Math.floor(time % 60), minutes: Math.floor(time / 60) % 60, hours: Math.floor(time / 60 / 60) % 24, days: Math.floor(time / 60 / 60 / 24) &#125; // 计算出时分秒 this.myDay = `$&#123;add(this.timeObj.days)&#125;` this.myHours = `$&#123;add(this.timeObj.hours)&#125;` this.myMinutes = `$&#123;add(this.timeObj.minutes)&#125;` this.mySeconds = `$&#123;add(this.timeObj.seconds)&#125;` // 当时间差小于等于0时,停止倒计时 if (time &lt;= 0) &#123; this.isShow = true this.clocker = this.endMsg clearInterval(go) &#125; &#125; // 开始执行倒计时 timeFunction() // 每一秒执行一次 const go = setInterval(() =&gt; &#123; timeFunction() &#125;, 1000) &#125; &#125;, watch: &#123; endTime: &#123; handler (newName, oldName) &#123; this.option() &#125;, immediate: true, deep: true &#125; &#125;&#125;&lt;/script&gt; 备注：我将时分秒使用计算属性分成了个位和十位两部分展示，在watch中深度监听endTime属性的变化并重新调用定时器 style1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style lang=\"scss\" scoped&gt;.downTime-wrapper&#123; display: inline-block; .dian &#123; font-weight: bold; position: relative; top: -5px; &#125; .hour&#123; display: inline-block; font-size: 36px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125; .minute&#123; display: inline-block; font-size: 36px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125; .second &#123; display: inline-block; font-size: 36px; margin-top: -5px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125;&#125;&lt;/style&gt; 使用在页面中引入并注册后即可使用 12345&lt;timer :endTime=\"item.endTime\" :startTime=\"new Date().getTime()\" :endMsg=\"item.endMsg\"&gt;&lt;/timer&gt; 毫秒倒计时效果在template中加入&lt;b id=&quot;timehs&quot;&gt;:00&lt;/b&gt; 声明timeDt方法 123456789101112131415161718methods: &#123; timeDt () &#123; this.timer1 = setTimeout(function () &#123; var haomiao = 99 document.getElementById('timehs').innerHTML = ':' + haomiao this.timer2 = setInterval(function () &#123; const timehs = document.getElementById('timehs') if (timehs) &#123; timehs.innerHTML = `:$&#123;haomiao &lt; 10 ? `0$&#123;haomiao&#125;` : haomiao&#125;` &#125; haomiao-- if (haomiao &lt; 0) &#123; haomiao = 99 &#125; &#125;, 10) &#125;, 1000) &#125; &#125; 在create生命周期函数中调用timeDt方法 12345created () &#123; this.$nextTick(() =&gt; &#123; this.timeDt() &#125;) &#125;,","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"},{"name":"组件化","slug":"组件化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"Mongoose在egg中的运用","slug":"Mongoose在egg中的运用","date":"2021-05-21T03:04:54.000Z","updated":"2021-05-21T03:08:49.103Z","comments":true,"path":"2021/05/21/Mongoose在egg中的运用/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/Mongoose%E5%9C%A8egg%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"Mongoose是什么？Mongoose是MongoDB的一个对象模型工具，封装了许多MongoDB对文档的的增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。###在egg项目中如何使用？ 1、安装npm i egg-mongoose --save 2、配置在根目录下的/config/plugin.js中配置插件 1234exports.mongoose = &#123; enable: true, package: 'egg-mongoose',&#125;; 3、连接数据库在根目录下的/config/config.default.js增加配置，其中url为我们的数据库地址，可通过环境变量来区分开发环境还是生产环境，并且确定是否使用用户名密码的数据库const prod = process.env.npm_config_server_prod; 12345678mongoose: &#123; client: &#123; url: prod ? 'mongodb:eggadmin:123456@localhost:27017/DbName' : 'mongodb://127.0.0.1:27017/DbName', options: &#123; useUnifiedTopology: true, &#125;, &#125;, &#125;, 4、配置与使用（1）数据表配置在app目录下新建model文件夹，在model文件夹下新建JS文件作为数据表的配置内容，下面以书籍表的配置为例 123456789101112131415161718192021222324252627282930'use strict';/** * @description: Mongoose book Schema, */module.exports = app =&gt; &#123; const mongoose = app.mongoose; const Schema = mongoose.Schema; const BookSchema = new Schema(&#123; desc: &#123; type: String &#125;, /* 书籍描述 */ name: &#123; type: String &#125;, /* 书籍名称 */ press: &#123; type: String &#125;, /* 出版社 */ author: &#123; type: String &#125;, /* 作者 */ image: &#123; type: Array &#125;, /* 书籍图片列表*/ price: &#123; type: String &#125;, /* 价格 */ book_type: &#123; /* 书籍分类id */ type: Schema.Types.ObjectId, ref: 'BookClassify', &#125;, user: &#123; /* 书籍发布者id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, create_time: &#123; type: String &#125;, /* 创建时间 */ status: &#123; type: String &#125;, /* 状态，1：待购买，2：已购买*/ look: &#123; type: Number &#125; /* 浏览数量 */ &#125;); return mongoose.model('Book', BookSchema);&#125;; 可以看到我们可以通过Schema来定义表结构，可以指定字段的类型及关联，设置完字段后就可以生成model了，这里算是非常简单的配置，更多配置方法可参考文档 (2)、使用mongoose方法配置完数据表结构后，我们就可以再service层中调用mongoose的方法对文档进行增删查改了，已书籍列表的处理逻辑为例子 12345678910111213141516171819202122232425262728293031323334353637383940async findbookList(data) &#123; const &#123; type, page, pageSize, desc, status, userId &#125; = data; const searchVal = &#123;&#125; if (type) &#123; searchVal.book_type = mongoose.Types.ObjectId(type) &#125; if (status) &#123; searchVal.status = status &#125; if (userId) &#123; searchVal.user = mongoose.Types.ObjectId(userId) &#125; const search_term = &#123; $or: [ &#123; desc: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; name: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; author: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; press: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, ], &#125;; const totalNum = await this.ctx.model.Book.find(searchVal).and(search_term).countDocuments(); const result = await this.ctx.model.Book.find(searchVal) .populate(&#123; path: 'user', select: &#123; name: 1, image: 1 &#125; &#125;) .populate(&#123; path: 'book_type' &#125;) .and(search_term) .sort(&#123; create_time: -1 &#125;) .skip((parseInt(page) - 1) * parseInt(pageSize)) .limit(parseInt(pageSize)); return result ? &#123; bean: &#123; records: result, current: page, size: result.length, total: totalNum, &#125;, ...app.config.msg.GET_SUCCESS &#125; : app.config.msg.GET_ERR;&#125; 可以看到，通过this.ctx.model.Book就可以获取到Book的model并且可以调用mongoose需要的方法，例如populate、find、and、sort、skip、limit 等等。 5、egg-Mongoose常用的方法增加数据1this.ctx.model.Book.create(data,callback); 其中data为json数据结构，callback为操作后的回调函数 查询数据获取所有数据，返回是一个数组1this.ctx.model.Book.find() 获取一个数据，返回是一个对象1this.ctx.model.Book.findOne() 条件查询1this.ctx.model.Article.find(conditions,callback); 其中conditions为查询的条件，callback为回调函数conditions有一下几种情况： 具体数据： 1this.ctx.model.Book.find(&#123;_id：5c4a19fb87ba4002a47ac4d, name: \"射雕英雄传\" &#125;, callback); 条件查询： 1234567\"$lt\" 小于\"$lte\" 小于等于\"$gt\" 大于\"$gte\" 大于等于\"$ne\" 不等于// 查询价格大于100小于200的书籍数组this.ctx.model.Book.find(&#123; \"price\": &#123; $get:100 , $lte:200 &#125;); 或查询 OR 123456\"$in\" 一个键对应多个值\"$nin\" 同上取反, 一个键不对应指定值\"$or\" 多个条件匹配, 可以嵌套 $in 使用\"$not\" 同上取反, 查询与特定模式不匹配的文档this.ctx.model.Book.find(&#123;\"name\":&#123; $in: [\"射雕\",\"倚天\"]&#125; ); 删除数据1this.ctx.model.Book.remove(conditions,callback); 更新数据1this.ctx.model.Book.update(conditions, update, callback) conditions为条件，update是更新的值对象 排序1this.ctx.model.Book.sort(&#123; create_time: -1 &#125;); 其中-1表示降序返回。 1表示升序返回 限制数量1this.ctx.model.Book.limit(number); number表示限制的个数 跳过文档返回1this.ctx.model.Book.skip(number); number表示跳过的个数,skip经常搭配limit实现分页的功能 条件数组and在find后面可使用and对查询结果进行进一步条件筛选，相当于并且的意思。 123456789const search_term = &#123; $or: [ &#123; desc: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; name: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; author: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; press: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, ], &#125;; this.ctx.model.Book.find().and(search_term) 关联查询populate123456789101112// 在model中配置字段时候指定关联的表名，就可以通过populate来进行表的关联查询user: &#123; /* 书籍发布者id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, this.ctx.model.Book.find() .populate(&#123; path: 'user', select: &#123; name: 1, image: 1 &#125; &#125;) 聚合管道Aggregate12345this.ctx.model.Template.aggregate([ &#123; $match: &#123; name &#125; &#125;, &#123; $sort: &#123; create_time: -1 &#125; &#125;, &#123; $group: &#123; _id: '$name', user_id: &#123; $first: '$modifier' &#125; &#125; &#125;, ]); Mongoose聚合管道aggregate常用的操作有$project 、$match 、$group、$sort、$limit、$skip、$lookup 表关联 批量操作bulkWrite12345678910111213141516const template_list = await ctx.model.Template.aggregate([ &#123; $sort: &#123; create_time: -1 &#125; &#125;, &#123; $group: &#123; _id: '$name', template_id: &#123; $first: '$_id' &#125;, label: &#123; $first: '$label' &#125; &#125; &#125;, ]); const update_value = []; template_list.forEach(item =&gt; &#123; if (!item.label) &#123; update_value.push(&#123; updateOne: &#123; filter: &#123; _id: item.template_id &#125;, update: &#123; label: '' &#125;, &#125;, &#125;); &#125; &#125;); await ctx.model.Template.bulkWrite(update_value); 可以进行一系列批量增加、删除、更新等操作。 mongoose还有非常多的方法可以提供给我的灵活使用，我们在使用的时候可以结合业务逻辑选择合适的方法来提高我们操作数据库的效率。在我们使用它之前可以认真的阅读官方文档","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yolindeng.gitee.io/myblog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://yolindeng.gitee.io/myblog/tags/mongoDB/"}]},{"title":"egg.js+mongoose实现二级评论","slug":"egg-js-mongoose实现二级评论","date":"2021-05-21T02:57:33.000Z","updated":"2021-05-21T02:58:54.227Z","comments":true,"path":"2021/05/21/egg-js-mongoose实现二级评论/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/egg-js-mongoose%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA/","excerpt":"","text":"1、首先我们先在model目录下新建comment.js文件，这里使用egg-mongoose进行配置表以及字段，这里关键需要parent_id作为父级字段，若默认为0则是第一级评论，如果为id，则是二级评论。 12345678910111213141516171819202122232425262728'use strict';/** * @description: Mongoose comment Schema, */module.exports = app =&gt; &#123; const mongoose = app.mongoose; const Schema = mongoose.Schema; const CommentSchema = new Schema(&#123; from: &#123; /* 评论人id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, to: &#123; /* 被评论人id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, content: &#123; type: String &#125;, /* 内容 */ create_time: &#123; type: String &#125;, /* 评论时间 */ book: &#123; /* 书籍id */ type: Schema.Types.ObjectId, ref: 'Book', &#125;, parent_id: &#123; type: String, required: true, default: 0 &#125; /* 父级 */ &#125;); return mongoose.model('Comment', CommentSchema);&#125;; 2、在controller 目录下新建comment.js 用于编写 评论相关的控制器方法，这里我定义了新增评论和查询评论，使用egg-validate进行请求参数验证如下： 123456789101112131415161718192021222324252627282930313233343536373839'use strict';const Controller = require('egg').Controller;// 定义新增评论请求参数规则const createCommentRule = &#123; from: 'string', to: &#123; type: 'string', required: false, &#125;, content: 'string', book: 'string', parentId: &#123; type: 'string', required: false, &#125;,&#125;// 定义查询评论请求参数规则const findCommentRule = &#123; book: 'string', page: 'string', pageSize: 'string'&#125;class CommentController extends Controller &#123; async create() &#123; const &#123; ctx &#125; = this; ctx.validate(createCommentRule, ctx.request.body); const result = await this.ctx.service.comment.createComment(ctx.request.body); ctx.body = result; &#125; async find() &#123; const &#123; ctx &#125; = this; ctx.validate(findCommentRule, ctx.query); const result = await this.ctx.service.comment.findComment(ctx.query); ctx.body = result; &#125;&#125;module.exports = CommentController; 在对应的控制器方法调用service层里面的方法，在service的方法进行数据库操作与逻辑处理。 3、在service目录下新建comment.js用于编写评论相关service方法。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081'use strict';/** * @description: 评论相关Service */const Service = require('egg').Service;const mongoose = require('mongoose');const dayjs = require('dayjs');module.exports = app =&gt; &#123; class CommentService extends Service &#123; /** * 新增评论 * @param &#123;Object&#125; data 包括评论人id，被评论人id，书籍id， 评论父级id，评论内容 */ async createComment(data) &#123; const &#123; from, to, content, book, parentId &#125; = data; const result = await this.ctx.model.Comment.create(&#123; from, to, content, book, parent_id: parentId ? mongoose.Types.ObjectId(parentId) : 0, create_time: dayjs().unix(), &#125;); return result ? app.config.msg.CREARE_SUCCESS : app.config.msg.CREARE_ERR; &#125; /** * 查询评论 * @param &#123;Object&#125; data 包括书籍id，页码，页数 */ async findComment(data) &#123; const &#123; book, page, pageSize &#125; = data const totalNum = await this.ctx.model.Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: 0 &#125;).countDocuments(); const oneList = await this.ctx.model.Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: 0 &#125;) .populate(&#123; path: 'from', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .populate(&#123; path: 'to', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .sort(&#123; create_time: 1&#125;) .skip((parseInt(page) - 1) * parseInt(pageSize)) .limit(parseInt(pageSize)).lean(); const Comment = this.ctx.model.Comment var promises = oneList.map(item =&gt; &#123; return Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: item._id &#125;) .populate(&#123; path: 'from', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .populate(&#123; path: 'to', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .sort(&#123; create_time: 1&#125;) .select('-__v').lean() &#125;); var list = await Promise.all(promises) oneList.forEach(item =&gt; &#123; item.items = [] list.forEach(code =&gt; &#123; if (code.length &gt; 0 &amp;&amp; item._id == code[0].parent_id) &#123; item.items = code &#125; &#125;) &#125;) return oneList ? &#123; bean: &#123; records: oneList, current: page, size: oneList.length, total: totalNum, &#125;, ...app.config.msg.GET_SUCCESS &#125; : app.config.msg.GET_ERR; &#125; &#125; return CommentService;&#125;; 注：首先我们需要查询一级评论的分页数据，然后用map遍历一级评论列表，返回一个promises数组，数组的每一项是查询该一级评论下的所有二级评论，我这里没有进行分页，也可以加上分页。使用Promise.all异步执行所有的查询函数，完成后的结果赋值为list，最后遍历一级评论列表与二级评论列表，当一级评论id 等于 二级评论列表中parent_id时候 给当前一级评论列表增加 items属性用于存放它的二级评论。 最后在router.js中定义接口路径与请求类型，如下： 1234// 新建评论router.post('/api/comment/create', controller.comment.create);// 查询评论router.get('/api/comment/find', controller.comment.find);","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yolindeng.gitee.io/myblog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://yolindeng.gitee.io/myblog/tags/mongoDB/"}]},{"title":"项目使用axios拦截器封装api","slug":"项目使用axios拦截器封装api","date":"2021-05-21T02:55:08.000Z","updated":"2021-05-21T02:58:16.365Z","comments":true,"path":"2021/05/21/项目使用axios拦截器封装api/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B0%81%E8%A3%85api/","excerpt":"","text":"在api目录下新建一个http.js，实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import Qs from 'qs'import axios from 'axios'import store from '@/store'import * as utils from '@/utils' //工具类import &#123; Toast &#125; from 'mand-mobile'const instance = axios.create(&#123; baseURL: '', // 后端接口根目录 message: true&#125;)// 错误控制const errorHandle = (status, message) =&gt; &#123; switch (status) &#123; case 401: // store.dispatch('logout') break case 403: break case 404: break default: Toast.failed(message) &#125;&#125;// axios请求拦截器/* 拦截器一般做什么？ 1. 修改请求头的一些配置项 2. 给请求的过程添加一些请求的图标 3. 给请求添加参数 */instance .interceptors .request .use(config =&gt; &#123; const token = utils.env !== 'dev' ? store.state.auth.token : '' token &amp;&amp; (config.headers.common.token = token) if (config.method === 'post' &amp;&amp; config.data) &#123; if (Object.prototype.toString.call(config.data) !== '[object FormData]') &#123; config.data = Qs.stringify(config.data) &#125; config.headers.common['Content-Type'] = 'multipart/form-data' &#125; return config &#125;, error =&gt; &#123; return Promise.reject(error) &#125;)// 响应拦截器，接受响应接口后的统一处理instance .interceptors .response .use(response =&gt; &#123; response.success = response.data.success if (response.config.message) &#123; if (!response.success) &#123; response.data.message &amp;&amp; Toast.failed(response.data.message) &#125; else &#123; response.config.method === 'post' &amp;&amp; Toast.succeed(response.data.message || '操作成功') &#125; &#125; return response &#125;, error =&gt; &#123; const &#123; response &#125; = error response ? errorHandle(response.status, response.data.message || '网络连接失败，请稍后重试！') : Toast.info('网络连接失败，请稍后重试！') return Promise.reject(error) &#125;)export const createAPI = (url, method, params, config = &#123;&#125;) =&gt; &#123; if (method === 'get') &#123; config.params = params &#125; else &#123; config.data = params &#125; return instance(&#123; url, method, ...config &#125;)&#125;export default instance 配置接口方式：在api目录下新建个index.jsimport { createAPI } from &#39;./http&#39; 123export default &#123; wxOuth: params =&gt; createAPI('/wechat/getOauthUrl', 'get', params)&#125; 最后在我们的vue组件中引入即可 import * as api from &#39;@/api&#39;调用方式为： api.wxOuth(params).then(res=&gt; {}).catch(err =&gt; {})","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"web端的微信支付可分为JSAPI与H5","slug":"web端的微信支付可分为JSAPI与H5","date":"2021-05-21T02:44:02.000Z","updated":"2021-05-21T02:53:41.403Z","comments":true,"path":"2021/05/21/web端的微信支付可分为JSAPI与H5/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/web%E7%AB%AF%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%AF%E5%88%86%E4%B8%BAJSAPI%E4%B8%8EH5/","excerpt":"","text":"web端的微信支付可分为JSAPI与H5JSAPI使用场景为微信内部，而H5支付则是使用在非微信下的外部浏览器。 1.JSAPI在微信内部可以直接唤起微信浏览器的内置对象WeixinJSBridge废话不多说直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 调用后端接口拿到JSAPI支付所需参数，我在beforeRouteEnter的时候调用。api.apply.jsApiPay(obj).then(res =&gt; &#123; if (res.data.code === '0000') &#123; vm.params = res.data.bean &#125; else &#123; alert('微信支付调起失败！') &#125; &#125;).catch(err =&gt; &#123; alert(err) &#125;)// 点击支付时候调用if (typeof WeixinJSBridge === 'undefined') &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', this.onBridgeReady(this.params), false) &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', this.onBridgeReady(this.params)) document.attachEvent('onWeixinJSBridgeReady', this.onBridgeReady(this.params)) &#125; &#125; else &#123; this.onBridgeReady(this.params) &#125;onBridgeReady (params) &#123; const that = this WeixinJSBridge.invoke( 'getBrandWCPayRequest', &#123; appId: params.appId, // 公众号名称，由商户传入 timeStamp: params.timeStamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: params.nonceStr, // 支付签名随机串，不长于 32 位 package: params.prepay_id, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*） signType: params.signType, // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: params.paySign // 支付签名 &#125;, function (res) &#123; if (res.err_msg === 'get_brand_wcpay_request:ok') &#123; that.queryOrder() // 这里是查询订单是否支付完成，然后执行成功和失败的业务逻辑 &#125; else if (res.err_msg === 'get_brand_wcpay_request:fail') &#123; alert('支付失败！') &#125; &#125; ) &#125;, 在微信支付的回调函数中，当res.err_msg 为get_brand_wcpay_request:ok 时，支付状态不一定准确，因此需要调用后端的查询订单接口，查询是否支付完成，然后再执行相应的逻辑。 2、H5支付h5相对简单，前端只需要跳转到后端返回的链接即可 1234567891011api.apply.h5Pay(&#123; title: '' orderNum: '', expireMinute: 10, redirectUrl: `$&#123;window.location.origin&#125;/pay/card?orderId=$&#123;vm.orderId&#125;` &#125;).then(res =&gt; &#123; vm.h5PayUrl = res.data.bean // 查询订单 &#125;).catch(err =&gt; &#123; alert(err) &#125;) 第一步，请求后端接口，需要传支付的标题，订单号，支付时间，重定向链接。 第二部，们只需要点击支付按钮时候跳转至后端返回链接即可。window.location.href = this.h5PayUrl需要注意的是H5支付查询订单需要用户去手动触发，因此需要增加一个确定订单的弹层。如图：查询订单是否支付成功与JSAPI一致~","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"微信体系","slug":"微信体系","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB/"}]},{"title":"前端日常开发常用技巧与方法","slug":"前端日常开发常用技巧与方法","date":"2020-06-09T10:10:36.000Z","updated":"2021-05-20T09:25:27.286Z","comments":true,"path":"2020/06/09/前端日常开发常用技巧与方法/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2020/06/09/%E5%89%8D%E7%AB%AF%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/","excerpt":"","text":"CSS部分盒子边倾斜clip-path: polygon(12% 0, 100% 0, 100% 100%, 0 100%); 禁止点击事件/鼠标事件“穿透”123div * &#123; pointer-events: none; /*链接啊，点击事件啊，都没有效果了*/ &#125; 用来控制元素在移动设备上使用滚动回弹效果123.main&#123; -webkit-overflow-scrolling: touch;&#125; 可解决在IOS中使用overflow:auto 形成的滚动条，滚动不流畅的情况 文字渐变效果12345.text-gradient&#123; background-image: linear-gradient(135deg, deeppink, deepskyblue); -webkit-background-clip: text; color: transparent;&#125; css三角形12345678910111213#triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red;&#125; JS部分JavaScript中检测数组的方法(1)、typeof操作符 这种方法对一些常用的类型检查没有问题，但对array和null 都判断为object(2)、instanceof操作符 这个操作符是检测对象的原型链是否指向构造函数的prototype对象的(3)、对象的constructor属性 123const arr = []console.log(arr.constructor === Array) // true (4)、Object.prototype.toString 123const arr = []console.log(Object.prototype.toString.call(arr) === '[object Array]') // true (5)、Array.isArray() 常用的字符串操作 字符串转化toString() 字符串分隔split() 字符串替换replace() 获取长度length 查询子字符串 indexOf 返回指定位置的字符串或字符串编码 charAt charCodeAt 字符串匹配 match 字符串拼接concat 字符串的切割或提取slice() substring() substr() 字符串大小写转化 toLowerCase toUpperCase 字符串去空格 trim() 用来删除字符串前后的空格 其中第9中三者的区别如下：（1）slice(), 参数可以是负数，负数表示从字符串最后一个位置开始切割到对应结束位置（2）substring()，参数不可为负数，切割第一个位置到第二个位置的字符串（3）substr()， 参数不可为负数，第一个参数是开始位置，第二个参数为切割的长度字符串去重const str = ‘11122223333’const arr = str.split(‘’)const uniqueStr = […new Set(arr)].join(‘’) 常用的数组操作1、Array.map()此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组2、Array.forEach()此方法是将数组中的每个元素执行传进提供的函数，没有返回值，注意和map方法区分3、Array.filter()此方法是将满足条件的元素作为一个新数组返回4、Array.every()此方法将数组所有元素进行判断返回一个布尔值，如果所有元素都符合判断条件，则返回true，否则返回false5、Array.some()此方法将数组所有元素进行判断返回一个布尔值,如果有一个元素满足判断条件，则返回true，所有元素都不满足则返回false6、Array.reduce()此方法为所有元素调用返回函数7、Array.push()在数组最后面添加新元素8、Array.shift()删除数组第一个元素9、Array.pop()删除数组最后一个元素10、Array.unshift()在数组最前面增加元素11、Array.isArray()判断是否为一个数组12、Array.concat()数组拼接13、Array.toString()数组转化为字符串14、Array.join()数组转化为字符串，并用第一个参数作为连接符15、Array.splice(开始位置，删除个数，元素)####常用对象方法1、Object.assign()用于克隆，两个参数，将第二个对象分配到第一个中2、Object.is()用于判断两个值是否相同//注意，该函数与==运算符不同，不会强制转换任何类型， 应该更加类似于===，但值得注意的是它会将+0和-0视作不同值3、Object.keys()用于返回对象可枚举的属性和方法的名称，返回一个属性或方法名称的字符串数组。4、Object.defineProperty()劫持变量的set和get方法,将属性添加到对象，或修改现有属性的特性 12345var a = &#123;&#125;;Object.defineProperty(a, 'name', &#123; value : 'kong', enumerable : true //该属性是否可枚举&#125;) 5、Object.defineProperties()可添加多个属性,与Object.defineProperty()对应,6、isPrototypeOf 123function a()&#123;&#125; var b = new a();console.log(a.prototype.isPrototypeOf(b));//true 安卓监听可视区域变化，让输入框移动至可视区域123456789if (/Android/gi.test(navigator.userAgent)) &#123; window.addEventListener('resize', function () &#123; if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') &#123; window.setTimeout(function () &#123; document.activeElement.scrollIntoViewIfNeeded(); &#125;, 0); &#125; &#125;); &#125;; vue中平滑滚动到某个位置this.$refs.rule.scrollIntoView({ block: ‘start’, behavior: ‘smooth’ }) 好用的JavaSrcipt库与模块（包）日期时间处理库1、monent.js2、day.jsday相对于monent要轻量许多 高精度数学运算number-precision 123456NP.strip(num) // strip a number to nearest right numberNP.plus(num1, num2, num3, ...) // addition, num + num2 + num3, two numbers is required at least.NP.minus(num1, num2, num3, ...) // subtraction, num1 - num2 - num3NP.times(num1, num2, num3, ...) // multiplication, num1 * num2 * num3NP.divide(num1, num2, num3, ...) // division, num1 / num2 / num3NP.round(num, ratio) // round a number based on ratio 实用工具库Lodashlodash 是一个 JavaScript 实用工具库，提供一致性，及模块化、性能和配件等功能。Lodash 消除了处理数组的麻烦，从而简化了 JavaScript、 数字、对象、字符串等","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"css","slug":"css","permalink":"http://yolindeng.gitee.io/myblog/tags/css/"}]},{"title":"JS的数据类型及深浅拷贝介绍","slug":"JS的数据类型及深浅拷贝介绍","date":"2020-06-09T10:06:22.000Z","updated":"2021-05-20T09:25:44.542Z","comments":true,"path":"2020/06/09/JS的数据类型及深浅拷贝介绍/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2020/06/09/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1、数据类型JS分为两种数据类型：基本数组类型： Number、String、Boolean、Null、Undefined、Symbol引用数组类型：Object(JS中除了基本数据类型，其他都是对象。例如数组、函数、正则表达式等) （1）基本数据类型（存放在栈中）基本数据类型是指直接存放在栈中的简单数据段，数据大小确定，内存k空间可分配，按值存放和访问注：栈(stack)和堆（heap）stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放 （2）引用数据类型（存放在堆内存中的对象）引用数据类型是存放在堆内存里的对象，而指向堆内存值的引用也就是指针是存在栈内存中的。 2、浅拷贝当我们使用对象拷贝时，如果属性是对象或者数组时，我们只是拷贝的数组或对象的引用地址，因此两者的属性值会指向同一个内存空间。实现数组的片浅拷贝使用concat、slice这个两个是技巧类，如何实现一个浅拷贝呢？简单的思路是遍历对象，把属性和属性值都放在一个新的对象中如下： 12345678910111213var shallowCopy = function(obj) &#123; // 只拷贝对象 if (typeof obj !== 'object') return; // 根据obj的类型判断是新建一个数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125;; // 遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125; &#125; return newObj;&#125; 12345let a = &#123; name: '123', obj: &#123; name: '456' &#125;&#125;const b = shallowCopy(a)b.obj.name = '666'console.log(b) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125;console.log(a) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125; 这样如果改变b中的对象，a中的对象也会同时改变。 3、深拷贝实现数组或对象的深拷贝，可以使用JSON.parse(JSON.stringify(obj))如何手写一个深度拷贝呢？思路是通过递归调用拷贝函数 12345678910var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return var newObj = obj instanceof Array ? [] : &#123;&#125; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key] &#125; &#125; return newObj&#125; 12345let a = &#123; name: '123', obj: &#123; name: '456' &#125;&#125;const b = deepCopy(a)b.obj.name = '666'console.log(b) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125;console.log(a) // &#123; name: '123', obj: &#123; name: '456' &#125; &#125; 这样就实现了深度拷贝，当改变b中对象值时，a没有发生变化。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]}],"categories":[{"name":"框架原理","slug":"框架原理","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"},{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"},{"name":"后端开发","slug":"后端开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"},{"name":"基础知识","slug":"基础知识","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"scss","slug":"scss","permalink":"http://yolindeng.gitee.io/myblog/tags/scss/"},{"name":"组件化","slug":"组件化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"模块化","slug":"模块化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"git","slug":"git","permalink":"http://yolindeng.gitee.io/myblog/tags/git/"},{"name":"node.js","slug":"node-js","permalink":"http://yolindeng.gitee.io/myblog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://yolindeng.gitee.io/myblog/tags/mongoDB/"},{"name":"微信体系","slug":"微信体系","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB/"},{"name":"css","slug":"css","permalink":"http://yolindeng.gitee.io/myblog/tags/css/"}]}