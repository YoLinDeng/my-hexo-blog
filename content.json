{"meta":{"title":"YoLinDeng's blog","subtitle":"","description":"YoLinDeng blog","author":"YoLin Deng","url":"https://yolindeng.github.io/my-hexo-blog","root":"/my-hexo-blog/"},"pages":[{"title":"关于","date":"2020-06-09T10:45:44.000Z","updated":"2022-05-17T09:38:44.151Z","comments":false,"path":"about/index.html","permalink":"https://yolindeng.github.io/my-hexo-blog/about/index.html","excerpt":"","text":"关于我 博主本名邓咏凌，来自美丽客都、世界长寿之乡梅州蕉岭。2019年毕业于广东药科大学，信息管理与信息系统专业。在成为一名出色的前端开发者的道路上不断努力，让自己变成越来越优秀。平时喜欢打篮球、短跑、唱歌、听歌，想要踏足祖国的大好河山，领略不同地域的风土人情。等到秋叶终于金黄，华发悄然苍苍，愿我们相约老地方～ 在校经历 大学四年时光是如此的短暂且美好，脑海中的点点滴滴都已成回忆，在心间不停流转。 获得二等奖学金，及运动类、社团类奖学金。三年参加了3次校运会，分别斩获2次第三，一次第一的成绩，最好成绩11.53。 大学期间最喜欢的运动莫过于篮球，成为我大学不可或缺的伙伴。 做过家教、手机销售等兼职 工作经历 广东万丈金数信息技术股份有限公司（2019.5 - 至今）前端开发工程师（初级、中级） 移动端活动营销页面、微信公众号页面、微信及支付宝小程序开发 活动组件可视化平台的前端与node后端开发（基于egg.js和mongoDB） 公司内部后台管理系统开发 百家保系列产品开发 快视秀小程序（基于uni-app）… 深圳云之家网络有限公司(金蝶云之家)（2018.12 - 2019.3）web前端开发实习生 生态圈产品移动端及管理系统功能迭代开发 配合产品、UI、UE、后端、测试，完成页面功能交互，并上线。 中山蕉神科技（2018.7 - 2018.11）H5前端开发工程师实习生 负责活动页面开发 公众号体系开发"},{"title":"About me","date":"2020-05-27T07:46:53.000Z","updated":"2020-12-15T01:45:28.823Z","comments":false,"path":"about/me.html","permalink":"https://yolindeng.github.io/my-hexo-blog/about/me.html","excerpt":"","text":""}],"posts":[{"title":"ES6的代理模式","slug":"ES6的代理模式Proxy","date":"2022-09-13T10:09:35.000Z","updated":"2022-09-13T10:10:46.714Z","comments":true,"path":"2022/09/13/ES6的代理模式Proxy/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/09/13/ES6%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FProxy/","excerpt":"","text":"语法1const proxy = new Proxy(target, handle) target: 使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理 handle: 一个通常以函数作为属性的对象，用来定制拦截行为 123456789// 例子let obj = &#123;&#125;let proxyObj = new Proxy(obj, &#123; get: function(target, propKey, receiver) &#123; return '6' &#125;&#125;)proxyObj.a // '6'obj.a // undefined 代理只会对proxy对象生效，原对象没有效果。 Handler 对象常用的方法 has： in 操作符的捕捉器。 get： 属性读取操作的捕捉器 set: 属性读取操作的捕捉器 deleteProperty: delete 操作符的捕捉器 ownKeys: Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。 apply: 函数调用操作的捕捉器。 construct: new 操作符的捕捉器 hander.get 用于代理目标对象的属性读取操作, 授受三个参数 get(target, propKey, ?receiver) target 目标对象 propkey 属性名 receiver Proxy 实例本身 12345678910111213141516const person = &#123; like: \"sing dance rap basketball\"&#125;const obj = new Proxy(person, &#123; get: function(target, propKey) &#123; if (propKey in target) &#123; return target[propKey]; &#125; else &#123; throw new ReferenceError(\"Prop name \\\"\" + propKey + \"\\\" does not exist.\"); &#125; &#125;&#125;)obj.like // sing dance rap basketballobj.cxk // Uncaught ReferenceError: Prop name \"cxk\" does not exist.// 在读取代理目标的值时，如果有值则直接返回，没有值就抛出一个自定义的错误 注意： 如果要访问的目标属性是不可写以及不可配置的，则返回的值必须与该目标属性的值相同 如果要访问的目标属性没有配置访问方法，即get方法是undefined的，则返回值必须为undefined 可撤消的Proxyproxy 有一个唯一静态的方法，Proxy.revocable(target, handler), 可以用来创建一个可撤销的代理对象 该方法的返回值是一个对象，其结构为： {&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke} proxy 表示新生成的代理对象本身，和用一般方式 new Proxy(target, handler) 创建的代理对象没什么不同，只是它可以被撤销掉。 revoke 撤销方法，调用的时候不需要加任何参数，就可以撤销掉和它一起生成的那个代理对象。 应用场景 校验器使用Proxy实现一个逻辑分离的数据格式验证器 123456789101112131415161718192021222324252627const target = &#123; id: 123, name: 'alice'&#125;const validators = &#123; name(val) &#123; return typeof val === 'string' &#125;, id(val) &#123; return typeof val === 'number' &#125;&#125;const createValidator = (target, validator) =&gt; &#123; return new Proxy(target, &#123; _validator: validator, set(target, propkey, value, proxy) &#123; let validator = this._validator[propKey](value) if (validator) &#123; return Reflect.set(target, propkey, value, proxy) &#125; else &#123; throw Error(`Cannot set $&#123;propkey&#125; to $&#123;value&#125;. Invalid type.`) &#125; &#125; &#125;)&#125; 私有属性使用Proxy轻松实现私有属性拦截 123456789101112131415161718let target = &#123; _id: 123&#125;const proxy = new Proxy(target, &#123; get(target, propkey, proxy) &#123; if (propkey[0] === '_') &#123; throw Error(`$&#123;propkey&#125; is restricted`) &#125; return Reflect.get(target, propkey, proxy) &#125;, set(target, propkey, value, proxy) &#123; if(propkey[0] === '_')&#123; throw Error(`$&#123;propkey&#125; is restricted`) &#125; return Reflect.set(target, propkey, value, proxy) &#125;&#125;)","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"vue组合式API相关知识","slug":"vue组合式API相关知识","date":"2022-09-11T07:07:32.000Z","updated":"2022-09-13T10:09:00.614Z","comments":true,"path":"2022/09/11/vue组合式API相关知识/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/09/11/vue%E7%BB%84%E5%90%88%E5%BC%8FAPI%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"","text":"setupsetup 函数是一个新的组件选项。作为在组件内使用 Composition API 的入口点 它在创建组件实例，初始化props后调用，从生命周期的角度看，他会在beforeCreate钩子之前被调用 setup会返回一个对象，该对象属性会被合并到组件模板渲染的上下文中。（ref定义的数据会自动解开，无需.value引用） setup(props, context){},接收props作为一个参数，且是响应式的，如果对其解构则会失去响应。第二个参数是上下文对象，类似vue2中的this，可以对其进行解构获取内部的一些属性。 this在setup中不可用 响应式系统APIreactive接收一个普通对象然后返回该普通对象的响应式代理。返回的对象不等于原始的对象。 1const obj = reactive(&#123; count: 0 &#125;) 等同于 2.x 的 Vue.observable() ref接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 .value 如果传入的是一个对象，则会调用reactive进行处理。 当ref作为渲染上下文的属性（通过setup函数返回），在模板中使用会自动解套，不需要写.value 当ref作为reactive对象中的属性被访问的时候也会自动解套，从 Array 或者 Map 等原生集合类中访问 ref 时，则不会。 可以通过传递范型参数来覆盖默认的推导 1const strOrNum = ref&lt;string | number&gt;('123') computed计算属性可有两种方式 传入一个getter函数，返回一个不可修改的ref对象 12const count = ref&lt;number&gt;(0)const comp = computed(() =&gt; count.value + 1) 传入一个拥有get和set函数的对象，可手动修改 1234567const count = ref&lt;number&gt;(0)const comp = computed(&#123; get: () =&gt; count.value + 1, set: val =&gt; &#123; count.value = val - 1 &#125;&#125;) readonly传入一个对象（响应式、普通）或ref，返回一个只读的代理，只读代理是深层的，对象内部的任何嵌套属性都是只读的。 watchEffect立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。 停止监听： 当 watchEffect 在组件的 setup() 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。 也可以调用其返回值来停止监听： 123456const stop = watchEffect(() =&gt; &#123; /* ... */&#125;)// 之后stop() 清理失效时的回调： 副作用传入的函数可以接收一个 onInvalidate 函数作入参, 用来注册清理失效时的回调 失效回调会被触发的条件： 副作用即将重新执行时 侦听器被停止 副作用刷新时机： 当一个用户定义的副作用函数进入队列时, 会在所有的组件更新后执行： 可以传递一个拥有 flush 属性的对象作为选项，默认是‘post’，在组件更新后执行副作用，值也可以是同步‘sync’、之前‘pre’ 12345678910111213141516171819// 同步运行watchEffect( () =&gt; &#123; /* ... */ &#125;, &#123; flush: 'sync', &#125;)// 组件更新前执行watchEffect( () =&gt; &#123; /* ... */ &#125;, &#123; flush: 'pre', &#125;) watch它类似于vue2.x的this.$watch，需要侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调。 与watchEffect对比，watch特点： 懒执行副作用 更明确哪些状态的改变会触发侦听器重新运行副作用 访问侦听状态变化前后的值 监听单个数据源 监听器的数据源可以是一个getter函数也可以是ref 1234567const state = reactive(&#123; name: 'YoLin' &#125;)watch(() =&gt; state.name, (curVal, prevVal) =&gt; &#123;...&#125;)const name = ref('YoLin')watch(name, (curVal, prevVal) =&gt; &#123; ... &#125;) 监听多个数据源 可以使用数组来同时侦听多个源 1watch([ref1, ref2], ([curRef1, curRef2], [prevRef1, prevRef2]) =&gt; &#123;&#125;) 生命周期钩子函数只能在setup() 期间同步使用 与 2.x 版本生命周期相对应的组合式 API beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate update -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroy -&gt; onUnmounted 新增的钩子函数 （用于调试） onRenderTracked onRenderTriggered 依赖注入provide/inject提供依赖注入，只能在setup中调用 12provide(key, 'dark')inject(key, 'light') inject 接受一个可选的的默认值作为第二个参数。如果未提供默认值，并且在 provide 上下文中未找到该属性，则 inject 返回 undefined。 模板Refs可以获得对模板内元素或组件实例的引用，我们可以像往常一样在 setup() 中声明一个 ref 并返回 将root暴露在渲染上下文，通过ref=”root”,绑定到dom节点上作为其ref 在 Virtual DOM patch 算法中，如果一个 VNode 的 ref 对应一个渲染上下文中的 ref，则该 VNode 对应的元素或组件实例将被分配给该 ref。 这是在 Virtual DOM 的 mount / patch 过程中执行的，因此模板 ref 仅在渲染初始化后才能访问。 配合 render 函数 / JSX 的用法 12345678910111213export default &#123; setup() &#123; const root = ref(null) return () =&gt; h('div', &#123; ref: root, &#125;) // 使用 JSX return () =&gt; &lt;div ref=&#123;root&#125; /&gt; &#125;,&#125; 在 v-for 中使用 使用函数型的 ref（3.0 提供的新功能）来自定义处理方式： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div v-for=\"(item, i) in list\" :ref=\"el =&gt; &#123; divs[i] = el &#125;\"&gt; &#123;&#123; item &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, reactive, onBeforeUpdate &#125; from 'vue' export default &#123; setup() &#123; const list = reactive([1, 2, 3]) const divs = ref([]) // 确保在每次变更之前重置引用 onBeforeUpdate(() =&gt; &#123; divs.value = [] &#125;) return &#123; list, divs, &#125; &#125;, &#125;&lt;/script&gt; 响应式系统工具集unref如果参数是一个 ref 则返回它的 value，否则返回参数本身。 12let str = ref('666')let strVal = unref(str) // '666' toReftoRef 可以用来为一个 reactive 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。 123456789let state = reactive(&#123; foo: 1, bar: 2&#125;)let fooRef = toRef(state, 'foo')fooRef.value++console.log(state.foo) // 2state.foo++console.log(fooRef.value) // 3 当要将一个 prop 中的属性作为 ref 传给组合逻辑函数时，toRef 就派上了用场： 12345export default &#123; setup(props) &#123; useSomeFeature(toRef(props, 'foo')) &#125;,&#125; toRefs把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。 当想要从一个组合逻辑函数中返回响应式对象时,用 toRefs 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 ... 操作符）返回的对象，并不会丢失响应性： 123456789101112131415161718192021// hook.jsexport const useFeature = () =&gt; &#123; const state = reactive(&#123; a: 1, b: 2 &#125;) return toRefs(state)&#125;// component or pageimport &#123; useFeature &#125; from './hook.js'export default &#123; setup() &#123; // 可以解构，不会丢失响应性 const &#123; a, b &#125; = useFeature() return &#123; a, b, &#125; &#125;,&#125; isRef检查一个值是否为一个 ref 对象 isProxy检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 isReactive检查一个对象是否是由 reactive 创建的响应式代理。 isReadonly检查一个对象是否是由 readonly 创建的只读代理。 高级响应式系统 APIcustomRefcustomRef 用于自定义一个 ref，可以显式地控制依赖追踪和触发响应，接受一个工厂函数，两个参数分别是用于追踪的 track 与用于触发响应的 trigger，并返回一个一个带有 get 和 set 属性的对象 使用customRef实现带防抖功能的v-model 1&lt;input v-model=\"text\" /&gt; 1234567891011121314151617181920212223242526function useDebouncedRef(value, delay = 200) &#123; let timer return customRef((track, trigger) =&gt; &#123; return &#123; get() &#123; track() return value &#125;, set(newVal) &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; value = newVal trigger() &#125;, delay) &#125; &#125; &#125;)&#125;export default &#123; setup() &#123; return &#123; text: useDebouncedRef('hello'), &#125; &#125;,&#125; markRaw显式标记一个对象为“永远不会转为响应式代理”，函数返回这个对象本身。 12const foo = markRaw(&#123;&#125;)console.log(isReactive(reactive(foo))) // false shallowReactive只为某个对象的私有（第一层）属性创建浅层的响应式代理，不会对“属性的属性”做深层次、递归地响应式代理，而只是保留原样。 shallowReadonly只为某个对象的自有（第一层）属性创建浅层的只读响应式代理，同样也不会做深层次、递归地代理，深层次的属性并不是只读的。 shallowRef创建一个 ref ，将会追踪它的 .value 更改操作，但是并不会对变更后的 .value 做响应式代理转换（即变更不会调用 reactive） 12345const foo = shallowRef(&#123;&#125;)// 更改对操作会触发响应foo.value = &#123;&#125;// 但上面新赋的这个对象并不会变为响应式对象isReactive(foo.value) // false toRaw返回由 reactive 或 readonly 方法转换成响应式代理的普通对象。这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发更改。不建议一直持有原始对象的引用。请谨慎使用。 1234const foo = &#123;&#125;const reactiveFoo = reactive(foo)console.log(toRaw(reactiveFoo) === foo) // true","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"}]},{"title":"微信小程序内嵌H5页面，完成微信支付闭环","slug":"微信小程序内嵌H5页面，完成微信支付闭环","date":"2022-09-06T05:36:46.000Z","updated":"2022-09-06T05:37:31.301Z","comments":true,"path":"2022/09/06/微信小程序内嵌H5页面，完成微信支付闭环/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/09/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%86%85%E5%B5%8CH5%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%AE%8C%E6%88%90%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%97%AD%E7%8E%AF/","excerpt":"","text":"前言本文介绍如何在小程序中内嵌H5，并完成微信支付的整个流程闭环。我们知道微信H5支付是通过生成特定的支付链接，并跳转到这个链接去完成支付操作的。但在微信小程序中对于内嵌的页面域名具有白名单限制，如果支付链接是第三方的无法做加白处理。 这个时候我们就得换个思路了，该怎么解决呢？咱们往下看。 实现过程小程序入口在微信小程序中新建一个页面，使用web-view组件作为内嵌H5的入口，由于后续支付需要用到appId以及openId信息，因此需要对url做带参做处理 12// page.wxml&lt;web-view src=\"&#123;&#123;url&#125;&#125;\"&gt;&lt;/web-view&gt; url处理逻辑： 1234567891011121314151617181920212223242526272829303132Page(&#123; data: &#123; url: '' &#125;, onLoad: function (options) &#123; wx.showLoading() wx.login(&#123; success: res =&gt; &#123; const code = res.code api.getUserOpenId(&#123; code &#125;, data =&gt; &#123; const openId = data.bean const params = &#123; wxAppletId: 'your appId', wxAppletOpenId: openId, ...options // 小程序启动路径的参数 &#125; this.setData(&#123; url: this.stringifyUrlArgs('your h5 url', params) &#125;) wx.hideLoading() &#125;) &#125; &#125;) &#125;, stringifyUrlArgs(url, params) =&gt; &#123; url += (/\\?/).test(url) ? '&amp;' : '?' url += Object.keys(params).map(key =&gt; `$&#123;key&#125;=$&#123;params[key]&#125;`).join('&amp;') return url &#125;&#125;) 在页面onload的时候，调用APIwx.login获取code，传递给后端换取该用户的openId，然后将appId、openId、以及启动路径参数拼接到你的H5 url 后面。这个url可以是个短链，方便后续修改不需要重新提交小程序代码审核，缩短发版的时间。只需要去修改该短链对应的H5链接即可。 H5 页面处理当我们在小程序入口处理好url后，会通过web-view组件进行访问H5链接，这个时候链接上携带了支付所必需的参数，我们上面提到如果这时候H5页面仍然还是调用生成H5支付链接的方式的话，会有页面白名单限制，导致第三方支付链接页面无法访问的情况。 这个时候我们可以绕开这个点，竟然是在小程序内部，我们可不可以使用小程序支付呢？答案当然是可以！ 处理的过程： H5页面请求后端支付接口获取微信小程序支付所必须的参数，这个时候appId和openId都是必要的，其他的信息则根据具体需求而定。 12345678// 微信小程序支付参数interface appletPayParams &#123; timeStamp: 'string', // 时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间 nonceStr: 'string', // 随机字符串，长度为32个字符以下 package: 'string', // 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*** signType?: 'string', // 签名算法，应与后台下单时的值一致 paySign: 'string' // 签名，具体见微信支付文档&#125; 由于H5是内嵌在小程序的web-view里面，当成功从后端获取到支付所需的参数后，需要通过web-view 跳到内部小程序的方式，跳转到对应的小程序支付页面进行支付操作，这个时候得使用wx.miniProgram.redirectTo进行处理，将获取到的支付参数encodeURIComponent一下再拼接到链接上。注意url是一个相对路径，如下： 1wx.miniProgram.redirectTo(&#123; url: `../insure-pay/insure-pay?payData=$&#123;encodeURIComponent(JSON.stringify(bean.applet))&#125;` &#125;) 小程序支付页新建一个支付页面，当从web-view内嵌H5页面跳转到支付页的时候，处理支付的逻辑处理，如下： 123456789101112131415161718192021Page(&#123; onLoad: function (options) &#123; const payData = decodeURIComponent(options.payData) // 支付参数 let pageSuccessUrl = '../pay-success/pay-success' // 成功页 let pageFailUrl = './insure-repay/insure-repay' // 失败页，重新支付 wx.requestPayment(&#123; ...JSON.parse(payData), success(res) &#123; wx.redirectTo(&#123; url: pageSuccessUrl, &#125;) &#125;, fail(err) &#123; console.log(err) wx.redirectTo(&#123; url: `$&#123;pageFailUrl&#125;?payData=$&#123;options.payData&#125;`, &#125;) &#125; &#125;) &#125;&#125;) 进入到支付页，会通过wx.requestPayment调起支付，将链接上的参数decodeURIComponent出来，传入API中，可通过回调函数success和fail监听成功和失败，并跳转到不同的处理页面。 总结大致的流程可以总结为一下几点： 在微信小程序建立一个入口页面，通过web-view内嵌H5，在这个页面onload的时候获取用户的openId以及appId并携带到H5链接上 在H5中获取链接携带的appId和openId，请求后端获取小程序支付所需的参数，并通过wx.miniProgram.redirectTo，从web-view重定向到小程序支付页。 在小程序支付页获取链接上携带的支付参数，通过wx.requestPaymen唤起支付，并处理成功和失败的逻辑。","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"长列表优化之虚拟列表","slug":"长列表优化之虚拟列表","date":"2022-09-01T09:35:23.000Z","updated":"2022-09-06T05:36:19.168Z","comments":true,"path":"2022/09/01/长列表优化之虚拟列表/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/09/01/%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/","excerpt":"","text":"前言虚拟列表是前端长列表优化的一个解决方案，就是将一个需要渲染所以列表项的长列表，改为只渲染可视区域内的列表项，但滚动效果还是要和渲染所有列表项的长列表一样。 使用场景： 在移动端使用下拉加载数据的时候，随着不断从服务端拉取数据，数据列表内容越来越多，导致创建了很多的节点，这个时候vue的diff就需要对比很多次，造成性能消耗和内存占用。 长列表渲染大量节点导致的问题： 占用大量 GPU 资源，导致卡顿 节点越多，就越耗费性能 虚拟列表的实现分两种： 列表项高度固定 列表项高度动态 下面以列表项高度固定为例子 实现过程在编码之前需要了解的信息： 容器高度（可视区高度）：viewport 列表项高度：itemSize 可视区域展示列表个数： viewCount 列表长度：phantomHeight （itemSize * 列表个数） 第一个元素顶部的距离：startOffset 开始元素的下标： startIndex 结尾元素的下标： endIndex 关键点就是确定需要渲染个列表个数，然后根据滚动时动态改变startIndex、endIndex、startOffset值，然后对列表项数据进行过滤切割，获取需要渲染的数据列表。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script setup lang&#x3D;&#39;ts&#39;&gt;import &#123; PropType, ref, computed &#125; from &#39;vue&#39;interface listItem &#123; index: number, num: number&#125;const props &#x3D; defineProps(&#123; data: &#123; type: Array as PropType&lt;listItem[]&gt;, default: () &#x3D;&gt; &#123;&#125; &#125;&#125;)const viewport &#x3D; ref&lt;HTMLElement&gt;()let startIndex &#x3D; ref&lt;number&gt;(0)let itemSize &#x3D; 100let viewCount &#x3D; 10let phantomHeight &#x3D; itemSize * props.data.lengthlet startOffset &#x3D; computed(() &#x3D;&gt; &#123; return startIndex.value * itemSize&#125;)let endIndex &#x3D; computed(() &#x3D;&gt; &#123; return startIndex.value + viewCount&#125;)let filterData &#x3D; computed(() &#x3D;&gt; &#123; return props.data.slice(startIndex.value, endIndex.value)&#125;)const scrollListBox &#x3D; () &#x3D;&gt; &#123; startIndex.value &#x3D; Math.floor((viewport.value?.scrollTop || 0) &#x2F; itemSize)&#125;&lt;&#x2F;script&gt;&lt;template&gt;&#123;&#123;startIndex&#125;&#125;&#123;&#123;endIndex&#125;&#125; &lt;div class&#x3D;&quot;viewport&quot; @scroll&#x3D;&quot;scrollListBox&quot; ref&#x3D;&quot;viewport&quot;&gt; &lt;div class&#x3D;&quot;v-list&quot; :style&#x3D;&quot;&#123; height: phantomHeight + &#39;px&#39;, paddingTop: startOffset + &#39;px&#39;&#125;&quot;&gt; &lt;div class&#x3D;&quot;v-list-item&quot; v-for&#x3D;&quot;item in filterData&quot; :key&#x3D;&quot;item.num&quot;&gt; &#123;&#123;item.num&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;style scoped&gt;.viewport &#123; width: 500px; height: 500px; overflow: scroll;&#125;.v-list-item &#123; height: 100px; width: 100%; background: #fff; color: #000; line-height: 100px; border-bottom: 1px solid #ccc;&#125;&lt;&#x2F;style&gt;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"了解pinia，它vuex相比有什么不同？","slug":"了解pinia，它vuex相比有什么不同？","date":"2022-08-26T05:33:22.000Z","updated":"2022-09-06T05:34:48.092Z","comments":true,"path":"2022/08/26/了解pinia，它vuex相比有什么不同？/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/08/26/%E4%BA%86%E8%A7%A3pinia%EF%BC%8C%E5%AE%83vuex%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/","excerpt":"","text":"Pinia 与vuex都是vue的全局状态管理器，可以说pinia就是vuex5，接下来本文通过vue3的形式来对比一下这两个全局状态管理器有何不同点。 安装12345// vuexnpm i vuex -S// pinia npm i pinia -S 挂载两个状态管理器都需要在main.js中挂载到vue实例上 vuex的挂载过程在src下新建store/index.js目录 1234567891011121314151617import &#123; createStore &#125; from 'vuex'export default createStore(&#123; state() &#123; return &#123; name: 'YoLin' &#125;; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;) state：全局state，类似于vue种的data，用于声明全局的状态变量。 mutations：通过commit 触发mutation来修改state，即修改state的函数，可记录追踪数据state变化。 actions：用于执行一些异步操作，并提交mutation更新state。 getters：可以看作和vue中的计算属性一样的能力。 modules： 将store分割成模块，当应用较大时使用。 在main.js上进行挂载 1234import &#123; createApp &#125; from 'vue'import App from './App.vue'import store from '@/store'createApp(App).use(store).mount('#app') 使用： 12345&lt;script setup&gt;import &#123; useStore &#125; from 'vuex'let store = useStore()console.log(store.state.name)&lt;/script&gt; pinia的挂载过程mian.js中引入 12345import &#123; createApp &#125; from \"vue\"import App from \"./App.vue\"import &#123;createPinia&#125; from 'pinia'const pinia = createPinia()createApp(App).use(pinia).mount(\"#app\") 创建store目录，目录一下每一个文件相当于一个模块，无需嵌套（通过modules引入）的方式引入模块。 store/storeA.js 1234567891011import &#123; defineStore &#125; from \"pinia\";export const storeA = defineStore(\"storeA\", &#123; state: () =&gt; &#123; return &#123; name: \"YoLin\", &#125;; &#125;, getters: &#123;&#125;, actions: &#123;&#125;,&#125;); 使用： 12345&lt;script setup&gt;import &#123; storeA &#125; from '@/store/storeA'let storeA = storeA()console.log(storeA.name)&lt;/script&gt; 可以对比看出pinia中没有mutations和mudules，在vuex中修改state需要调用mutations里的函数，才能达到追踪数据变化的目的，而pinia不需要，同步和异步都定义在actions中进行操作。pinia不需要嵌套的方式引入，一个store文件就是一个模块。 修改状态 vuex 非严格模式下，可以直接修改,但这样vuex不能够记录每一次state的变化记录，影响我们的调试 123456&lt;script setup&gt;import &#123; useStore &#125; from 'vuex'let store = useStore()vuexStore.state.name = 'hello YoLin'console.log(store.state.name)&lt;/script&gt; 严格模式下，则必须通过mutations进行修改 12345678910111213141516171819202122// store/index.jsimport &#123; createStore &#125; from \"vuex\";export default createStore(&#123; strict: true, state: &#123; name: \"YoLin\", &#125;, mutations: &#123; setName(state, data) &#123; state.name = data; &#125;, &#125;, ...&#125;); // App.vue&lt;script setup&gt;import &#123; useStore &#125; from 'vuex'let store = useStore()store.commit('setName', 'hello YoLin')&lt;/script&gt; 或者在组件中通过dispatch调用actions来提交mutations进而修改state, 123456789101112131415161718192021222324252627// store/index.jsimport &#123; createStore &#125; from \"vuex\";export default createStore(&#123; strict: true, state: &#123; name: \"YoLin\", &#125;, mutations: &#123; setName(state, data) &#123; state.name = data; &#125; &#125;, actions: &#123; changeName(&#123; commit &#125;, value) &#123; commit('setName', value) &#125; &#125; ...&#125;);// App.vue&lt;script setup&gt;import &#123; useStore &#125; from 'vuex'let store = useStore()store.dispatch('changeName', 'hello YoLin')&lt;/script&gt; 在vuex的使用中，actions中一般是先执行异步请求，当获取到后端返回的内容后，通过提交mutation的形式更新数据。 pinia 相比vuex，pinia是可以直接修改状态的。 12345&lt;script setup&gt;import &#123; storeA &#125; from '@/store/storeA'let storeA = storeA()storeA.piniaMsg = 'hello YoLin'&lt;/script&gt; 也可以通过$patch更新一个或多个数据 123456789storeA.$patch(&#123; name: 'hello YoLin', ...&#125;) // or functionstoreA.$patch((state) =&gt; &#123; state.name = 'hello YoLin' ...&#125;) 或者通过actions进行修改 123456789101112131415161718import &#123; defineStore &#125; from \"pinia\";export const storeA = defineStore(\"storeA\", &#123; state: () =&gt; &#123; return &#123; name: \"YoLin\", &#125;; &#125;, actions: &#123; setName(data) &#123; this.name = data &#125; &#125;&#125;)// App.vueimport &#123; storeA &#125; from '@/store/storeA'let storeA = storeA()storeA.setName('YoLinDeng') 重置state可以通过$reset 1storeA.$reset() pinia解构当使用es6的解构赋值对state进行解构的时候，state会失去响应式，这个时候可以使用storeToRefs来避免state失去响应式。 1234import &#123; storeA &#125; from '@/store/storeA'import &#123; storeToRefs &#125; from 'pinia'let storeA = storeA()let &#123; name &#125; = storeToRefs(storeA) getters对于getters来说vuex和pinia是一致的，它可以监听对应state的变化，动态计算返回值，getters的值也具有缓存特性，也就是只有在首次和依赖方式改变的时候才会触发getters函数执行。 modules如果项目比较大的情况，如果只使用单一模块，会显得十分的臃肿难维护，vuex允许将其分割成模块（modules），每个模块单独维护自己的state、getters、mutations、actions，而pinia每个状态库本身就是一个模块。","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"vuex","slug":"vuex","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vuex/"},{"name":"pinia","slug":"pinia","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/pinia/"}]},{"title":"前端项目代码提交规范化实践","slug":"前端项目代码提交规范化实践","date":"2022-08-19T09:16:13.000Z","updated":"2022-08-19T09:16:40.583Z","comments":true,"path":"2022/08/19/前端项目代码提交规范化实践/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/08/19/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%8C%96%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"commitizen规范提交信12// 全局安装commitizenyarn global add commitizen 12// 初始化commitizen init cz-conventional-changelog --save --save-exact 执行后在package.json下会生成以下配置 12345678&#123; ... \"config\": &#123; \"commitizen\": &#123; \"path\": \"./node_modules/cz-conventional-changelog\" &#125; &#125;,&#125; 另外还可以安装中文包 1yarn add cz-conventional-changelog-zh -D 并修改配置,可自定义: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768\"config\": &#123; \"commitizen\": &#123; \"path\": \"./node_modules/cz-conventional-changelog-zh\", \"defaultType\":\"[新增功能]\", \"types\": &#123; \"[新增功能]\": &#123; \"description\": \"新增功能点、新增需求\", \"title\": \"Features\" &#125;, \"[Bug修复]\": &#123; \"description\": \"修复Bug,线上，测试，验收阶段的bug\", \"title\": \"Bug Fixes\" &#125;, \"[文档修改]\": &#123; \"description\": \"文档增删改\", \"title\": \"Documentation\" &#125;, \"[样式修改]\": &#123; \"description\": \"样式修改(空白、格式、缺少分号等)\", \"title\": \"Styles\" &#125;, \"[代码重构]\": &#123; \"description\": \"既不修复bug也不添加新功能的更改\", \"title\": \"Code Refactoring\" &#125;, \"[性能优化]\": &#123; \"description\": \"性能优化\", \"title\": \"Performance Improvements\" &#125;, \"[测试代码]\": &#123; \"description\": \"增加测试\", \"title\": \"Tests\" &#125;, \"[编译代码]\": &#123; \"description\": \"影响构建系统或外部依赖项的更改(示例范围:gulp、broccoli、npm)\", \"title\": \"Builds\" &#125;, \"[持续集成]\": &#123; \"description\": \"对CI配置文件和脚本的更改(示例范围:Travis, Circle, BrowserStack, SauceLabs)\", \"title\": \"Continuous Integrations\" &#125;, \"[其他提交]\": &#123; \"description\": \"除src目录或测试文件以外的修改\", \"title\": \"Chores\" &#125;, \"[回退更改]\": &#123; \"description\": \"回退历史版本\", \"title\": \"Reverts\" &#125;, \"[修改冲突]\": &#123; \"description\": \"修改冲突\", \"title\": \"Conflict\" &#125;, \"[字体修改]\": &#123; \"description\": \"字体文件更新\", \"title\": \"Fonts\" &#125;, \"[删除文件]\": &#123; \"description\": \"删除文件\", \"title\": \"Delete Files\" &#125;, \"[暂存文件]\": &#123; \"description\": \"暂存文件\", \"title\": \"Stash Files\" &#125; &#125; &#125; &#125; 为了方便提交，添加package.json中scripts的配置： 123456&#123; \"scripts\": &#123; ... \"commit\": \"git add -A &amp;&amp; git cz &amp;&amp; git push\", &#125;&#125; standard-version自动化版本控制12// 安装yarn add standard-version -D 添加scripts配置 123456&#123; \"scripts\": &#123; ... \"standard\": \"standard-version\" &#125;&#125; 编写自定义脚本，进行版本号升级控制: 1234567891011121314151617181920212223242526272829// scripts/version.js/* eslint-disable */const exec = require('child_process').execconst inquirer = require('inquirer')const states = &#123; major: '版本升级（新功能不兼容旧版本时）', minor: '特性更新（添加新功能或功能增强时）', patch: '修复补丁（修复常规错误时）', skip: '跳过（谨慎！请仅在未完成时选择此项）'&#125;inquirer.prompt([ &#123; type: 'list', name: 'version', message: '请选择您要升级的版本号类型:', choices: Object.keys(states).map(k =&gt; `$&#123;k&#125;: $&#123;states[k]&#125;`) &#125;]).then((&#123; version &#125;) =&gt; &#123; const type = version.split(':')[0] if (type !== 'skip') &#123; exec(`npm run standard -- --release-as $&#123;type&#125;`) console.log('正在更新版本号.....') &#125;&#125;).catch((err) =&gt; &#123; console.error(err) process.exit(1)&#125;) 修改package.json 的scripts 中的commit配置并添加update:version命令： 1234567&#123; \"scripts\": &#123; ... \"commit\": \"git add -A &amp;&amp; git cz &amp;&amp; npm run update:version &amp;&amp; git push\", \"update:version\": \"node ./scripts/version.js\" &#125;&#125; 在运行commitizen提交后，将会执行脚本文件version.js进行版本更新，若不选择skip，则运行standard命令，会在根目录下生成CHANGELOG.md（版本更新日志文件）。 集成Husky和lint-staged Husky可以在 git 提交代码的前后，执行一系列的 git hooks，以对代码、文件等进行预设的检查，一旦检查不通过，就可以阻止当前的代码提交，避免了不规范的代码和 git 提交出现在项目中。 lint-staged 是一个专门用于在通过 git 提交代码之前，对暂存区的代码执行一系列的格式化。当 lint-staged 配合 git hooks 使用时，可以在 git 提交前的 hook 中加入 lint-staged 命令，这样就能在提交代码之前，对即将提交的代码进行格式化，成功之后就会提交代码。 1234567// 安装yarn add husky -Dyarn add lint-staged -D// 同时集成npx mrm@2 lint-staged 执行命令后，你就会看到你的 package.json 里多了一个 lint-staged 配置项，且根目录下多了一个 .husky 目录，里面就包含了 pre-commit 文件，里面包含了一个最基础的命令：npx lint-staged。 我们可以修改lint-staged的配置项已达到我们校验代码的目的，比如eslint、stylelint等等 123456789&#123; ... \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": [ \"eslint --cache --fix\", \"vue-cli-service lint\" ] &#125;&#125; 可创建其他钩子git hooks，并在文件里面编写shell脚本 12// 新增其他hooknpx husky add [fileName]","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"日常手写代码练习","slug":"日常手写代码练习","date":"2022-08-19T09:14:16.000Z","updated":"2022-08-19T09:15:54.006Z","comments":true,"path":"2022/08/19/日常手写代码练习/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/08/19/%E6%97%A5%E5%B8%B8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/","excerpt":"","text":"1、setTimeout模拟实现setInterval题目：使用setInterval 用来实现循环定时调用 可能会存在一定的问题 能用 setTimeout 解决吗? 123456789101112131415function mySetInterval(fn, time) &#123; let timer = null function interval() &#123; fn() timer = setTimeout(() =&gt; &#123; interval() &#125;, time) &#125; interval() return &#123; clear: () =&gt; &#123; clearTimeout(timer) &#125; &#125;&#125; 扩展：使用 setInterval 模拟实现 setTimeout 吗？ 123456function mySetTimeout(fn, time) &#123; let timer = setInterval(() =&gt; &#123; fn() clearInterval(time) &#125;, time)&#125; 拓展思考：setinterval 的缺陷是什么？ 1、即使调用的代码报错了，setInterval仍然会继续调用 2、无视网络延迟，在使用ajax轮询服务器数据时，它会去一遍又一遍的发送请求，如果网络不好，会导致请求堆积。 setInterval不定时。如果它调用的代码执行的时间小于定时的时间，它会跳过调用，这就导致无法按照你需要的执行次数或无法得到你想要的结果 2、 发布订阅模式题目： 实现一个发布订阅模式拥有 on emit once off 方法 123456789101112131415161718192021222324252627class EventEmitter &#123; constructor() &#123; this.events = &#123;&#125; &#125; on(type, cb) &#123; if (this.events[type]) &#123; this.events[type].push(cb) &#125; else &#123; this.events[type] = [cb] &#125; &#125; off(type, cb) &#123; this.events[type] = this.events[type].filter(x =&gt; x !== cb) &#125; once(type, cb) &#123; function fn() &#123; cb() this.off(type, fn) &#125; this.on(type, fn) &#125; emit(type, ...rest) &#123; this.events[type]?.forEach(x =&gt; &#123; x.apply(this, rest) &#125;) &#125;&#125; 3、 数组扁平化题目：实现一个方法使多维数组变成一维数组 12345// 递归function flatter(arr) &#123; if (!arr.length) return return arr.reduce((prev, curr) =&gt; Array.isArray(curr) ? [...prev, ...flatter(curr)] : [...prev, curr], [])&#125; 12345678// 迭代function flatter(arr) &#123; if (!arr.length) return while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr&#125; 4、寄生组合继承12345678910111213141516function Parent(name) &#123; this.name = name this.say = () =&gt; &#123; console.log('say') &#125;&#125;Parent.prototype.play = () =&gt; &#123; console.log('basketball')&#125;function Child(name) &#123; Parent.call(this) this.name = name&#125;Child.prototype = Object.create(Parent.prototype)Child.prototype.constructor = Child 5、 实现有并行限制的 Promise 调度器题目: JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个 12345678910111213141516171819202122232425class Scheduler &#123; constructor(limit) &#123; this.queue = [] this.maxCount = limit this.runCount = 0 &#125; add(promise) &#123; this.queue.push(promise) &#125; taskStart() &#123; for (let i = 0; i&lt; this.maxCount; i++) &#123; this.request() &#125; &#125; request() &#123; if (!this.queue || !this.queue.length || this.runCount &gt;= this.maxCount) &#123; return &#125; this.runCount++ this.queue.shift()().then(() =&gt; &#123; this.runCount-- this.request() &#125;) &#125;&#125; 6、new操作符1234567function objectFactory() &#123; const obj = &#123;&#125; const constructor = [].shift.call(arguments) obj.__proto__ = constructor.prototype const res = constructor.apply(obj, arguments) return typeof res === 'object' ? res : obj&#125; 7、call、apply、bind12345678910111213141516171819202122232425262728293031323334353637Function.prototype.myCall = function (context, ...args) &#123; if (!context || content === null) &#123; context = window &#125; // 创造唯一的key值 作为构造的context内部方法名 let fn = Symbol() context[fn] = this // 指向调用myCall的那个函数 return context[fn](...args)&#125; Function.prototype.myApply = function (context, args) &#123; if (!context || context === null) &#123; context = windw &#125; let fn = Symbol() context[fn] = this return context[fn](...args)&#125;Function.prototype.myBind = function (context, args) &#123; if (!context || context === null) &#123; context = window &#125; let fn = Symbol() context[fn] = this let _this = this const result = function (...innerArgs) &#123; if (this instanceof _this) &#123; this[fn] = _this this[fn](...[args, ...innerArgs]) &#125; else &#123; context[fn](...[...args, ...innerArgs]) &#125; &#125; result.prototype = Object.create(this.prototype) return result&#125; 8、深拷贝1234567891011121314151617181920function isObject(val) &#123; return typeof val === 'obj' &amp;&amp; val !== null&#125;function deepClone(obj, hash = new weakMap()) &#123; if (!isObject(obj)) return obj if (hash.has(obj)) &#123; return hash.get(obj) &#125; let target = Array.isArray(obj) ? [] : &#123;&#125; hash.set(obj, target) Reflect.ownKeys(obj).forEach(item =&gt; &#123; if (isObject(obj[item])) &#123; target[item] = deepClone(obj[item], hash) &#125; else &#123; target[item] = obj[item] &#125; &#125;) return target&#125; 9、instanceof1234567891011function myInstanceof(left, right) &#123; while (true) &#123; if (left === null) &#123; return false &#125; if (left.__proto__ === right.prototype) &#123; return true &#125; left = left.__proto__ &#125;&#125; 10、柯里化12345678910111213function currying(fn, ...args) &#123; const length = fn.length let allArgs = [...args] const res = (...newArgs) =&gt; &#123; allArgs = [...allArgs, ...newArgs] if (allArgs.length === length) &#123; return fn(...allArgs) &#125; else &#123; return res &#125; &#125; return res&#125; 11、冒泡排序(时间复杂度n^2)123456789101112function bubbleSort(arr) &#123; const len = arr.length for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; let flag = arr[j] arr[j] = arr[j+1] arr[j+1] = flag &#125; &#125; &#125;&#125; 12、选择排序123456789101112131415function selectSort(arr) &#123; const len = arr.length let minIndex for (let i = 0; i &lt; len - 1; i++) &#123; for (let j = i; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j &#125; &#125; if (minIndex !== i) &#123; [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]] &#125; &#125; return arr&#125; 13、插入排序 **123456789101112function insertSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; let j = i let target = arr[j] while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; target) &#123; arr[j] = arr[j - 1] j-- &#125; arr[j] = target &#125; return arr&#125; 14、快速排序(nlogn~ n^2 )123456789function quickSort(arr) &#123; if (arr.length &lt; 2) &#123; return arr &#125; const curr = arr[arr.length - 1] const left = arr.filter((item, index) =&gt; item &lt; curr &amp;&amp; index !== arr.length - 1) const right = arr.filter(item =&gt; item &gt; curr) return [...quickSort(left), curr, ...quickSort(right)]&#125; 15、归并排序( nlog(n)) **12345678910111213141516171819202122232425262728293031function merge(left, right) &#123; let res = []; let i = 0; let j = 0; while (i &lt; left.length &amp;&amp; j &lt; right.length) &#123; if (left[i] &lt; right[j]) &#123; res.push(left[i]); i++; &#125; else &#123; res.push(right[j]); j++; &#125; &#125; if (i &lt; left.length) &#123; res.push(...left.slice(i)); &#125; else &#123; res.push(...right.slice(j)); &#125; return res;&#125;function mergeSort(arr) &#123; if (arr.length &lt; 2) &#123; return arr; &#125; const mid = Math.floor(arr.length / 2); const left = mergeSort(arr.slice(0, mid)); const right = mergeSort(arr.slice(mid)); return merge(left, right);&#125; 16、二分查找（log2(n)）题目:如何确定一个数在一个有序数组中的位置 1234567891011121314151617function search(arr, target, start, end) &#123; let targetIndex = -1 let mid = Math.floor((start + end) / 2) if (arr[mid] === target) &#123; targetIndex = mid return targetIndex &#125; if (start &gt;= end) &#123; return targetIndex &#125; if (arr[mid] &lt; target) &#123; return search(arr, target, mid + 1, end) &#125; else &#123; return search(arr, target, start, mid -1) &#125;&#125; 17、防抖节流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 防抖 非立即执行function debounce(fn, wait) &#123; let timer = null return function () &#123; timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, wait) &#125;&#125;// 防抖 立即执行function debounce(fn, wait) &#123; let timer = null return function() &#123; let flag = !timer timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; timer = null &#125;, wait) if (flag) &#123; fn.apply(this, arguments) &#125; &#125;&#125;// 节流 时间戳function throttle(fn, wait) &#123; let prev = 0 return function() &#123; let now = Date.now() if (now - prev &gt; wait) &#123; fn.apply(this, arguments) prev = now &#125; &#125;&#125;// 节流 定时器function throttle(fn, wait) &#123; let timer = null return function() &#123; if (!timer) &#123; setTimeout(() =&gt; &#123; fn.apply(this, arguments) timer = null &#125;, wait) &#125; &#125;&#125; 18、LRU（最近最少使用）算法123456789101112131415161718192021222324252627class LRUCache &#123; constructor(capacity) &#123; this.secretKey = new Map() this.capacity = capacity &#125; get(key) &#123; if (this.secretKey.has(key)) &#123; let tempValue = this.secretkey.get(key) this.secretKey.delete(key) this.secretKey.set(key, tempValue) return tempValue &#125; else &#123; return -1 &#125; &#125; set(key, value) &#123; if (this.secretKey.has(key)) &#123; this.secretKey.delete(key) this.secretKey.set(key, value) &#125; else if (this.capacity &gt; this.secretKey.size) &#123; this.secretKey.set(key, value) &#125; else &#123; this.secretKey.delete(this.secretKey.keys().next.value) this.secretKey.set(key, value) &#125; &#125;&#125; 19、Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192class Promise &#123; constructor(executor) &#123; this.state = 'pending' this.value = 'undefined' this.reason = 'undefined' this.onResolvedCallbacks = [] this.onRejectedCallbacks = [] let resolve = value =&gt; &#123; this.state = 'fulfilled' this.value = value this.onResolvedCallbacks.forEach(fn =&gt; fn()) &#125; let reject = reason =&gt; &#123; this.state = 'rejected' this.reason = reason this.onRejectedCallbacks.forEach(fn =&gt; fn()) &#125; try &#123; executor(resolve, reject) &#125; catch(error) &#123; reject(error) &#125; &#125; then(onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125; let promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.state === 'fulfilled') &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value) resolve(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125; if (this.state === 'rejected') &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125; if (this.state === 'pending') &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125;) this.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason) resolvePromise(promise2,x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125; &#125;) return promise2 &#125;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if (x === promise2) &#123; return new TypeError('chaining cycle detected for promise') &#125; let called if (x != null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; let then = x.then if (typeof then === 'function') &#123; then.call(x, y =&gt; &#123; if (called) return called = true resolvePromise(promise2, y, resolve, reject) &#125;, err =&gt; &#123; if (called) return called = true reject(err) &#125;) &#125; &#125; catch(error) &#123; if (called) return called = true reject(error) &#125; &#125; else &#123; resolve(x) &#125;&#125;// resolvePromise.resolve = function(value) &#123; if (value &amp;&amp; typeof value === 'object' &amp;&amp; (value instanceof Promise)) &#123; return value &#125; return new Promise(resolve =&gt; &#123; resolve(value) &#125;)&#125;// rejectPromise.reject = function(value) &#123; return new Promise((_, reject) =&gt; &#123; reject(value) &#125;)&#125;// allPromise.all = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = [] let count = 0 let len = promises.length if (len === 0) &#123; resolve([]) &#125; promises.forEach((item, index) =&gt; &#123; Promise.resolve(item).then(res =&gt; &#123; count += 1 result[index] = res if (count === len) &#123; resolve(result) &#125; &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125;// allSettledPromise.allSettled = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = [] let count = 0 let len = promises.length if (len === 0) &#123; resolve([]) &#125; promises.forEach((item, index) =&gt; &#123; Promise.resolve(item).then(res =&gt; &#123; count += 1 result[index] = &#123; status: 'fulfiled', value: res &#125; if (len === count) &#123; resolve(result) &#125; &#125;).catch(err =&gt; &#123; count += 1 result[index] = &#123; status: 'rejected', reason: err &#125; if (len === count) &#123; resolve(result) &#125; &#125;) &#125;) &#125;)&#125;// racePromise.race = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach(item =&gt; &#123; Promise.resolve(item).then(resolve).catch(reject) &#125;) &#125;)&#125; 20、实现 DOM2JSON 一个函数，可以把一个 DOM 节点输出 JSON 的格式1234567function dom2Json(domtree) &#123; let obj = &#123;&#125; obj.name = domtree.tagName obj.children = [] domtree.childNodes.forEach(child =&gt; obj.children.push(dom2Json(child))) return obj&#125; 21、类数组转化为数组的方法123456789101112const arrayLike =document.querySelectorAll('div')// 扩展运算符[...arrayLike]// Array.fromArray.from(arrayLike)// Array.prototype.sliceArray.prototype.slice.call(arrayLike)// Array.applyArray.apply(null, arrayLike)// Array.prototype.concatArray.prototype.concat.apply([], arrayLike) 22、Object.is 实现Object.is不会转换被比较的两个值的类型，这点和===更为相似，他们之间也存在一些区别。 NaN在===中是不相等的，而在Object.is中是相等的 +0和-0在===中是相等的，而在Object.is中是不相等的 1234567Object.is = function(x, y) &#123; if (x === y) &#123; return x !== 0 || 1 / x === 1 / y &#125; return x!== x &amp;&amp; y!==y&#125; 23、 AJAX12345678910111213141516const getJson = (url) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() xhr.open('GET', url, false) xhr.setRequestHeader(\"Content-Type\", \"application/json\") xhr.onreadystatechange = function() &#123; if (xhr.readyState !== 4) return if (xhr.status === 200 || xhr.status === 304) &#123; resolve(xhr.responseText) &#125; else &#123; reject(new Error(xhr.responseText)) &#125; &#125; xhr.send() &#125;)&#125; 24、分片思想解决大数据量渲染问题12345678910111213141516171819202122let ul = document.getElementById(\"ul\")let total = 1000000 // 插入100万条数据let once = 20 // 一次插入20条let page = total / once // 总页数let index = 0 // 索引// 循环加载数据function loop(curTotal, curIndex) &#123; if (curTotal &lt;= 0) &#123; return false &#125; // 每页多少条数据 const pageCount = Math.min(curTotal, once) window.requestAnimationFrame(function () &#123; for (let i = 0; i &lt; pageCount; i++) &#123; let li = doucument.createElement('li') li.innerText = `第$&#123;curIndex + i&#125;项 ` ul.appendChild(li) &#125; loop(curTotal - pageCount, curIndex + pageCount) &#125;)&#125;loop(total, index) 25、将虚拟 Dom 转化为真实 Dom12345678910111213141516171819202122232425262728293031&#123; tag: 'DIV', attrs:&#123; id:'app' &#125;, children: [ &#123; tag: 'SPAN', children: [ &#123; tag: 'A', children: [] &#125; ] &#125;, &#123; tag: 'SPAN', children: [ &#123; tag: 'A', children: [] &#125;, &#123; tag: 'A', children: [] &#125; ] &#125; ]&#125;把上诉虚拟Dom转化成下方真实Dom&lt;div id=\"app\"&gt; &lt;span&gt; &lt;a&gt;&lt;/a&gt; &lt;/span&gt; &lt;span&gt; &lt;a&gt;&lt;/a&gt; &lt;a&gt;&lt;/a&gt; &lt;/span&gt;&lt;/div&gt; 1234567891011121314151617function _render(vnode) &#123; if (typeof vnode === 'number') &#123; vnode = String(vnode) &#125; if (typeof vnode === 'string') &#123; return document.createTextNode(vnode) &#125; const dom = ducument.createElement(vnode.tag) if (vnode.attrs) &#123; Object.keys(vnode.attrs).forEach(key =&gt; &#123; const value = vnode.attrs[key] dom.setAttribute(key, value) &#125;) &#125; vnode.children.forEach(child =&gt; dom.appendChild(_render(child))) return dom&#125; 26、实现模板字符串解析功能123456let template = '我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;';let data = &#123; name: '姓名', age: 18&#125;render(template, data); // 我是姓名，年龄18，性别undefined 123456function render(template, data) &#123; const computed = template.replace(/\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/g, function(match, key) &#123; return data[key] &#125;) return computed&#125; 27、列表转成树形结构12345678910111213141516171819function listToTree(data) &#123; let map = &#123;&#125; let treeData = [] data.forEach(item =&gt; &#123; if (!item.children) &#123; item.children = [] &#125; map[item.id] = item &#125;) data.forEach(item =&gt; &#123; let parent = map[item.pid] if (parent) &#123; parent.children.push(item) &#125; else &#123; treeData.push(item) &#125; &#125;) return treeData&#125; 28、树形结构转成列表1234567891011function treeToList(data) &#123; let result = [] data.forEach(item =&gt; &#123; result.push(item) if (item.children &amp;&amp; item.children.length &gt; 0) &#123; result.push(...treeToList(item.children)) &#125; Reflect.deleteProperty(item, 'children') &#125;) return result&#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"低代码可视化拖拽编辑器实现方案","slug":"低代码可视化拖拽编辑器实现方案","date":"2022-08-11T02:43:04.000Z","updated":"2022-08-11T02:48:53.274Z","comments":true,"path":"2022/08/11/低代码可视化拖拽编辑器实现方案/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/08/11/%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8B%96%E6%8B%BD%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言随着业务不断发展，低代码、无代码平台越来越常见，它降低开发门槛、快速响应业务需求、提升开发效率。零开发经验的业务人员通过可视化拖拽等方式，即可快速搭建各种应用。本文主要是讲解低代码可视化拖拽平台前端展示层面的实现逻辑和方案，对于后端逻辑、数据库设计、以及自动化部署等暂时没有涉及。 编码水平一般，提供给小伙伴们一些思路或学习参考。源码地址 效果展示 展示区划分首先我们需要先清晰我们要实现的UI展示效果，如下图，分为三部分（组件选项区、可视化展示区、元素配置编辑区） 1、组件选项区1.1 数据格式定义为了展示出各种元素，先定义元素的类型（文字、图片、按钮、banner、表单等等），具体数据格式如下，详情可以查看源码路径（src/config/template.ts、src/config/base.ts）,这些组件的每一项也可以存储在库，通过接口查询回来，只是这里没有实现。 template.ts: 定义所有类型自定义组件的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182export const config: any = &#123; text: [ &#123; config: &#123; name: 'content-box', noDrag: 1, slot: [ &#123; name: 'content-input', style: &#123; backgroundImage: require('@/assets/title1-left-icon.png'), backgroundRepeat: 'no-repeat', backgroundSize: 'contain', borderWidth: 0, fontSize: '14px', height: '13px', lineHeight: '32px', width: '18px' &#125;, value: '' &#125;, &#123; name: 'content-input', style: &#123; height: '32px', paddingLeft: '5px', paddingRight: '5px' &#125;, value: \"&lt;div style=\\\"line-height: 2;\\\"&gt;&lt;span style=\\\"font-size: 16px; color: #fce7b6;\\\"&gt;&lt;strong&gt;活动规则&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;\" &#125;, &#123; name: 'content-input', style: &#123; backgroundImage: require('@/assets/title1-right-icon.png'), backgroundRepeat: 'no-repeat', backgroundSize: 'contain', borderWidth: 0, fontSize: '14px', height: '13px', lineHeight: '32px', marginRight: '5px', width: '18px' &#125;, value: '' &#125; ], style: &#123; alignItems: 'center', backgroundColor: 'rgba(26, 96, 175, 1)', display: 'flex', height: '40px', justifyContent: 'center', paddingLeft: '1px' &#125;, value: '' &#125;, name: '带点的标题', preview: require('@/assets/title1.jpg') &#125; ], img: [ &#123; config: &#123; value: require('@/assets/gift.png'), name: 'content-asset', style: &#123; width: '100px', height: '100px', display: 'inline-block' &#125; &#125;, preview: require('@/assets/gift.png'), name: '礼包' &#125; ], btn: [ .... ], form: [ ... ]&#125; base.ts: 中定义基本组件的配置 123456789101112131415161718192021222324252627282930313233export const config: any = &#123; text: &#123; value: '&lt;div style=\"text-align: center; line-height: 1;\"&gt;&lt;span style=\"font-size: 14px; color: #333333;\"&gt;这是一行文字&lt;/span&gt;&lt;/div&gt;', style: &#123;&#125;, name: 'content-input' &#125;, multipleText: &#123; value: '&lt;div style=\"text-align: center; line-height: 1.5;\"&gt;&lt;span style=\"font-size: 14px; color: #333333;\"&gt;这是多行文字&lt;br /&gt;这是多行文字&lt;br /&gt;这是多行文字&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;', name: 'content-input', style: &#123;&#125; &#125;, img: &#123; value: require('@/assets/logo.png'), name: 'content-asset', style: &#123; width: '100px', height: '100px', display: 'inline-block' &#125; &#125;, box: &#123; name: 'content-box', noDrag: 0, style: &#123; width: '100%', minHeight: '100px', height: 'auto', display: 'inline-block', boxSizing: 'border-box' &#125;, slot: [] &#125;&#125; 基本元素（文字content-input、图片content-asset）主要包含以下属性: name（组件名称）、style（行内样式）、value（内容值） 盒子元素（content-box）主要包含以下属性: name（组件名称）、style（行内样式）、noDrag（是否可拖拽）、slot（插槽内容 1.2 实现可拖拽为了实现可拖拽效果，这里使用了sortable.js拖拽库来实现。更多使用细节可查看官方文档 关键实现代码如下： 12345678910111213141516171819202122232425262728293031// 左侧选项区DOM结构&lt;el-tabs tab-position=\"left\" class=\"tabs-list\" v-model=\"activeType\"&gt; &lt;el-tab-pane v-for=\"item in props.tabConfig\" :key=\"item.value\" :label=\"item.label\" :name=\"item.value\"&gt; &lt;template #label&gt; &lt;span class=\"tabs-list-item\"&gt; &lt;i :class=\"`iconfont $&#123;item.icon&#125;`\"&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;item.label&#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;/template&gt; &lt;div class=\"tab-content\"&gt; &lt;div class=\"tab-content-title\"&gt;&#123;&#123;item.label&#125;&#125;&lt;/div&gt; &lt;div class=\"main-box\" ref=\"mainBox\"&gt; &lt;div class=\"config-item base\" v-if=\"activeType === 'base'\" data-name=\"text\" @click=\"addToSubPage(Base.config['text'])\"&gt; &lt;el-icon :size=\"20\"&gt;&lt;Document /&gt;&lt;/el-icon&gt; &lt;div&gt;文本&lt;/div&gt; &lt;/div&gt; &lt;div class=\"config-item base\" v-if=\"activeType === 'base'\" data-name=\"box\" @click=\"addToSubPage(Base.config['box'])\"&gt; &lt;el-icon :size=\"20\"&gt;&lt;Box /&gt;&lt;/el-icon&gt; &lt;div&gt;盒子&lt;/div&gt; &lt;/div&gt; &lt;div class=\"config-item\" v-for=\"_item in item.children\" :key=\"_item\" :data-name=\"_item\" @click=\"addToSubPage(Base.config[_item])\"&gt; &lt;div v-if=\"activeType === 'text'\" class=\"config-item-text\" v-html=\"Base.config[_item].value\"&gt;&lt;/div&gt; &lt;img v-if=\"activeType === 'img'\" class=\"config-item-img\" :src=\"Base.config[_item].value\"/&gt; &lt;/div&gt; &lt;div class=\"config-item\" v-for=\"(tItem, tIndex) in Template.config[activeType]\" :key=\"tItem.id\" :data-type=\"activeType\" :data-index=\"tIndex\" @click=\"addToSubPage(tItem.config)\"&gt; &lt;img :src=\"tItem.preview\" class=\"preview\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; 12345678910111213141516171819202122232425const mainBox = ref()const initSortableSide = (): void =&gt; &#123; // 获取mainBox下每一个元素，遍历并注册拖拽组 Array.from(mainBox.value).forEach(($box, index) =&gt; &#123; instance[`_sortable_$&#123;index&#125;`] &amp;&amp; instance[`_sortable_$&#123;index&#125;`].destroy() instance[`_sortable_$&#123;index&#125;`] = Sortable.create($box, &#123; filter: '.ignore', // 需要过滤或忽略指定元素 sort: false, // 不允许组内排序 group: &#123; name: 'shared', // 自定义组名 pull: 'clone', // 从当前组克隆拖出 put: false, // 不允许拖入 &#125;, // 开始拖拽回调函数 onStart: () =&gt; &#123; // 给subpage展示区添加选中框样式 (document.querySelector('.subpage') as HTMLElement).classList.add('active') &#125;, // 结束拖拽回调函数 onEnd: (&#123; item, originalEvent &#125;: any) =&gt; &#123; ... &#125; &#125;) &#125;)&#125; 这里主要讲一下onEnd里面的逻辑，当拖拽组件并将其移动到中间的可视化展示区的时候，需要做以下2个关键操作。 判断是否拖拽到可视化展示区内 获取当前拖拽元素的配置，并更新pinia中store的值。(pinia是vue新一代状态管理插件，可以认为是vuex5.) 12345678910111213141516171819202122232425262728293031323334353637onEnd: (&#123; item, originalEvent &#125;: any) =&gt; &#123; // 获取鼠标放开后的X、Y坐标 const &#123; pageX, pageY &#125; = originalEvent // 获取可视化展示区的上下左右坐标 const &#123; left, right, top, bottom &#125; = (document.querySelector('.subpage') as HTMLElement).getBoundingClientRect() const &#123; dataset &#125; = item // 为了移除被clone到可视化区的dom结构，通过配置来渲染可视化区的内容 if ((document.querySelector('.subpage') as HTMLElement).contains(item)) &#123; item.remove() &#125; // 编辑判断 if (pageX &gt; left &amp;&amp; pageX &lt; right &amp;&amp; pageY &gt; top &amp;&amp; pageY &lt; bottom) &#123; // 获取自定义属性中的name、type 、index const &#123; name, type, index &#125; = dataset let currConfigItem = &#123;&#125; as any // 若存在type 说明不是基础类型,在template.ts找到对应的配置。 if (type) &#123; currConfigItem = utils.cloneDeep(Template.config[type][index].config) // 使用nanoid 生成唯一id currConfigItem.id = utils.nanoid() // 递归遍历组件内部的slot，为每个元素添加唯一id currConfigItem.slot = configItemAddId(currConfigItem.slot) &#125; else &#123; // 基础类型操作 currConfigItem = utils.cloneDeep(Base.config[name]) currConfigItem.id = utils.nanoid() &#125; // 修改pinia的store数据 templateStore.config.push(currConfigItem) // 触发更新（通过watch实现） key.value = Date.now() &#125; else &#123; console.log('false') &#125; // 移除中间可视化区选中样式 (document.querySelector('.subpage') as HTMLElement).classList.remove('active') &#125; 2、可视化展示区中间的可视化展示区的功能主要是提供用户对具体元素选中以及拖拽操作。因此主要实现元素展示 、选中框以及可拖拽功能。 2.1 元素展示元素展示比较简单，只需要通过遍历pinia的store中的页面配置config，并用动态组件component标签展示即可 12&lt;component v-for=\"item in template.config\" :key=\"item.id\" :is=\"item.name\" :config=\"item\" :id=\"item.id\"&gt;&lt;/component&gt; 2.2 实现选中框实现选中框的逻辑相对复杂一点，其中关键的两个事件是hover（鼠标悬浮在元素上）和select（鼠标点击元素）。 定义一个响应式对象来存储它们的变化情况： 1234567891011121314const catcher: any = reactive( &#123; hover: &#123; id: '', // 元素id rect: &#123;&#125;, // 元素坐标 eleName: '' // 元素类名 &#125;, select: &#123; id: '', rect: &#123;&#125;, eleName: '' &#125; &#125;) 定义事件监听器（mouseover、click） 123456789101112131415161718192021222324252627282930313233import &#123; onMounted, ref &#125; from 'vue'const subpage = ref()const listeners = &#123; mouseover: (e: any) =&gt; &#123; // findUpwardElement方法为向上查找最近的目标元素 const $el = utils.findUpwardElement(e.target, editorElements, 'classList') if ($el) &#123; catcher.hover.id = $el.id // 重置catcher响应式对象 resetRect($el, 'hover') &#125; else &#123; catcher.hover.rect.width = 0 catcher.hover.id = '' &#125; &#125;, click: (e: any) =&gt; &#123; const $el = utils.findUpwardElement(e.target, editorElements, 'classList') if ($el) &#123; template.activeElemId = $el.id catcher.select.id = $el.id resetRect($el, 'select') &#125; else if (!utils.findUpwardElement(e.target, ['mouse-catcher'], 'classList')) &#123; removeSelect() &#125; &#125;&#125; as anyonMounted(() =&gt; &#123; Object.keys(listeners).forEach(event =&gt; &#123; subpage.value.addEventListener(event, listeners[event], true) &#125;)&#125;) 定义修改catcher响应式对象方法 1234567891011121314151617181920212223242526272829303132333435interface rectInter &#123; width: number; height: number; top: number; left: number;&#125;// 修改catcher对象方法const resetRect = ($el: HTMLElement, type: string): void =&gt; &#123; if ($el) &#123; const parentRect = utils.pick(subpage.value.getBoundingClientRect(), 'left', 'top') const rect: rectInter = utils.pick($el.getBoundingClientRect(), 'width', 'height', 'left', 'top') rect.left -= parentRect.left rect.top -= parentRect.top catcher[type].rect = rect catcher[type].eleName = $el.className &#125;&#125;const removeSelect = (): void =&gt; &#123; catcher.select.rect.width = 0 catcher.select.id = '' catcher.hover.rect.width = 0 catcher.hover.id = '' template.activeElemId = ''&#125;// 重置select配置const resetSelectRect = (id: string): void =&gt; &#123; if (id) &#123; resetRect(document.getElementById(id) as HTMLElement, 'select') &#125; else &#123; removeSelect() &#125;&#125; 选中框组件 选中框组件包括选中框主体（通过不同颜色区分盒子还是元素）、功能栏（上下移动、删除、复制）。 12// 将catcher对象传入组件&lt;MouseCatcher class=\"ignore\" v-model=\"catcher\"&gt;&lt;/MouseCatcher&gt; 比较关键的点是在操作功能栏的时候对全局配置的修改，详细逻辑可以查看源码（src/components/mouse-catcher/index.vue） 2.3 实现可视区拖拽接下来是实现可视化展示区的可拖拽，这个区域与选项区不同，它允许内部元素的排序以及拖到别的拖拽组（盒子）。 关键逻辑如下：(主要分析onEnd回调中的逻辑) 123456789101112131415161718192021222324252627282930313233343536373839404142434445const initSortableSubpage = (): void =&gt; &#123; instance._sortableSubpage &amp;&amp; instance._sortableSubpage.destroy() instance._sortableSubpage = Sortable.create(document.querySelector('.subpage'), &#123; group: 'shared', filter: '.ignore', onStart: (&#123; item &#125;: any) =&gt; &#123; console.log(item.id) &#125;, onEnd: (obj: any) =&gt; &#123; let &#123; newIndex, oldIndex, originalEvent, item, to &#125; = obj // 在可视区盒子内拖拽 if (to.classList.contains('subpage')) &#123; const &#123; pageX &#125; = originalEvent const &#123; left, right &#125; = (document.querySelector('.subpage') as HTMLElement).getBoundingClientRect() // 判断是否移出可视区 if (pageX &lt; left || pageX &gt; right) &#123; // 移出可视区，则移除元素 templateStore.config.splice(oldIndex, 1) &#125; else &#123; // 判断移动位置发生更改 if (newIndex !== oldIndex) &#123; // 新的位置在最后一位，需要减1 if (newIndex === templateStore.config.length) &#123; newIndex = newIndex - 1 &#125; // 旧的位置在最后一位，需要减1 if (oldIndex === templateStore.config.length) &#123; oldIndex = oldIndex - 1 &#125; // 数据互换位置 const oldVal = utils.cloneDeep(templateStore.config[oldIndex]) const newVal = utils.cloneDeep(templateStore.config[newIndex]) utils.fill(templateStore.config, oldVal, newIndex, newIndex + 1) utils.fill(templateStore.config, newVal, oldIndex, oldIndex + 1) &#125; &#125; &#125; else &#123; // 若将元素移动至其他拖拽组（盒子） const itemIndex = templateStore.config.findIndex((x: any) =&gt; x.id === item.id) const currContentBox = utils.findConfig(templateStore.config, to.id) const currItem = templateStore.config.splice(itemIndex, 1)[0] currContentBox.slot.push(currItem) &#125; &#125; &#125;)&#125; 2.4 实现盒子内拖拽这里需要注意需要筛选可视区盒子subpage中类名为content-box，并且不包含类名为no-drag的。 其关键逻辑也是在onEnd回调函数里，需要区分元素在当前盒子内部移动、元素移动到其他盒子、元素移动到可视区（subpage）盒子三种情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const initSortableContentBox = () =&gt; &#123; console.log(Array.from(document.querySelectorAll('.subpage .content-box')).filter((x: any) =&gt; !x.classList.contains('no-drag'))) Array.from(document.querySelectorAll('.subpage .content-box')).filter((x: any) =&gt; !x.classList.contains('no-drag')).forEach(($content, contentIndex) =&gt; &#123; instance[`_sortableContentBox_$&#123;contentIndex&#125;`] &amp;&amp; instance[`_sortableContentBox_$&#123;contentIndex&#125;`].destroy() instance[`_sortableContentBox_$&#123;contentIndex&#125;`] = Sortable.create($content, &#123; group: 'shared', onStart: (&#123; from &#125;: any) =&gt; &#123; console.log(from.id) &#125;, onEnd: (obj: any) =&gt; &#123; let &#123; newIndex, oldIndex, item, to, from &#125; = obj if (to.classList.contains('subpage')) &#123; // 元素移动至可视区盒子 const currContentBox = utils.findConfig(templateStore.config, from.id) const currItemIndex = currContentBox.slot.findIndex((x: any) =&gt; x.id === item.id) const currItem = currContentBox.slot.splice(currItemIndex, 1)[0] templateStore.config.push(currItem) &#125; else &#123; if (from.id === to.id) &#123; // 同一盒子中移动 const currContentBox = utils.findConfig(templateStore.config, from.id) if (newIndex !== oldIndex) &#123; if (newIndex === currContentBox.length) &#123; newIndex = newIndex - 1 &#125; if (oldIndex === currContentBox.length) &#123; oldIndex = oldIndex - 1 &#125; const oldVal = utils.cloneDeep(currContentBox.slot[oldIndex]) const newVal = utils.cloneDeep(currContentBox.slot[newIndex]) utils.fill(currContentBox.slot, oldVal, newIndex, newIndex + 1) utils.fill(currContentBox.slot, newVal, oldIndex, oldIndex + 1) &#125; &#125; else &#123; // 从一个盒子移动到另一个盒子 const currContentBox = utils.findConfig(templateStore.config, from.id) const currItemIndex = currContentBox.slot.findIndex((x: any) =&gt; x.id === item.id) const currItem = currContentBox.slot.splice(currItemIndex, 1)[0] const toContentBox = utils.findConfig(templateStore.config, to.id) toContentBox.slot.push(currItem) &#125; &#125; &#125; &#125;) &#125;)&#125; 3、元素配置编辑区该区域是用于编辑修改元素的行内样式，目前简单实现了字体、位置布局、背景、边框、阴影配置。 3.1 字体编辑字体编辑功能使用富文本编辑器tinymce，这里使用vue3-tinymce，它是基于 vue@3.x + tinymce@5.8.x 封装的富文本编辑器。 更多配置可参考官方文档, 下面的对vue3-tinymce进行封装。 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;vue3-tinymce v-model&#x3D;&quot;state.content&quot; :setting&#x3D;&quot;state.setting&quot; &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script lang&#x3D;&quot;ts&quot; setup&gt;import &#123; reactive, watch &#125; from &#39;vue&#39;;&#x2F;&#x2F; 引入组件import Vue3Tinymce from &#39;@jsdawn&#x2F;vue3-tinymce&#39;import &#123; useTemplateStore &#125; from &#39;@&#x2F;stores&#x2F;template&#39;import &#123; findConfig &#125; from &#39;@&#x2F;utils&#39;const template &#x3D; useTemplateStore()const props &#x3D; defineProps(&#123; modelValue: &#123; type: String, default: &#39;&#39; &#125;&#125;)const state &#x3D; reactive(&#123; content: &#39;&#39;, setting: &#123; height: 300, language: &#39;zh-Hans&#39;, language_url: &#39;&#x2F;tinymce&#x2F;langs&#x2F;zh-Hans.js&#39; &#125;&#125;)watch(() &#x3D;&gt; props.modelValue, () &#x3D;&gt; &#123; props.modelValue &amp;&amp; (state.content &#x3D; findConfig(template.config, props.modelValue)?.value)&#125;)watch(() &#x3D;&gt; state.content, () &#x3D;&gt; &#123; const config &#x3D; findConfig(template.config, props.modelValue) config &amp;&amp; (config.value &#x3D; state.content)&#125;)&lt;&#x2F;script&gt; 3.2 位置布局可修改元素的内外边距、宽高、布局类型（display）、定位类型（position）。 3.3 背景可修改元素背景颜色、圆角、渐变方式。 3.4 边框可修改边框类型，包括无边框、实线、虚线、点线 3.5 阴影可修改阴影颜色、以及阴影的X、Y、距离、大小。 基础组件1、文字组件1234567891011121314151617181920212223242526272829303132&lt;script lang&#x3D;&quot;ts&quot;&gt;export default &#123; name: &quot;ContentInput&quot;&#125;;&lt;&#x2F;script&gt;&lt;script setup lang&#x3D;&#39;ts&#39;&gt;import &#123; PropType &#125; from &#39;vue&#39;;import &#123; useStyleFix &#125; from &#39;@&#x2F;utils&#x2F;hooks&#39;const props &#x3D; defineProps(&#123; config: &#123; type: Object as PropType&lt;any&gt; &#125;&#125;)&lt;&#x2F;script&gt;&lt;template&gt; &lt;div class&#x3D;&quot;content-input&quot; v-html&#x3D;&quot;props.config.value&quot; :style&#x3D;&quot;[props.config.style, useStyleFix(props.config.style)]&quot; &gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;.content-input &#123; word-break: break-all; user-select: none;&#125;&lt;&#x2F;style&gt; 2、图片组件123456789101112131415161718192021222324252627&lt;script lang&#x3D;&quot;ts&quot;&gt;export default &#123; name: &quot;ContentAsset&quot;&#125;;&lt;&#x2F;script&gt;&lt;script setup lang&#x3D;&#39;ts&#39;&gt;import &#123; PropType &#125; from &#39;vue&#39;const props &#x3D; defineProps(&#123; config: &#123; type: Object as PropType&lt;any&gt; &#125;&#125;)&lt;&#x2F;script&gt;&lt;template&gt; &lt;div class&#x3D;&quot;content-asset&quot; :style&#x3D;&quot;props.config.style&quot;&gt; &lt;img :src&#x3D;&quot;props.config.value&quot;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;img &#123; width: 100%; height: 100%;&#125;&lt;&#x2F;style&gt; 3、盒子组件12345678910111213141516171819202122&lt;script lang&#x3D;&quot;ts&quot;&gt;export default &#123; name: &quot;ContentBox&quot;&#125;&lt;&#x2F;script&gt;&lt;script setup lang&#x3D;&#39;ts&#39;&gt;import &#123; PropType &#125; from &#39;vue&#39;const props &#x3D; defineProps(&#123; config: &#123; type: Object as PropType&lt;any&gt; &#125;&#125;)&lt;&#x2F;script&gt;&lt;template&gt; &lt;div :class&#x3D;&quot;[&#39;content-box&#39;, &#123; &#39;no-drag&#39;: props.config.noDrag &#125;]&quot; :style&#x3D;&quot;props.config.style&quot;&gt; &lt;component v-for&#x3D;&quot;item in props.config.slot&quot; :key&#x3D;&quot;item.id&quot; :is&#x3D;&quot;item.name&quot; :config&#x3D;&quot;item&quot; :id&#x3D;&quot;item.id&quot;&gt;&lt;&#x2F;component&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;&lt;&#x2F;style&gt; 到这里基本的实现流程都完毕，目前的版本还比较简单，还有很多可以实现的功能，比如撤回、重做、自定义组件选项、接入数据库.","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"低代码","slug":"低代码","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"}]},{"title":"setup语法糖以及pinia的使用","slug":"setup语法糖以及pinia的使用","date":"2022-05-10T09:25:16.000Z","updated":"2022-05-17T09:41:07.654Z","comments":true,"path":"2022/05/10/setup语法糖以及pinia的使用/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/05/10/setup%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BB%A5%E5%8F%8Apinia%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"vue3 compositionAPI 相关 (vue3.2 setup语法糖)1、文件结构 vue2中限制template只能有一个根元素，vue3没有限制 2、data123456789101112131415161718&lt;script setup&gt; import &#123; reactive, ref, toRefs &#125; from &#39;vue&#39;&#x2F;&#x2F; ref声明响应式数据，用于声明基本数据类型const name &#x3D; ref(&#39;YoLin&#39;)&#x2F;&#x2F; 修改name.value &#x3D; &#39;Deng&#39;&#x2F;&#x2F; reactive声明响应式数据，用于声明引用数据类型const state &#x3D; reactive(&#123; name: &#39;YoLin&#39;, sex: &#39;男&#39;&#125;)&#x2F;&#x2F; 修改state.name &#x3D; &#39;Deng&#39;&#x2F;&#x2F; 使用toRefs解构const &#123; name, sex &#125; &#x3D; toRefs(state)&#x2F;&#x2F; 在template中可直接使用&#123;&#123; name &#125;&#125;、&#123;&#123; sex &#125;&#125;&lt;&#x2F;script&gt; 3、method1234567891011121314151617&lt;template&gt; &#x2F;&#x2F; 调用方法 &lt;button @click&#x3D;&#39;changeName&#39;&gt;按钮&lt;&#x2F;button&gt; &lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; reactive &#125; from &#39;vue&#39; const state &#x3D; reactive(&#123; name: &#39;YoLin&#39; &#125;) &#x2F;&#x2F; 声明method方法 const changeName &#x3D; () &#x3D;&gt; &#123; state.name &#x3D; &#39;Deng&#39; &#125; &lt;&#x2F;script&gt; 4、computed12345678&lt;script setup&gt; import &#123; computed, ref &#125; from &#39;vue&#39; let count &#x3D; ref(0) const doubuleCount &#x3D; computed(() &#x3D;&gt; &#123; return count.value * 2 &#125;) &lt;&#x2F;script&gt; 5、watch12345678910111213141516&lt;script setup&gt; import &#123; watch, reactive &#125; from &#39;vue&#39; const state &#x3D; reactive(&#123; count: 1 &#125;) const changeCount &#x3D; () &#x3D;&gt; &#123; state.count &#x3D; state.count * 2 &#125; watch(() &#x3D;&gt; state.count, (newVal, oldVal) &#x3D;&gt; &#123; console.log(newVal) &#125;, &#123; immediate: true, &#x2F;&#x2F;立刻执行 deep: true &#x2F;&#x2F; 深度监听 &#125;)&lt;&#x2F;script&gt; 6、props 父传子12345678910111213141516171819202122232425262728293031子组件&lt;template&gt; &lt;span&gt;&#123;&#123;props.name&#125;&#125;&lt;&#x2F;span&gt; &#x2F;&#x2F; 可省略【props.】 &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; &#x2F;&#x2F; import &#123; defineProps &#125; from &#39;vue&#39; &#x2F;&#x2F; defineProps在&lt;script setup&gt;中自动可用，无需导入 &#x2F;&#x2F; 需在.eslintrc.js文件中【globals】下配置【defineProps: true】 &#x2F;&#x2F; 声明props const props &#x3D; defineProps(&#123; name: &#123; type: String, default: &#39;&#39; &#125; &#125;) &lt;&#x2F;script&gt;父组件引入子组件，组件会自动注册 &lt;template&gt; &lt;child name&#x3D;&#39;Jerry&#39;&#x2F;&gt; &lt;&#x2F;template&gt;&lt;script setup&gt; &#x2F;&#x2F; 引入子组件 import child from &#39;.&#x2F;child.vue&#39;&lt;&#x2F;script&gt; 7、emit 子传父子组件. 123456789101112131415161718192021222324252627&lt;template&gt; &lt;span&gt;&#123;&#123;props.name&#125;&#125;&lt;&#x2F;span&gt; &#x2F;&#x2F; 可省略【props.】 &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt; &lt;button @click&#x3D;&#39;changeName&#39;&gt;更名&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; &#x2F;&#x2F; import &#123; defineEmits, defineProps &#125; from &#39;vue&#39; &#x2F;&#x2F; defineEmits和defineProps在&lt;script setup&gt;中自动可用，无需导入 &#x2F;&#x2F; 需在.eslintrc.js文件中【globals】下配置【defineEmits: true】、【defineProps: true】 &#x2F;&#x2F; 声明props const props &#x3D; defineProps(&#123; name: &#123; type: String, default: &#39;&#39; &#125; &#125;) &#x2F;&#x2F; 声明事件 const emit &#x3D; defineEmits([&#39;updateName&#39;]) const changeName &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 执行 emit(&#39;updateName&#39;, &#39;Tom&#39;) &#125;&lt;&#x2F;script&gt; 父组件 123456789101112131415161718&lt;template&gt; &lt;child :name&#x3D;&#39;state.name&#39; @updateName&#x3D;&#39;updateName&#39;&#x2F;&gt; &lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; reactive &#125; from &#39;vue&#39; &#x2F;&#x2F; 引入子组件 import child from &#39;.&#x2F;child.vue&#39; const state &#x3D; reactive(&#123; name: &#39;YoLin&#39; &#125;) &#x2F;&#x2F; 接收子组件触发的方法 const updateName &#x3D; (name) &#x3D;&gt; &#123; state.name &#x3D; name &#125;&lt;&#x2F;script&gt; 8、v-model支持绑定多个v-model，v-model 是v-model:modelValue的简写 绑定其他字段，如v-model:name 子组件 123456789101112131415161718192021&lt;template&gt; &lt;span @click&#x3D;&quot;changeInfo&quot;&gt;我叫&#123;&#123; modelValue &#125;&#125;，今年&#123;&#123; age &#125;&#125;岁&lt;&#x2F;span&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; &#x2F;&#x2F; import &#123; defineEmits, defineProps &#125; from &#39;vue&#39; &#x2F;&#x2F; defineEmits和defineProps在&lt;script setup&gt;中自动可用，无需导入 &#x2F;&#x2F; 需在.eslintrc.js文件中【globals】下配置【defineEmits: true】、【defineProps: true】 defineProps(&#123; modelValue: String, age: Number &#125;) const emit &#x3D; defineEmits([&#39;update:modelValue&#39;, &#39;update:age&#39;]) const changeInfo &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 触发父组件值更新 emit(&#39;update:modelValue&#39;, &#39;Tom&#39;) emit(&#39;update:age&#39;, 30) &#125;&lt;&#x2F;script&gt; 父组件 12345678910111213141516171819&lt;template&gt; &#x2F;&#x2F; v-model:modelValue简写为v-model &#x2F;&#x2F; 可绑定多个v-model &lt;child v-model&#x3D;&quot;state.name&quot; v-model:age&#x3D;&quot;state.age&quot; &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; reactive &#125; from &#39;vue&#39; &#x2F;&#x2F; 引入子组件 import child from &#39;.&#x2F;child.vue&#39; const state &#x3D; reactive(&#123; name: &#39;Jerry&#39;, age: 20 &#125;)&lt;&#x2F;script&gt; 9、nextTick1234567&lt;script setup&gt; import &#123; nextTick &#125; from &#39;vue&#39; nextTick(() &#x3D;&gt; &#123; &#x2F;&#x2F; ... &#125;)&lt;&#x2F;script&gt; 10、子组件ref变量和defineExpose1、在标准的组件写法中，子组件的数据是默认隐式暴露给父组件的，但在script-setup模式下，所以的数据只是默认return给template使用，不会暴露到外部组件，所以父组件无法通过挂载ref变量来获取子组件的数据 2、如果想要调用子组件的数据，需要先在子组件显示的暴露出来，才能够正确的拿到，这个操作，就是由defineExpose来完成 子组件 123456789101112131415161718192021222324&lt;template&gt; &lt;span&gt;&#123;&#123;state.name&#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; reactive, toRefs &#125; from &#39;vue&#39; &#x2F;&#x2F; defineExpose无需引入 &#x2F;&#x2F; import &#123; defineExpose, reactive, toRefs &#125; from &#39;vue&#39; &#x2F;&#x2F; 声明state const state &#x3D; reactive(&#123; name: &#39;YoLin&#39; &#125;) &#x2F;&#x2F; 将方法、变量暴露给父组件使用，父组件才可通过ref API拿到子组件暴露的数据 defineExpose(&#123; &#x2F;&#x2F; 解构state ...toRefs(state), &#x2F;&#x2F; 声明方法 changeName () &#123; state.name &#x3D; &#39;Deng&#39; &#125; &#125;)&lt;&#x2F;script&gt; 父组件 1234567891011121314151617181920&lt;template&gt; &lt;child ref&#x3D;&#39;childRef&#39;&#x2F;&gt; &lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; ref, nextTick &#125; from &#39;vue&#39; &#x2F;&#x2F; 引入子组件 import child from &#39;.&#x2F;child.vue&#39; &#x2F;&#x2F; 子组件ref（TypeScript语法） const childRef &#x3D; ref&lt;InstanceType&lt;typeof child&gt;&gt;() &#x2F;&#x2F; nextTick nextTick(() &#x3D;&gt; &#123; &#x2F;&#x2F; 获取子组件name console.log(childRef.value.name) &#x2F;&#x2F; 执行子组件方法 childRef.value.changeName() &#125;)&lt;&#x2F;script&gt; 11、插槽 子组件 123456789101112131415161718192021222324&lt;template&gt; &#x2F;&#x2F; 匿名插槽 &lt;slot&#x2F;&gt; &#x2F;&#x2F; 具名插槽 &lt;slot name&#x3D;&#39;title&#39;&#x2F;&gt; &#x2F;&#x2F; 作用域插槽 &lt;slot name&#x3D;&quot;footer&quot; :scope&#x3D;&quot;state&quot; &#x2F;&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; useSlots, reactive &#125; from &#39;vue&#39; const state &#x3D; reactive(&#123; name: &#39;张三&#39;, age: &#39;25岁&#39; &#125;) const slots &#x3D; useSlots() &#x2F;&#x2F; 匿名插槽使用情况 const defaultSlot &#x3D; reactive(slots.default &amp;&amp; slots.default().length) console.log(defaultSlot) &#x2F;&#x2F; 1 &#x2F;&#x2F; 具名插槽使用情况 const titleSlot &#x3D; reactive(slots.title &amp;&amp; slots.title().length) console.log(titleSlot) &#x2F;&#x2F; 3&lt;&#x2F;script&gt; 父组件 123456789101112131415161718192021&lt;template&gt; &lt;child&gt; &#x2F;&#x2F; 匿名插槽 &lt;span&gt;我是默认插槽&lt;&#x2F;span&gt; &#x2F;&#x2F; 具名插槽 &lt;template #title&gt; &lt;h1&gt;我是具名插槽&lt;&#x2F;h1&gt; &lt;h1&gt;我是具名插槽&lt;&#x2F;h1&gt; &lt;h1&gt;我是具名插槽&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &#x2F;&#x2F; 作用域插槽 &lt;template #footer&#x3D;&quot;&#123; scope &#125;&quot;&gt; &lt;footer&gt;作用域插槽——姓名：&#123;&#123; scope.name &#125;&#125;，年龄&#123;&#123; scope.age &#125;&#125;&lt;&#x2F;footer&gt; &lt;&#x2F;template&gt; &lt;&#x2F;child&gt; &lt;&#x2F;template&gt;&lt;script setup&gt; &#x2F;&#x2F; 引入子组件 import child from &#39;.&#x2F;child.vue&#39;&lt;&#x2F;script&gt; 12、路由useRoute和useRouter1234567891011&lt;script setup&gt; import &#123; useRoute, useRouter &#125; from &#39;vue-router&#39; &#x2F;&#x2F; 必须先声明 const route &#x3D; useRoute() const router &#x3D; useRouter() &#x2F;&#x2F; 路由信息 console.log(route.query) &#x2F;&#x2F; 路由跳转 router.push(&#39;&#x2F;index&#39;)&lt;&#x2F;script&gt; 13、路由导航守卫1234567891011&lt;script setup&gt; import &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; from &#39;vue-router&#39; &#x2F;&#x2F;添加一个导航守卫，当组件将要离开的时候触发 onBeforeRouteLeave((to, from, next) &#x3D;&gt; &#123; next() &#125;) &#x2F;&#x2F; 添加一个导航守卫，当组件将要更新时触发 onBeforeRouteUpdate((to, from, next) &#x3D;&gt;&#123; next() &#125;)&lt;&#x2F;script&gt; 14、store vuex *Vue3 中的Vuex不再提供辅助函数写法 12345678910111213141516171819&lt;script setup&gt; import &#123; useStore &#125; from &#39;vuex&#39; import &#123; key &#125; from &#39;..&#x2F;store&#x2F;index&#39; &#x2F;&#x2F; 必须先声明调用 const store &#x3D; useStore(key) &#x2F;&#x2F; 获取Vuex的state store.state.xxx &#x2F;&#x2F; 触发mutations的方法 store.commit(&#39;fnName&#39;) &#x2F;&#x2F; 触发actions的方法 store.dispatch(&#39;fnName&#39;) &#x2F;&#x2F; 获取Getters store.getters.xxx&lt;&#x2F;script&gt; 15、pinia Pinia 就是 Vuex 5 ，Pinia 的优点： 1、同时支持 Composition Api 和 Options api 的语法； 2、去掉 mutations ，只有 state 、getters 和 actions ； 3、不支持嵌套的模块，通过组合 store 来代替； *4、更完善的typescript支持 5、清晰、显式的代码拆分 安装： 12345# 使用 npmnpm install pinia# 使用 yarnyarn add pinia main.js引入 1234567import App from './App.vue'import &#123; createApp &#125; from 'vue'import &#123; createPinia &#125; from 'pinia'const app = createApp(App)app.use(createPinia())app.mount('#app') 配置store.js 1234567891011121314151617181920212223242526272829303132333435363738import &#123; defineStore &#125; from 'pinia'// defineStore 调用后返回一个函数，调用该函数获得 Store 实体export const useStore = defineStore(&#123; // id: 必须，在所有 Store 中唯一 id: 'globalState', // state: 返回对象的函数 state: () =&gt; (&#123; count: 1, data: &#123; name: 'Jerry', sex: '男' &#125; &#125;), // getter 第一个参数是 state，是当前的状态，也可以使用 this 获取状态 // getter 中也可以访问其他的 getter，或者是其他的 Store getters: &#123; // 通过 state 获取状态 doubleCount: (state) =&gt; state.count * 2, // 通过 this 获取状态（注意this指向） tripleCount() &#123; return this.count * 3 &#125; &#125;, actions: &#123; updateData (newData, count) &#123; // 使用 this 直接修改 this.data = &#123; ...newData &#125; this.count = count // 使用 $patch 修改多个值 this.$patch(&#123; data: &#123; ...newData &#125;, count &#125;) &#125; &#125;&#125;) 使用store 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &#x2F;&#x2F; 获取 store 的 state &lt;p&gt;姓名：&#123;&#123;store.data.name&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;性别：&#123;&#123;store.data.sex&#125;&#125;&lt;&#x2F;p&gt; &#x2F;&#x2F; 调用 mutations 方法 &#x2F; 修改 store &lt;button @click&#x3D;&#39;update&#39;&gt;修改用户信息&lt;&#x2F;button&gt; &#x2F;&#x2F; 获取 getter &lt;p&gt;获取getter：&#123;&#123;store.doubleCount&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; useStore &#125; from &#39;@store&#x2F;store.js&#39; const store &#x3D; useStore() function update () &#123; &#x2F;&#x2F; 通过 actions 定义的方法修改 state store.updateData(&#123; name: &#39;Tom&#39;, sex: &#39;女&#39; &#125;) &#x2F;&#x2F; 通过 store 直接修改 store.data &#x3D; &#123; name: &#39;Tom&#39;, sex: &#39;女&#39; &#125; &#x2F;&#x2F; 同时改变多个状态 store.$patch((state) &#x3D;&gt; &#123; state.data &#x3D; &#123; name: &#39;Tom&#39;, sex: &#39;女&#39; &#125; state.count &#x3D; 2 &#125;) &#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt; 其他方法 1、$state可以替换store的整个state 2、重制状态， $reset() 方法将状态重置为初始值 123const store = useStore()store.$state = &#123;&#125;store.$reset() 16、声明周期通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。 Option API: beforeCreate、created、beforeMount、mounted、beforeUnmount(原vue2的beforeDestroy)、unmounted(原vue2的destroyed)、errorCapturedactivated、deactivated(在keep-alive标签下才有) renderTracked(新增，状态跟踪, 每次渲染后重新收集响应式依赖)、renderTriggered(新增、状态触发, 每次触发页面重新渲染时自动执行), 新增的这两个用于调试使用 Composition API: setup中不需要beforeCreate 和 created, 其余只需要在Option API名称前面加上“on” 17、原型绑定与组件内使用main.js 123456789import &#123; createApp &#125; from 'vue'import App from './App.vue'const app = createApp(App)// 获取原型const prototype = app.config.globalProperties// 绑定参数prototype.name = 'Jerry' 组件内使用 123456789&lt;script setup&gt; import &#123; getCurrentInstance &#125; from &#39;vue&#39; &#x2F;&#x2F; 获取原型 const &#123; proxy &#125; &#x3D; getCurrentInstance() &#x2F;&#x2F; 输出 console.log(proxy.name)&lt;&#x2F;script&gt; 18、V-bind() css 变量注入12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;span&gt;Jerry&lt;&#x2F;span&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; ref, reactive &#125; from &#39;vue&#39; &#x2F;&#x2F; prop接收样式 const props &#x3D; defineProps(&#123; border: &#123; type: String, default: &#39;1px solid yellow&#39; &#125; &#125;) &#x2F;&#x2F; 常量声明样式 const background &#x3D; &#39;red&#39; &#x2F;&#x2F; 响应式数据声明样式 const color &#x3D; ref(&#39;blue&#39;) const style &#x3D; reactive(&#123; opacity: &#39;0.8&#39; &#125;)&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt; span &#123; &#x2F;&#x2F; 使用常量声明的样式 background: v-bind(background); &#x2F;&#x2F; 使用响应式数据声明的样式 color: v-bind(color); opacity: v-bind(&#39;style.opacity&#39;); &#x2F;&#x2F; 使用prop接收的样式 border: v-bind(&#39;props.border&#39;); &#125;&lt;&#x2F;style&gt; 19、Provide 和inject 父组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;child&#x2F;&gt;&lt;&#x2F;template&gt;&lt;script setup&gt; import &#123; provide &#125; from &#39;vue&#39; import &#123; ref, watch &#125; from &#39;vue&#39; &#x2F;&#x2F; 引入子组件 import child from &#39;.&#x2F;child.vue&#39; let name &#x3D; ref(&#39;Jerry&#39;) &#x2F;&#x2F; 声明provide provide(&#39;provideState&#39;, &#123; name, changeName: () &#x3D;&gt; &#123; name.value &#x3D; &#39;Tom&#39; &#125; &#125;) &#x2F;&#x2F; 监听name改变 watch(name, () &#x3D;&gt; &#123; console.log(&#96;name变成了$&#123;name&#125;&#96;) setTimeout(() &#x3D;&gt; &#123; console.log(name.value) &#x2F;&#x2F; Tom &#125;, 1000) &#125;)&lt;&#x2F;script&gt; 子组件 12345678&lt;script setup&gt; import &#123; inject &#125; from &#39;vue&#39; &#x2F;&#x2F; 注入 const provideState &#x3D; inject(&#39;provideState&#39;) &#x2F;&#x2F; 子组件触发name改变 provideState.changeName()&lt;&#x2F;script&gt; 20、对await 的支持不必再配合 async 就可以直接使用 await 了，这种情况下，组件的 setup 会自动变成 async setup 123&lt;script setup&gt; const post &#x3D; await fetch(&#39;&#x2F;api&#39;).then(() &#x3D;&gt; &#123;&#125;)&lt;&#x2F;script&gt; 21、定义组件的name用单独的&lt;script&gt;块来定义 12345&lt;script&gt; export default &#123; name: &#39;ComponentName&#39;, &#125;&lt;&#x2F;script&gt;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"}]},{"title":"前端性能优化","slug":"前端性能优化","date":"2022-05-06T11:21:51.000Z","updated":"2022-05-17T09:23:57.299Z","comments":true,"path":"2022/05/06/前端性能优化/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/05/06/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"加载优化 减少HTTP请求：尽量减少页面的请求数（首次加载同时请求数不能超过4个） 合并CSS和JS 使用CSS精灵图 缓存资源 使用缓存可减少向服务器的请求数，节省加载时间，所有静态资源都要在服务器端设置缓存 缓存一切可缓存的资源 使用长缓存 使用外联的样式和脚本 压缩代码 减少资源大小可加快网页显示速度，对代码进行压缩，并在服务器端设置GZip 压缩代码(多余的缩进、空格和换行符) 启用Gzip 无阻塞：头部内联的样式和脚本会阻塞页面的渲染，样式放在头部并使用link方式引入，脚本放在尾部并使用异步方式加载 首屏加载 针对首屏的快速显示做优化 按需加载 将不影响首屏的资源和当前屏幕不用的资源放到用户需要时才加载，可大大提升显示速度和降低总体流量(按需加载会导致大量重绘，影响渲染性能) 懒加载 滚屏加载 Media Query加载 预加载 大型资源页面可使用Loading，资源加载完成后再显示页面，但加载时间过长，会造成用户流失 压缩图像 使用TinyJpg和TinyPng压缩图像 使用CSS3、SVG、IconFont代替图像 使用img的srcset按需加载图像 减少Cookie Cookie会影响加载速度，静态资源域名不使用Cookie 避免重定向 异步加载第三方资源 执行优化 CSS写在头部，JS写在尾部并异步 避免img、iframe等的src为空：空src会重新加载当前页面，影响速度和效率 尽量避免重置图像大小：多次重置图像大小会引发图像的多次重绘，影响性能 图像尽量避免使用DataURL：DataURL图像没有使用图像的压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长 渲染优化 设置viewport：HTML的viewport可加速页面的渲染 减少DOM节点 优化动画 尽量使用CSS3动画 合理使用requestAnimationFrame动画代替setTimeout 适当使用Canvas动画：5个元素以内使用CSS动画，5个元素以上使用Canvas动画，iOS8+可使用WebGL动画 优化高频事件：scroll、touchmove等事件可导致多次渲染 （1）函数节流 （2）函数防抖 （3）使用requestAnimationFrame监听帧变化：使得在正确的时间进行渲染 （4）增加响应变化的时间间隔：减少重绘次数 GPU加速 使用某些HTML5标签和CSS3属性会触发GPU渲染，请合理使用(过渡使用会引发手机耗电量增加) HTML标签：video、canvas、webgl CSS属性：opacity、transform、transition 样式优化 避免在HTML中书写style 避免CSS表达式 移除CSS空规则 正确使用display 不滥用float 不滥用Web字体 不声明过多的font-size： 过多的font-size影响CSS树的效率 值为0时不需要任何单位 标准化各种浏览器前缀 无前缀属性应放在最后 CSS动画属性只用-webkit-、无前缀两种 其它前缀为-webkit-、-moz-、-ms-、无前缀四种：Opera改用blink内核，-o-已淘汰 避免让选择符看起来像正则表达式：高级选择符执行耗时长且不易读懂，避免使用 脚本优化 减少重绘和回流 避免不必要的DOM操作 避免使用document.write 减少drawImage 尽量改变class而不是style，使用classList代替className 缓存DOM选择与计算 缓存.length的值 尽量使用事件代理 尽量使用id选择器 touch事件优化：使用tap(touchstart和touchend)代替click(注意touch响应过快，易引发误操作)","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"页面加载优化","slug":"页面加载优化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/"}]},{"title":"HTTP相关","slug":"HTTP相关","date":"2022-04-08T13:20:13.000Z","updated":"2022-05-17T09:21:15.764Z","comments":true,"path":"2022/04/08/HTTP相关/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/04/08/HTTP%E7%9B%B8%E5%85%B3/","excerpt":"","text":"HTTP 与HTTPS的区别 HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全 HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443 HTTPS 由于需要加密以及多次握手，性能方面不如 HTTP HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高 UDP和TCP的区别UDP（用户数据包协议）的特点： UDP不提供复杂的控制机制，利用ip提供面向无连接的通信服务 传输途中出现丢包，UDP也不负责重发 当包到达的顺序出现混乱时，UDP也没有纠正的功能 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为 TCP（传输控制协议）的特点： TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现） TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方 TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用 TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信 如何理解TCP/IP协议TCP/IP，传输控制协议/网际协议，是指能够在多个不同网络实现信息传输的协议簇 TCP 一种面向连接、可靠、基于字节流的传输层通信协议 IP 用于封包交换数据网络的协议 TCP/IP协议不仅仅指的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇 TCP/IP协议族按层次分别了五层体系或者四层体系 五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层 五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层 DNS协议 是什么？说说DNS 完整的查询过程?DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器 过程： 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表 若没有命中，则继续搜索操作系统的 DNS 缓存 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询。 1、本地服务器向根域名服务器发送请求，获取顶级域名的地址给本地服务器 2、本地服务器根据顶级域名地址发送请求，获取权限域名的地址 3、根据权限域名地址发送请求，最终得到该域名对应的ip 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起 如何理解CDN，说说实现原理？CDN 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度 CDN 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速 通过CDN的负载均衡系统，智能调度边缘节点提供服务，相当于CDN服务的大脑，而缓存系统相当于CDN的心脏，缓存命中直接返回给用户，否则回源 HTTP1.0/1.1/2.0的区别HTTP1.0: 浏览器和服务器只是短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接 HTTP1.1 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用 在同一个TCP连接里面，客户端可以同时发送多个请求 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着 新增了一些请求方法 新增了一些请求头和响应头 HTTP2.0 采用二进制格式而非文本格式 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行 使用报头压缩，降低开销 服务器推送 HTTP常见的状态码有哪些，适用的场景？分类： 1 表示消息 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级 2 表示成功 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回 201（已创建）：请求成功并且服务器创建了新的资源 202（已创建）：服务器已经接收请求，但尚未处理 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源 204（无内容）：服务器成功处理请求，但没有返回任何内容 205（重置内容）：服务器成功处理请求，但没有返回任何内容 206（部分内容）：服务器成功处理了部分请求 3 表示重定向 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 4 表示请求错误 400（错误请求）： 服务器不理解请求的语法 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403（禁止）： 服务器拒绝请求 404（未找到）： 服务器找不到请求的网页 405（方法禁用）： 禁用请求中指定的方法 406（不接受）： 无法使用请求的内容特性响应请求的网页 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理 408（请求超时）： 服务器等候请求时发生超时 5 表示服务器错误 500（服务器内部错误）：服务器遇到错误，无法完成请求 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护） 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"HTTP","slug":"HTTP","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/HTTP/"}]},{"title":"vue相关问题","slug":"vue相关问题","date":"2022-03-18T09:13:34.000Z","updated":"2022-05-17T09:18:54.612Z","comments":true,"path":"2022/03/18/vue相关问题/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/03/18/vue%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"简述MVVM视图模型双向绑定，是Model-View-ViewModel的缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。以前是操作DOM结构更新视图，现在是数据驱动视图。 MVVM的优点 1、低耦合，视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变； 2、可重用性，你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑 3、独立开发 4、可测试 Vue2.x双向绑定数据绑定采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调 vue的双向绑定是指，数据变化更新视图变化，视图变化更新数据变化。view变化更新Data可以通过事件监听的方式来实现，所以vue的数据双向绑定的工作主要是如何根据data变化更新view主要通过以下4个步骤来实现数据双向绑定： 1、实现一个监听器Observer：对数据对象进行遍历，包括子属性对象的属性，利用Object.defineProperty()对这个属性都加上setter 和getter。当给对象的某个属性赋值的时候就会触发setter，监听到数据变化（在getter收集依赖，在setter通知依赖更新） 2、实现一个解析器Complie: 解析Vue模版指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 3、实现一个订阅者Watcher： Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 谈谈对vue2生命周期的理解？每个vue实例在创建的时候会经过一系列的初始化过程，vue的生命周期钩子，就是在达到某个阶段或条件的时候出发的函数，目的是为了完成一些动作或事件。 create阶段：vue实例被创建beforeCreate: 创建前，此时data和methods中的数据都还没有初始化created： 创建完毕，data中有值，未挂载 mount阶段： vue实例被挂载到真实DOM节点beforeMount：可以发起服务端请求，去数据mounted: 此时可以操作DOM update阶段：当vue实例里面的data数据变化时，触发组件的重新渲染beforeUpdate :更新前updated：更新后 destroy阶段：vue实例被销毁beforeDestroy：实例被销毁前，此时可以手动销毁一些方法destroyed:销毁后 组件生命周期生命周期（父子组件） 父组件beforeCreate –&gt; 父组件created –&gt; 父组件beforeMount –&gt; 子组件beforeCreate –&gt; 子组件created –&gt; 子组件beforeMount –&gt; 子组件 mounted –&gt; 父组件mounted –&gt;父组件beforeUpdate –&gt;子组件beforeDestroy–&gt; 子组件destroyed –&gt; 父组件updated computed与watch能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。 watch属性监听: 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用 computed计算属性： 属性的结果会被缓存，当computed中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 computed中的函数必须用return返回最终的结果 computed更高效，优先使用。data 不改变，computed 不更新。使用场景 computed：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 watch：当一条数据影响多条数据的时候使用，例：搜索数据 组件中的data为什么是一个函数？一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 2.如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。 为什么v-for和v-if不建议用在一起当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费，建议使用computed，先对数据进行过滤。3.x 版本中 v-if 总是优先于 v-for 生效 React/Vue 项目中 key 的作用 key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM; 为了在数据变化时强制更新组件，以避免“就地复用”带来的副作用当 Vue.js 用 v-for 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误 vue组件的通信方式 props/$emit 父子组件之间通信 provide/inject 父-&gt;子孙组件之间 ref/refs，获取子组件实例，并调用其方法和访问数据 eventBus ,又称为事件总线,在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。 缺点：难以维护。 1234// event-bus.js import Vue from 'vue'export const EventBus = new Vue() 导出EventBus,通过$emit发送事件，通过$on接收事件，通过$off移除事件监听者 Vuex: Vue.js 应用程序开发的状态管理模式(state、getters、mutations、actions、mudules) $attrs与 $listeners ,父-&gt;子，如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false， $listeners绑定父组件的所有事件总结常见使用场景可以分为三类： 父子通信： 父向子传递数据是通过 props，子向父是通过 events（ $emit）；通过父链 / 子链也可以通信（ $parent / $children）；ref 也可以访问组件实例; provide/inject、$attrs/$listeners 兄弟通讯： eventBus； VueX 跨级通讯：eventBus、VueX、provide/inject、$attrs/$listeners nextTick的实现 nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用； 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。nextTick的实现原理是什么？在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。 匿名插槽、具名插槽、作用域插槽子组件：(匿名插槽)(具名插槽)(作用域插槽) 父之间:旧版本： 新版本： keep-alive的实现作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染Vue.js内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。 mixin（混入）mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin多个组件有相同的逻辑，抽离出来mixin并不是完美的解决方案，会有一些问题vue3提出的Composition API旨在解决这些问题劣势：1.变量来源不明确，不利于阅读2.多mixin可能会造成命名冲突3.mixin和组件可能出现多对多的关系，使得项目复杂度变高 vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进1、在vue2.x中通过Object.defineProperty为每个对象添加getter、setter方法来监听数据的变化，vue3.x通过Proxy代理目标对象，且一开始只代理最外层，嵌套对象惰性监听（lazy by default），性能更好。 2、支持数组索引修改，对象属性的增加、删除 vue 数组中 key 的作用是什么diff算法需求对比虚拟dom的修改，然后异步的渲染到页面中，当出现大量的相同标签的时候，vnode会首先判断key和标签名是否一致，如果一致再判断子节点一致，使用key可以帮助diff算法提升判断的速度，在页面重新渲染时更快、消耗更少。 vue 中 v-if 和 v-show 的区别是什么v-show 总是会进行编译和渲染的工作 - 它只是简单的在元素上添加了 display: none; 的样式。v-show 具有较高的初始化性能成本上的消耗，但是使得转换状态变得很容易。 相比之下，v-if 才是真正「有条件」的：它的加载是惰性的，因此，若它的初始条件是 false，它就不会做任何事情。这对于初始加载时间来说是有益的，当条件为 true 时，v-if 才会编译并渲染其内容。切换 v-if 下的块儿内容实际上时销毁了其内部的所有元素，比如说处于 v-if 下的组件实际上在切换状态时会被销毁并重新生成，因此，切换一个较大 v-if 块儿时会比 v-show 消耗的性能多。 vue中computed的原理是什么computed的实现是基于响应式原理中Watcher对象的实现，在初始化data和computed的时候会涉及到以下几个对象：1、Observer对象（现在数据监听）、2、Dep对象（收集依赖，触发watcher数据更新）3、Watcher对象（执行更新函数，更新依赖变化）。 computed有两种定义方式，一种是方法、一种是get和set属性，其内部监听的对象必须是已经定义响应式的属性。 vue在创建computed属性的时候，会循环所有的计算属性，每个计算属性都会创建一个watch，通过defineProperty定义监听，在get中收集依赖，在set中重新执行计算方法，computed是懒执行，在第一次初始化后，不会执行计算，下一次变更时在set中执行计算。 vue-loader 的实现原理是什么vue-loader会把sfc（单文件组件规范）中的内容拆分为template、script、style三个虚拟模块，然后分别匹配webpack配置中的对应rules，比如script模块会匹配所有跟处理javascript和typescript相关的loader。 template中的内容会通过vue compiler转换为render函数合并到script虚拟模块中。 scoped style会经过vue-loader/style-post-loader的处理，成为只匹配特定元素的私有样式。 vue实现一个messageAPI可以先写好一个 render 函数，作用是把某一 HTML 片段挂载到 #root 下 / 从 #root 删除该片段。然后写一个 Vue 插件，就是一个暴露了包含 install 方法的模块，install 方法中将 设置 Vue.prototype.$message = message 对象。最后使用 Vue.use 全局注册这个插件即可。 如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错 在 vue 中数组是否可以以在数组中的次序为 key不可，key 应为唯一标识，在数组变更时插入或删除后，index 无法确保始终指向对应的序列 vue中的router实现原理前端路由实现的本质是监听url的变化，实现方式有2种，Hash模式和History模式，无需刷新页面就能重新加载相应的页面。通过location.hash 跳转路由，通过hashchange监听路由变化。History url 通过history.pushState 和 history.replaceState改变url，通过popstate 事件监听路由变化。 两种模式的区别： hash 只能改变#后的值，而history模式可以随意设置同源url hash 只能添加字符串类的数据，而history可以通过API添加多种类型的数据 hash 的历史记录只显示之前的www.a.com而不会显示 hash 值，而 history 的每条记录都会进入到历史记录； hash 无需后端配置且兼容性好，而 history 需要配置index.html用于匹配不到资源的情况。 vue实例挂载的过程中发生了什么？1、new Vue 的时候调用了_init方法 定义$set、$get、$delete、$watch 等方法 定义$on $off $emit 等事件 定义_update $forceUpdate $destory 生命周期 2、调用$mount 进行页面的挂载，挂载的时候主要通过mountComponent方法 3、定义updateComponent更新函数 4、执行render函数生成虚拟dom 5、_update将虚拟dom生成真实dom结构，渲染到页面中 在created和mounted这两个生命周期中请求数据有什么区别呢？created后vue实力化完成，可以获取到属性和方法等，无法获取dom，而在mounted的时候dom已经挂载了，因此可以获取到dom，如果在mounted请求数据，页面可能会闪动一下。放在created中则不会。 SPA首屏加载速度慢的怎么解决？ 减少入口文件体积（路由懒加载） 静态资源本地缓存 后端返回资源： 1、采用HTTP缓存，强缓存：Cache-Control, 协商缓存：Last-Modified, Etag 2、Service Worker离线缓存 客户端合理运用localStorage UI框架按需加载 图片资源的压缩（压缩图片，使用icon，精灵图） 组件重复打包（在webpack的config文件中，修改CommonsChunkPlugin的配置） 开启GZip压缩 1、安装compression-webpack-plugin，在vue.congig.js中引入并修改webpack配置 1234567891011121314const CompressionPlugin = require('compression-webpack-plugin')configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... config.mode = 'production' return &#123; plugins: [new CompressionPlugin(&#123; test: /\\.js$|\\.html$|\\.css/, //匹配文件名 threshold: 10240, //对超过10k的数据进行压缩 deleteOriginalAssets: false //是否删除原文件 &#125;)] &#125; &#125; 2、服务端设置 使用SSR Nuxt.js 小结：减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化 为什么组件data属性是一个函数而不是一个对象？ 根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况 组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象 Vue中给对象添加新的属性，界面不刷新？因为新加的属性不是响应式的数据 如果为对象添加少量的新属性，可以直接采用Vue.set() 如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象 如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议) vue3是用过proxy实现数据响应式的，直接动态添加新属性仍可以实现数据响应式 Vue组件与插件的区别组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue 插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身 简单来说，插件就是指对Vue的功能的增强或补充 vue的mixin的理解，有什么应用场景 替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数 合并型策略是data, 通过set方法进行合并和重新赋值 队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行 叠加型有component、directives、filters，通过原型链进行层层的叠加 不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立 这时，可以通过Vue的mixin功能将相同或者相似的代码提出来 Vue.observable你有了解过吗？Vue.observable，让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象 在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 变更，它和被返回的对象是同一个对象 在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的 在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable就是一个很好的选择 自定义指令的应用场景自定义指令也像组件那样存在钩子函数： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中) update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用 unbind：只调用一次，指令与元素解绑时调用 所有的钩子函数的参数都有以下 el binding vnode oldVnode 应用场景 防抖 图片懒加载 一键copy功能 权限校验 vue 中diff算法的作用用于虚拟dom渲染成真实dom的新旧VNode节点比较 特点： 比较只会在同层级进行，不会跨层级比较 在diff比较的过程中，循环从两边向中间比较 vue项目中有封装过axios吗？主要封装哪方面？axios是基于Promise的Http网络请求库 封装：对超时时间、设置请求头、根据项目环境使用请求地址、错误处理等。 通过请求拦截器和响应拦截器实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const instance = axios.create(&#123; baseURL: `$&#123;host&#125;/lightning/api/backend`&#125;)const errorHandle = (status, message, url) =&gt; &#123; switch (status) &#123; case '0001': url !== '/activity/icid' &amp;&amp; store.dispatch('logout') break case '5301': break default: Message.error(message) &#125;&#125;instance.interceptors.request.use( config =&gt; &#123; config.headers.token = localStorage.getItem('lightning_auth_ssoToken') // sso token return config &#125;, error =&gt; &#123; return Promise.reject(error) &#125;)instance.interceptors.response.use( (response) =&gt; &#123; const code = response.data.code if (code === '0000') &#123; Message.success(response.data.message) &#125; else &#123; if (code === '0001') &#123; Message.error(response.data.message) &#125; errorHandle(code, response.data.message, response.config.url) &#125; return response &#125;, error =&gt; &#123; const &#123; response &#125; = error response ? errorHandle(response.data.code, response.data.message, response.config.url) : Message.warning('网络连接失败，请稍后重试！') return Promise.reject(error) &#125;)export const createAPI = (url, method, params, config = &#123;&#125;) =&gt; &#123; if (method === 'get') &#123; config.params = params &#125; else &#123; config.data = params &#125; return instance(&#123; url, method, ...config &#125;)&#125; vue的SSR（Nuxt）1、Vue SSR 是在SPA上进行改良的服务端渲染 2、通过Vue SSR渲染的页面，需要在客户端激活才能实现交互 3、Vue SRR将包含两部分：服务端渲染首屏，包含交互的SPA SSR主要解决两个问题： 1、SEO 2、首屏呈现渲染 vue3做了哪些优化？ 源码 1、源码管理（monorepo的方式维护） 2、TS 性能 1、体积优化（tree-shanking） 2、编译优化（优化diff算法） 3、数据劫持优化（Proxy） 语法API（Composition API） 1、优化逻辑组织 2、优化逻辑复用 vue3性能提升主要通过哪几个方面体现1、编译阶段 diff算法的优化 增加静态标记，在dff的过程中不会比较 静态提升 对不参与更新的元素，会做静态提升，只会被创建一次，在渲染的时直接复用，避免重复创建，优化运行时的内存占用 事件监听缓存 SSR优化 当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染 2、源码体积 移除了不常用的一些API，使用Tree-shanking,把没有用到的模块摇掉，打包的整体体积变小。 3、响应式系统 采用Proxy重写了响应式系统，因为Proxy可以对整个对象进行监听，所以不需要深度遍历。 为什么要用Proxy API代替defineProperty APIObject.defineProperty需要遍历属性进行监听，如果嵌套对象，需要深层监听，造成性能问题，不能监听对象属性的添加和删除，不能监听数组的变化（vue2通过重写数组方法实现监听）。 Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的，可以监听数据的变化，但它不兼容ie","categories":[{"name":"框架原理","slug":"框架原理","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"}]},{"title":"webpack相关","slug":"webpack相关","date":"2022-02-17T12:08:23.000Z","updated":"2022-05-17T09:10:47.395Z","comments":true,"path":"2022/02/17/webpack相关/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/02/17/webpack%E7%9B%B8%E5%85%B3/","excerpt":"","text":"webpack的理解，解决了什么问题？webpack 是一个用于现代JavaScript应用程序的静态模块打包工具 webpack可以解决一下几个问题： 需要通过模块化的方式来开发 使用一些高级特性来提高开发效率，比如通过ES6+、TS开发脚本逻辑，scss、less等CSS扩展语言来编写css 监听文件的变化来并且反映到浏览器上，提高开发的效率（热更新） 开发完毕后需要对代码进行压缩、合并以及其他相关优化 webpack的构建流程webpack的运行流程是个串行的过程，它的工作流程就是将各个插件串联起来 从启动到结束会依次执行一下三个步骤： 初始化流程：从配置文件或shell语句中读取或合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数 编辑构建流程：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理 初始化后会调用Compiler的run来真正启动webpack编译构建流程： complie 开始编译（构建一个compilation 对象，执行模块创建、依赖收集、分块、打包等主要任务） make 从入口点文件分析模块及其依赖的模块，创建这些模块对象 build-module 构建模块（调用配置的loaders，模块转换完后，使用acorn解析输出AST树） seal 封装构建结果 emit 把各个chunk输出到结果文件 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统 webpack 中常见的Loaderloader用于对模块的源码进行转换，在import或者加载模块时预处理文件。 像一些css、sass、png等文件，webpack则无能为力，这个时候就需要配置对应的loader进行文件内容的解析 配置loader的三种方式： 配置方式（推荐），在webpack.config.js中指定loader 在module.rules属性中配置，rules是一个数组，所以可以配置多个loader，每个配置是一个对象，test属性表示匹配规则，一般是正则表达式，use属性来调用对应的loader 内联方式：在每个import语句中显式指定loader cli方式：在shell命令中指定它们 特性： loader可以同步也可以异步 loader运行在node.js中，并且可以执行任何操作 除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块 插件(plugin)可以为 loader 带来更多特性 loader 能够产生额外的任意文件 常见的loader： css-loader 分析css模块之间的关系，合并成一个css。 12345678910111213141516171819npm install --save-dev css-loader // shrules: [ ..., &#123; test: /\\.css$/, use: &#123; loader: \"css-loader\", options: &#123; // 启用/禁用 url() 处理 url: true, // 启用/禁用 @import 处理 import: true, // 启用/禁用 Sourcemap sourceMap: false &#125; &#125; &#125;] 如果只通过css-loader加载文件，这时候页面代码设置的样式并没有生效。 原因在于，css-loader只是负责将.css文件进行一个解析，而并不会将解析后的css插入到页面中 如果我们希望再完成插入style的操作，那么我们还需要另外一个loader，就是style-loader style-loader 把css-loader生成的内容，用style标签挂载到页面的head中 123456789npm install --save-dev style-loader // shrules: [ ..., &#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125;] less-loader/sass-loader 开发中，我们也常常会使用less、sass、stylus预处理器编写css样式，使开发效率提高 raw-loader 在 webpack中通过 import方式导入文件内容，该loader并不是内置的，所以首先要安装 file-loader 把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串) 123456789101112131415161718192021npm install --save-dev file-loader // shrules: [ ..., &#123; test: /\\.(png|jpe?g|gif)$/, use: &#123; loader: \"file-loader\", options: &#123; // placeholder 占位符 [name] 源资源模块的名称 // [ext] 源资源模块的后缀 name: \"[name]_[hash].[ext]\", //打包后的存放位置 outputPath: \"./images\", // 打包后文件的 url publicPath: './images', &#125; &#125; &#125;] url-loader 可以处理理 file-loader 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 base64 格式的字符串，并打包到 js 中，对小体积的图片比较合适，大图片不合适。 12345678910111213141516171819202122npm install --save-dev url-loader // shrules: [ ..., &#123; test: /\\.(png|jpe?g|gif)$/, use: &#123; loader: \"url-loader\", options: &#123; // placeholder 占位符 [name] 源资源模块的名称 // [ext] 源资源模块的后缀 name: \"[name]_[hash].[ext]\", //打包后的存放位置 outputPath: \"./images\" // 打包后文件的 url publicPath: './images', // 小于 100 字节转成 base64 格式 limit: 100 &#125; &#125; &#125;] webpack 中常见的plugin, 解决了什么问题？plugin赋予其各种灵活的功能，运行在 webpack 的不同阶段（钩子 / 生命周期），贯穿了webpack整个编译周期，目的在于解决loader 无法实现的其他事 特性： 本质是一个具有apply方法的js对象，apply方法会被webpack compiler调用，并且在整个编译生命周期都可以访问到compiler对象 1234567891011const pluginName = 'ConsoleLogOnBuildWebpackPlugin';class ConsoleLogOnBuildWebpackPlugin &#123; apply(compiler) &#123; compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123; console.log('webpack 构建过程开始！'); &#125;); &#125;&#125;module.exports = ConsoleLogOnBuildWebpackPlugin; 编译生命周期钩子,如下： entry-option: 初始化option run compile: 真正开始编译，在创建compilation对象之前 Compilation：生成了compilation对象 make：从entry开始递归分析依赖，准备对每个模块进行build after-compile: 编译build过程结束 emit: 在将内存中 assets 内容写到磁盘文件夹之前 after-emit: 在将内存中 assets 内容写到磁盘文件夹之后 done: 完成所有的编译过程 failed：编译失败的时候 常见的plugin html-webpack-plugin 在打包结束后，⾃动生成⼀个 html ⽂文件，并把打包生成的js 模块引⼊到该 html 中 123456789101112// webpack.config.jsconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = &#123; ... plugins: [ new HtmlWebpackPlugin(&#123; title: \"My App\", filename: \"app.html\", template: \"./src/html/index.html\" &#125;) ]&#125;; clean-webpack-plugin（删除（清理）构建目录） mini-css-extract-plugin（提取css到一个独立的文件中） DefinePlugin 允许在编译时创建配置的全局对象，是一个webpack内置的插件，不需要安装 12345678910const &#123; DefinePlugun &#125; = require('webpack')module.exports = &#123; ... plugins:[ new DefinePlugin(&#123; BASE_URL:'\"./\"' &#125;) ]&#125; 这时候编译template模块的时候，就能通过下述形式获取全局对象 1&lt;link rel=\"icon\" href=\"&lt;%= BASE_URL%&gt;favicon.ico&gt;\" copy-webpack-plugin 复制文件或目录到执行区域，如vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中 123456789101112new CopyWebpackPlugin(&#123; parrerns:[ &#123; from:\"public\", globOptions:&#123; ignore:[ '**/index.html' ] &#125; &#125; ]&#125;) 复制的规则在patterns属性中设置： from：设置从哪一个源中开始复制 to：复制到的位置，可以省略，会默认复制到打包的目录下 globOptions：设置一些额外的选项，其中可以编写需要忽略的文件 说说Loader和plugin的区别？编写Loader和plugin的思路？概念： loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中 plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事 运行时机的区别： loader是运行在打包文件之前 plugin在整个编译周期都起作用 在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果。 对于loader实质是一个转化器，将A文件进行编译转化为B文件，操作的是文件。 编写loader： loader本质是一个函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader设为一个箭头函数， 函数接受一个参数，为 webpack 传递给 loader 的文件源内容，函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息，函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer 1234567891011121314151617181920// 导出一个函数，source为webpack传递给loader的文件源内容module.exports = function(source) &#123; const content = doSomeThing2JsString(source); // 如果 loader 配置了 options 对象，那么this.query将指向 options const options = this.query; // 可以用作解析其他模块路径的上下文 console.log('this.context'); /* * this.callback 参数： * error：Error | null，当 loader 出错时向外抛出一个 error * content：String | Buffer，经过 loader 编译后需要导出的内容 * sourceMap：为方便调试生成的编译后内容的 source map * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程 */ this.callback(null, content); // 异步 return content; // 同步&#125; 一般在编写loader的过程中，保持功能单一，避免做多种功能 编写plugin： 由于webpack基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务 webpack编译会创建两个核心对象： compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子 compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建 如果自己要实现plugin，也需要遵循一定的规范： 插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问compiler实例 传给每个插件的 compiler 和 compilation 对象都是同一个引用，因此不建议修改 异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住 123456789101112class MyPlugin &#123; // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象 apply (compiler) &#123; // 找到合适的事件钩子，实现自己的插件功能 compiler.hooks.emit.tap('MyPlugin', compilation =&gt; &#123; // compilation: 当前打包构建流程的上下文 console.log(compilation); // do something... &#125;) &#125;&#125; 在 emit 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容 webpack的热更新是如何做到的？总结： 通过webpack-dev-server创建两个服务器：提供静态资源服务（express）和Socket服务 express server 负责直接提供静态资源服务（打包后的资源直接被浏览器请求和解析） socket server是一个websocket的长链接，可双向进行通信 当socket server 监听到对应模块发生变化时，会生产两个文件，.json(manifest) 、.js文件（update chunk） 通过长链接，socket server可直接将这两个文件主动发送给客户端（浏览器） 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新 webpack proxy 的工作原理，为什么能解决跨域？Webpack proxy 是webpack提供的代理服务，可接收客户端请求进行转发到对应的服务器，解决前端开发模式下跨域的问题 通过服务器工具webpack-dev-server实现，只适用在开发阶段 关于配置方面，在webpack配置对象属性中通过devServer属性提供，如下： 1234567891011121314151617// ./webpack.config.jsconst path = require('path')module.exports = &#123; // ... devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000, proxy: &#123; '/api': &#123; target: 'https://api.github.com' &#125; &#125; // ... &#125;&#125; devServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配 属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为/api，值为对应的代理匹配规则，对应如下： pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false changeOrigin：它表示是否更新代理后请求的 headers 中host地址 工作原理： proxy的工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器 在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中 12345const express = require('express')const proxy = require('http-proxy-middleware')const app = express()app.use('api', proxy(&#123; target: 'http://www.example.org', changeOrigin: true &#125;))app.listen(3000) 跨域： 本地开发时候，通过webpack-dev-server启动了一个服务独立运行在localhost的一个端口上，而后端又是运行在另外一台服务器中，由于浏览器的同源策略的原因，因此本地访问会出现跨域的问题。 通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者 当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。 服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制 如何借助webpack来优化前端性能？手段： JS代码压缩(terser-webpack-plugin) terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小 123456789101112const TerserPlugin = require('terser-webpack-plugin')module.exports = &#123; ... optimization: &#123; minimize: true, minimizer: [ new TerserPlugin(&#123; parallel: true // 电脑cpu核数-1 &#125;) ] &#125;&#125; extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换 keep_classnames：保留类的名称 keep_fnames：保留函数的名称 css代码压缩(css-minimizer-webpack-plugin) css压缩通常是去除无用的空格等 HTML代码压缩（HtmlWebpackPlugin） 使用HtmlWebpackPlugin插件来生成HTML的模板时候，通过配置属性minify进行html优化 12345678910111213module.exports = &#123; ... plugin:[ new HtmlwebpackPlugin(&#123; ... minify:&#123; minifyCSS:false, // 是否压缩css collapseWhitespace:false, // 是否折叠空格 removeComments:true // 是否移除注释 &#125; &#125;) ]&#125; 文件大小压缩(compression-webpack-plugin) 对文件的大小进行压缩，减少http传输过程中宽带的损耗 123456new ComepressionPlugin(&#123; test:/\\.(css|js)$/, // 哪些文件需要压缩 threshold:500, // 设置文件多大开始压缩 minRatio:0.7, // 至少压缩的比例 algorithm:\"gzip\", // 采用的压缩算法&#125;) 图片压缩（file-loader、image-webpack-loader） 一般来说在打包之后，一些图片文件的大小是远远要比 js 或者 css 文件要来的大，所以图片压缩较为重要 12345678910111213141516171819202122232425262728293031323334353637383940414243module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', &#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; // 压缩 jpeg 的配置 mozjpeg: &#123; progressive: true, quality: 65 &#125;, // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭 optipng: &#123; enabled: false, &#125;, // 使用 imagemin-pngquant 压缩 png pngquant: &#123; quality: '65-90', speed: 4 &#125;, // 压缩 gif 的配置 gifsicle: &#123; interlaced: false, &#125;, // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式 webp: &#123; quality: 75 &#125; &#125; &#125; ] &#125;, ]&#125; tree sharking Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系） 两种方案： usedExports： 通过标记某些函数是否被使用，之后通过Terser来进行优化的 sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用 usedExports: 配置方法也很简单，只需要将usedExports设为true 123456module.exports = &#123; ... optimization:&#123; usedExports &#125;&#125; 使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知 Terser 在优化时，可以删除掉这段代码 sideEffects: sideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性 如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports 1234\"sideEffecis\":[ \"./src/util/format.js\", \"*.css\" // 所有的css文件] css tree shaking css进行tree shaking优化可以安装PurgeCss插件 1234567891011121314const PurgeCssPlugin = require('purgecss-webpack-plugin')module.exports = &#123; ... plugins:[ new PurgeCssPlugin(&#123; path:glob.sync(`$&#123;path.resolve('./src')&#125;/**/*`), &#123;nodir:true&#125;// src里面的所有文件 satelist:function()&#123; return &#123; standard:[\"html\"] &#125; &#125; &#125;) ]&#125; paths：表示要检测哪些目录下的内容需要被分析，配合使用glob 默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性 代码分离 将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件 默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度 代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能 这里通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可 默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all 12345optimization:&#123; splitChunks:&#123; chunks:\"all\" &#125; &#125; splitChunks主要属性有如下： Chunks，对同步代码还是异步代码进行处理 minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 maxSize： 将大于maxSize的包，拆分为不小于minSize的包 minChunks：被引入的次数，默认是1 内联chunk 可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的 关于webpack对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化 如何提高webpack的构建速度优化手段： 优化 loader 配置 在使用loader时，可以通过配置include、exclude、test属性来匹配文件，接触include、exclude规定哪些匹配应用loader 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 use: ['babel-loader?cacheDirectory'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, ] &#125;,&#125;; 合理使用 resolve.extensions 在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码 通过resolve.extensions是解析到文件时自动添加拓展名，默认情况如下 1234module.exports = &#123; ... extensions:[\".warm\",\".mjs\",\".js\",\".json\"]&#125; 当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找 当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度 优化 resolve.modules resolve.modules 用于配置 webpack 去哪些目录下寻找第三方模块。默认值为[&#39;node_modules&#39;]，所以默认会从node_modules中查找文件 当安装的第三方模块都放在项目根目录下的 ./node_modules目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下： 1234567module.exports = &#123; resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')] &#125;,&#125;; 优化 resolve.alias alias给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是./../../的形式 通过配置alias以减少查找过程 123456789module.exports = &#123; ... resolve:&#123; alias:&#123; \"@\":path.resolve(__dirname,'./src') &#125; &#125;&#125;# 使用 DLLPlugin 插件 DLL全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中 使用步骤分成两部分： 打包一个 DLL 库 引入 DLL 库 12345678910// 打包一个 DLL 库,webpack内置了一个DllPlugin可以帮助我们打包一个DLL的库文件module.exports = &#123; ... plugins:[ new webpack.DllPlugin(&#123; name:'dll_[name]', path:path.resolve(__dirname,\"./dll/[name].manifest.json\") &#125;) ]&#125; 12345678910111213// 使用 webpack 自带的 DllReferencePlugin 插件对 mainfest.json 映射文件进行分析，获取要使用的DLL库// 然后再通过AddAssetHtmlPlugin插件，将我们打包的DLL库引入到Html模块中module.exports = &#123; ... new webpack.DllReferencePlugin(&#123; context:path.resolve(__dirname,\"./dll/dll_react.js\"), mainfest:path.resolve(__dirname,\"./dll/react.mainfest.json\") &#125;), new AddAssetHtmlPlugin(&#123; outputPath:\"./auto\", filepath:path.resolve(__dirname,\"./dll/dll_react.js\") &#125;)&#125; 使用 cache-loader 在一些性能开销较大的 loader之前添加 cache-loader，以将结果缓存到磁盘里，显著提升二次构建速度 保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此loader 1234567891011module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.ext$/, use: ['cache-loader', ...loaders], include: path.resolve('src'), &#125;, ], &#125;,&#125;; terser 启动多线程 12345678910//使用多进程并行运行来提高构建速度module.exports = &#123; optimization: &#123; minimizer: [ new TerserPlugin(&#123; parallel: true, &#125;), ], &#125;,&#125;; 合理使用 sourceMap(打包生成 sourceMap 的时候，如果信息越详细，打包速度就会越慢) 总结： 可以看到，优化webpack构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手 与webpack类似的打包工具有哪些？区别？ Rollup Rollup 是一款 ES Modules 打包器，从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多 Rollup的优点： 代码更简洁、效率更高 默认支持 Tree-shaking 但缺点也十分明显，加载其他类型的资源文件或者支持导入 CommonJS 模块，又或是编译 ES 新特性，这些额外的需求 Rollup需要使用插件去完成 综合来看，rollup并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用CommonJs方式导出成员，并且rollup不支持HMR，使开发效率降低 但是在用于打包JavaScript 库时，rollup比 webpack 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略 Parcel Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序 执行命令后，Parcel不仅打包了应用，同时也启动了一个开发服务器，跟webpack Dev Server一样 跟webpack类似，也支持模块热替换，但用法更简单 同时，Parcel有个十分好用的功能：支持自动安装依赖，像webpack开发阶段突然使用安装某个第三方依赖，必然会终止dev server然后安装再启动。而Parcel则免了这繁琐的工作流程 同时，Parcel能够零配置加载其他类型的资源文件，无须像webpack那样配置对应的loader Snowpack Snowpack，是一种闪电般快速的前端构建工具，专为现代Web设计，较复杂的打包工具（如Webpack或Parcel）的替代方案，利用JavaScript的本机模块系统，避免不必要的工作并保持流畅的开发体验 开发阶段，每次保存单个文件时，Webpack和Parcel都需要重新构建和重新打包应用程序的整个bundle。而Snowpack为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，Snowpack会重新构建该单个文件 Vite vite ，是一种新型前端构建工具，能够显著提升前端开发体验 它主要由两部分组成： 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 模块热更新HMR 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源 其作用类似webpack+ webpack-dev-server，其特点如下： 快速的冷启动 即时的模块热更新 真正的按需编译 vite会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快 利用现代浏览器支持ES Module的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间 在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/webpack/"}]},{"title":"手写Promise及其静态方法","slug":"手写Promise及其静态方法","date":"2022-02-16T14:41:25.000Z","updated":"2022-05-17T09:46:59.706Z","comments":true,"path":"2022/02/16/手写Promise及其静态方法/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2022/02/16/%E6%89%8B%E5%86%99Promise%E5%8F%8A%E5%85%B6%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","excerpt":"","text":"Promise.resolve 1、Promise.resolve最终结果还是一个Promise，并且与Promise.resolve(该值)传入的值息息相关 2、传入的参数可以是一个Promise实例，那么该函数执行的结果是直接将实例返回 3、这里最主要需要理解跟随，可以理解成Promise最终状态就是这个thenable对象输出的值 源码实现 12345678910Promise.myResolve = function(value) &#123; // 是Promise实例，直接返回即可 if (value &amp;&amp; value typeof 'object' &amp;&amp; (value instanceof Promise)) &#123; return value &#125; // 否则其他情况一律再通过Promise包装一下 return new Promise(resolve =&gt; &#123; resolve(value) &#125;)&#125; Promise.rejectPromise.reject() 方法返回一个带有拒绝原因的Promise对象。 源码实现 12345Promise.myReject = function(value) &#123; return new Promise((_, reject) =&gt; &#123; reject(value) &#125;)&#125; Promise.all源码实现 1234567891011121314151617181920Promise.myAll = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = [] let count = 0 if (promises.length === 0) &#123; resolve(result) &#125; promises.forEach((item, index) =&gt;&#123; Promise.resolve(item).then(res =&gt; &#123; count += 1 result[index] = res if (count === promises.length)&#123; resolve(result) &#125; &#125;).catch(err =&gt;&#123; reject(err) &#125;) &#125;) &#125;)&#125; Promise.allSettled方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更,一旦发生状态变更，状态总是fulfilled，不会变成rejected 不管是全部成功还是有部分失败，最终都会进入Promise.allSettled的.then回调中 最后的返回值中，成功和失败的项都有status属性，成功时值是fulfilled，失败时是rejected 最后的返回值中，成功含有value属性，而失败则是reason属性 源码实现 123456789101112131415161718192021222324252627282930Promise.prototype.myAllSettled = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = [] let count = 0 if (promises.length === 0) &#123; resolve(result) &#125; promises.forEach((item, index) =&gt; &#123; Promise.resolve(item).then(res =&gt; &#123; count += 1 result[index] = &#123; status: 'fulfilled', value: res &#125; if (count === promises.length) &#123; resolve(result) &#125; &#125;).catch(err =&gt; &#123; count += 1 result[index] = &#123; status: 'rejected', reason: err &#125; if (count === promises.length) &#123; resolve(result) &#125; &#125;) &#125;) &#125;)&#125; Promise.racePromise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]) 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。源码实现 1234567Promise.myRace = (promises) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach(item =&gt; &#123; Promise.resolve(item).then(resolve).catch(reject) &#125;) &#125;)&#125; 手写Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192class Promise &#123; constructor(executor) &#123; this.state = 'pending' this.value = 'undefined' this.reason = 'undefined' this.onResolvedCallbacks = [] this.onRejectedCallbacks = [] let resolve = value =&gt; &#123; this.state = 'fulfilled' this.value = value this.onResolvedCallbacks.forEach(fn =&gt; fn()) &#125; let reject = reason =&gt; &#123; this.state = 'rejected' this.reason = reason this.onRejectedCallbacks.forEach(fn =&gt; fn()) &#125; try &#123; executor(resolve, reject) &#125; catch(error) &#123; reject(error) &#125; &#125; then(onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; &#123; throw err &#125; let promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.state === 'fulfilled') &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value) resolve(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125; if (this.state === 'rejected') &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125; if (this.state === 'pending') &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125;) this.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason) resolvePromise(promise2,x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125; &#125;) return promise2 &#125;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if (x === promise2) &#123; return new TypeError('chaining cycle detected for promise') &#125; let called if (x != null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; let then = x.then if (typeof then === 'function') &#123; then.call(x, y =&gt; &#123; if (called) return called = true resolvePromise(promise2, y, resolve, reject) &#125;, err =&gt; &#123; if (called) return called = true reject(err) &#125;) &#125; &#125; catch(error) &#123; if (called) return called = true reject(error) &#125; &#125; else &#123; resolve(x) &#125;&#125;// resolvePromise.resolve = function(value) &#123; if (value &amp;&amp; typeof value === 'object' &amp;&amp; (value instanceof Promise)) &#123; return value &#125; return new Promise(resolve =&gt; &#123; resolve(value) &#125;)&#125;// rejectPromise.reject = function(value) &#123; return new Promise((_, reject) =&gt; &#123; reject(value) &#125;)&#125;// allPromise.all = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = [] let count = 0 let len = promises.length if (len === 0) &#123; resolve([]) &#125; promises.forEach((item, index) =&gt; &#123; Promise.resolve(item).then(res =&gt; &#123; count += 1 result[index] = res if (count === len) &#123; resolve(result) &#125; &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125;// allSettledPromise.allSettled = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = [] let count = 0 let len = promises.length if (len === 0) &#123; resolve([]) &#125; promises.forEach((item, index) =&gt; &#123; Promise.resolve(item).then(res =&gt; &#123; count += 1 result[index] = &#123; status: 'fulfiled', value: res &#125; if (len === count) &#123; resolve(result) &#125; &#125;).catch(err =&gt; &#123; count += 1 result[index] = &#123; status: 'rejected', reason: err &#125; if (len === count) &#123; resolve(result) &#125; &#125;) &#125;) &#125;)&#125;// racePromise.race = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach(item =&gt; &#123; Promise.resolve(item).then(resolve).catch(reject) &#125;) &#125;)&#125;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/Promise/"}]},{"title":"commonJs与ESModule的区别","slug":"commonJs与ESModule的区别","date":"2021-11-02T07:48:01.000Z","updated":"2021-11-02T09:33:50.283Z","comments":true,"path":"2021/11/02/commonJs与ESModule的区别/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/11/02/commonJs%E4%B8%8EESModule%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"开篇学习之前引出几个问题： Commonjs 和 Es Module 有什么区别 ？ Commonjs 如何解决的循环引用问题 ？ Es Module 如何解决循环引用问题 ？ exports 和 module.exports 有何不同？ require 模块查找机制 ？ import() 的动态引入？ Es Module 如何改变模块下的私有变量 ？ 模块化开发很容易存在全局污染和依赖管理混乱问题，所以就需要模块化来解决这两个问题，今天介绍的是前端模块化的两个重要方案，commonjs 和 ESModule Commonjscommonjs的提出弥补了，前端模块化的空缺，nodejs借鉴了commonjs，实现了模块化管理。 目前commonjs广泛应用于以下几个场景： Node（commonjs在服务端的一个具体代表性实现） Browserify（ commonjs 在浏览器中的一种实现） wepack 打包工具对 CommonJS 的支持和转换 特点 在commonjs中每个js文件就是一个单独的模块，称为module。 模块中包含commonjs的核心变量：exports、module.exports、require exports 和 module.export可以用于导出模块中的内容 require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容 实现原理每个模块文件上存在 module，exports，require三个变量，然而这三个变量是没有被定义的，但是我们可以在 Commonjs 规范下每一个 js 模块上直接使用它们 module 记录当前模块信息。 require 引入模块的方法。 exports 当前模块导出的属性 在编译的过程中，实际 Commonjs 对 js 的代码块进行了首尾包装 123456789(function(exports,require,module,__filename,__dirname)&#123; const sayName = require('./hello.js') module.exports = function say()&#123; return &#123; name:sayName(), author:'YoLin' &#125; &#125;&#125;) 在 Commonjs 规范下模块中，会形成一个包装函数，我们写的代码将作为包装函数的执行上下文，使用的 require ，exports ，module 本质上是通过形参的方式传递到包装函数中的。 12345function wrapper (script) &#123; return '(function (exports, require, module, __filename, __dirname) &#123;' + script + '\\n&#125;)'&#125; 包装函数执行 123456789const modulefunction = wrapper(` const sayName = require('./hello.js') module.exports = function say()&#123; return &#123; name:sayName(), author:'YoLin' &#125; &#125;`) 1runInThisContext(modulefunction)(module.exports, require, module, __filename, __dirname) 在模块加载的时候，会通过 runInThisContext (可以理解成 eval ) 执行 modulefunction ，传入require ，exports ，module 等参数。最终我们写的 nodejs 文件就这么执行了。 require 文件加载流程1231、const fs = require('fs') // 核心模块2、const sayName = require('./sayName.js') // 文件模块3、const crypto = require('crypto-js') // 第三方模块 如上所示：require可以加载核心模块、文件模块、第三方自定义模块。当 require 方法执行的时候，接收的唯一参数作为一个标识符 ，Commonjs 下对不同的标识符，处理流程不同，但是目的相同，都是找到对应的模块。 require 加载标识符原则nodejs中对标识符的处理原则 对fs、http、path等标识符，会被作为核心模块 ./和../作为相对路径的文件模块，/作为绝对路径的文件模块 非路径形式也非核心模块的模块，将作为自定义模块 核心模块的处理：核心模块的优先级仅次于缓存加载，在 Node 源码编译中，已被编译成二进制代码，所以加载核心模块，加载过程中速度最快。 路径形式的文件模块处理：已 ./ ，../ 和 / 开始的标识符，会被当作文件模块处理。require() 方法会将路径转换成真实路径，并以真实路径作为索引，将编译后的结果缓存起来，第二次加载的时候会更快。 自定义模块处理：自定义模块，一般指的是非核心的模块，它可能是一个文件或者一个包，它的查找会遵循以下原则： 在当前目录下的 node_modules 目录查找。 如果没有，在父级目录的 node_modules 查找，如果没有在父级目录的父级目录的 node_modules 中查找 沿着路径向上递归，直到根目录下的 node_modules 目录。 在查找过程中，会找 package.json 下 main 属性指向的文件，如果没有 package.json ，在 node 环境下会以此查找 index.js ，index.json ，index.node。 require 模块引入与处理CommonJS 模块同步加载并执行模块文件，CommonJS 模块在执行阶段分析模块依赖，采用深度优先遍历（depth-first traversal），执行顺序是父 -&gt; 子 -&gt; 父； require 加载原理过程： require 会接收一个参数——文件标识符，然后分析定位文件，分析过程我们上述已经讲到了，加下来会从 Module 上查找有没有缓存，如果有缓存，那么直接返回缓存的内容。 如果没有缓存，会创建一个 module 对象，缓存到 Module 上，然后执行文件，加载完文件，将 loaded 属性设置为 true ，然后返回 module.exports 对象。借此完成模块加载流程。 模块导出就是 return 这个变量的其实跟 a = b 赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址。 exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对 exports 进行赋值会导致 exports 操作的不再是 module.exports 的引用。 require 避免重复加载加载之后的文件的 module 会被缓存到 Module 上，如果其他模块再次引入，则会直接读取缓存中的，无需再次执行模块 require 避免循环引用","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"typescript知识点","slug":"typescript知识点","date":"2021-11-02T07:45:11.000Z","updated":"2021-11-02T07:46:22.982Z","comments":true,"path":"2021/11/02/typescript知识点/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/11/02/typescript%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"TypeScript基础学习基础类型12345678910111213let isDone: boolean = truelet age: number = 20let binaryNumber: number = 0b1111 // 支持二进制或八进制let fistName: string = 'YoLinDeng'let u: undefined = undefinedlet n: null = nulllet num: number = undefined // 说明undefined和null类型是所以类型的子类型 null和undefined的区别null表示“没有对象”，即该处不该有值 1）作为函数的参数，表示该函数的参数不是对象 2）作为对象原型链的终点 undefined表示缺少值，就是此处应该有值，但是还没有定义 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 any类型和联合类型1234let notSure: any = 1// 有明确类型的时候避免使用any类型，没有代码提示以及校验let numberOrString: number | string = 123numberOrString = 'abc' Array 和 Tuple（元组）123456// 定义数组let arrOfNumbers: number[] = [1, 2, 3]let arr2: Array&lt;number&gt; = [1, 2, 3]// 定义元组,限定了一定数据类型的数组let user: [string, number] = ['YoLinDeng', 20] interface(接口) 对对象的形状进行描述 对类进行抽象 Duck Typing(鸭子类型) 12345678910interface Person &#123; readonly id: number; // 只读 name: string; age?: number; // 可选&#125;let yoLin: Person &#123; id: 1, name: 'YoLinDeng'&#125; 函数和类型推断1234567891011121314151617181920function add(x: number, y: number, z?: number): number &#123; if (typeof z === 'number') &#123; return x + y + z &#125; else &#123; return x + y &#125;&#125;let result = add(1, 2, 3)// 函数表达式const add = function(x: number, y: number, z?: number): number &#123; if (typeof z === 'number') &#123; return x + y + z &#125; else &#123; return x + y &#125;&#125;const add2 = (x: number, y: number, z?: number) =&gt; number = add当我们没有指定类型的时候，ts的complier会给我推断出一个类型 类Class类(Class)：定义了一切事物的抽象特点对象（Object）:类的实例面向对象（OOP）:三大特征：封装，继承，多态 1234567891011121314151617181920212223242526272829303132333435class Animal &#123; name: string; constructor(name: string) &#123; this.name = name &#125; run() &#123; return `$&#123;this.name&#125; is running` &#125;&#125;const snake = new Animal('liLy')console.log(snake.run())class Dog extends Animal &#123; bark() &#123; return `$&#123;this.name&#125; is barking` &#125;&#125;const xiaobao = new Dog('xiaobao')console.log(xiaobao.run())console.log(xiaobao.bark())class Cat extends Animal &#123; constructor(name) &#123; super(name) console.log(this.name) &#125; run() &#123; return `Meow,$&#123;super.run()&#125;` &#125;&#125;const maomao = new Cat('maomao')console.log(maomao.run()) 修饰符：public（公有的）、private（私有的）、protected(只有自己和子类可以访问)、readonly（只读）、static（静态，不需要实例化，可以在类上直接调用） 类和接口：使用interface和implements抽象和验证类的属性和方法，对类的一部分内容进行抽象。将特性提取成接口，使用implements来实现,像一种契约，定义和约束object的样子。 123456789101112131415161718192021222324interface Radio &#123; switchRadio(): void;&#125;interface Battery &#123; checkBatteryStatus(): void;&#125;interface RadioWithBattery extends Radio &#123; checkBatteryStatus(): void;&#125;class Car implements RadioWithBattery &#123; switchRadio() &#123; &#125; checkBatteryStatus() &#123;&#125;&#125;class CellPhone implements RadioWithBattery &#123; switchRadio() &#123; &#125; checkBatteryStatus() &#123; &#125;&#125; Enum枚举12345678910111213141516// 常量枚举, 提升性能，不会编译成js代码，只有常量值才可以进行常量枚举，计算值不行。const enum Direction1 &#123; left, right, top, bottom&#125;enum Direction2 &#123; left = 'LEFT', right = 'RIGHT', top = 'TOP', bottom = 'BOTTOM'&#125;console.log(Direction1.left)console.log(Direction1[0])console.log(Direction2.left === 'LEFT') 泛型在定义函数接口或类的时候，先不指定具体类型，在使用的时候才指定。 1234567891011function echo&lt;T&gt;(arg: T): T &#123; return arg&#125;const result1: number = echo(123)const result2: string = echo('string')function swap&lt;T, U&gt;(tuple: [T, U]): [T, U] &#123; return [tuple[0], tuple[1]]&#125;const result3 = swap(['string', 123]) 约束泛型使用extends继承接口进行约束 1234567891011interface IWithLength &#123; length: number&#125;function echoWithLength&lt;T extends IWithLength&gt;(arg: T): T &#123; console.log(arg.length) return arg&#125;const str = echoWithLength('str')const obj = echoWithLength(&#123; length: 10 &#125;)const arr = echoWithLength([1, 2, 3]) 泛型在类中的使用 123456789101112class Queue&lt;T&gt; &#123; private data = [] push(item: T) &#123; return this.data.push(item) &#125; pop(): T &#123; return this.data.shift() &#125;&#125;const queue = new Queue&lt;number&gt;()queue.push(1)console.log(queue.pop().toFixed()) 接口interface中使用泛型 123456interface KeyPair&lt;T, U&gt; &#123; key: T; value: U;&#125;let kp1: KeyPair&lt;number, string&gt; = &#123; key: 123, value: '123'&#125;let kp2: KeyPair&lt;string, number&gt; = &#123; key: 'str', value: 123&#125; 使用泛型定义数组 1let arr: Array&lt;number&gt; = [1,2,3] interface描述函数 1234567891011interface IPlus&lt;T&gt; &#123; (a: T, b: T): number&#125;function plus(a: number, b: number): number &#123; return a + b;&#125;function connect(a: string, b: string): string &#123; return a + b&#125;const a: IPlus&lt;number&gt; = plusconst b: IPlus&lt;string&gt; = connect 类型别名和类型断言type aliases 12345678910111213141516type PlusType = (x: number, y: number) =&gt; numberfunction sum(x: number, y: number): number &#123; return x + y&#125;const sum2: PlusType = sum// 联合类型中使用类型别名type NameResolver = () =&gt; stringtype NameOrResolver = string | NameResolverfunction getName(n: NameOrResolver): string &#123; if (typeof n === 'string') &#123; return n &#125; else &#123; return n() &#125;&#125; type assertion 断言 12345function getLength(input: number | string): number &#123; const str = input as String // or &lt;string&gt;input&#125; 声明文件创建.d.ts文件，例如jQuery.d.ts 1declare var Jquery: (selector: string) =&gt; any 再tsconfig.json中写配置 123&#123; \"include\": [\"**/*\"] //编译当前文件夹下的所有文件&#125;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/typeScript/"}]},{"title":"浏览器缓存原理","slug":"浏览器缓存原理","date":"2021-07-17T12:51:32.000Z","updated":"2022-05-17T09:46:02.090Z","comments":true,"path":"2021/07/17/浏览器缓存原理/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/07/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/","excerpt":"","text":"HTTP报文分为两种： HTTP请求(Request)报文请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体HTTP响应(Response)报文缓存过程分析 浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中强制缓存 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程主要有三种： 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果那么强制缓存的缓存规则是什么？ 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。 Expires Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义 Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存）private：所有内容只有客户端可以缓存，Cache-Control的默认取值no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。 那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。 内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。时效性：一旦该进程关闭，则该进程的内存则会清空硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。 协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304协商缓存失效，返回200和请求结果结果协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。 Last-Modified / If-Modified-Since Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间 If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件 Etag / If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成) If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200 注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。 总结 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"}]},{"title":"vue变化侦测","slug":"vue变化侦测","date":"2021-07-10T09:04:39.000Z","updated":"2022-05-17T09:06:28.801Z","comments":true,"path":"2021/07/10/vue变化侦测/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/07/10/vue%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/","excerpt":"","text":"变化侦测就是追踪状态，亦或者说是数据的变化，一旦发生了变化，就要去更新视图。 变化侦测可不是个新名词，它在目前的前端三大框架中均有涉及。在Angular中是通过脏值检查流程来实现变化侦测；在React是通过对比虚拟DOM来实现变化侦测，而在Vue中也有自己的一套变化侦测实现机制。 object变化侦测1.让Object数据变得“可观测”通过JS提供的Object.defineProperty方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/ 源码位置：src/core/observer/index.js/** * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象 */export class Observer &#123; constructor (value) &#123; this.value = value // 给value新增一个__ob__属性，值为该value的Observer实例 // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作 def(value,'__ob__',this) if (Array.isArray(value)) &#123; // 当value为数组时的逻辑 // ... &#125; else &#123; this.walk(value) &#125; &#125; walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125;&#125;/** * 使一个对象转化成可观测对象 * @param &#123; Object &#125; obj 对象 * @param &#123; String &#125; key 对象的key * @param &#123; Any &#125; val 对象的某个key的值 */function defineReactive (obj,key,val) &#123; // 如果只传了obj和key，那么val = obj[key] if (arguments.length === 2) &#123; val = obj[key] &#125; if(typeof val === 'object')&#123; new Observer(val) &#125; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; console.log(`$&#123;key&#125;属性被读取了`); return val; &#125;, set(newVal)&#123; if(val === newVal)&#123; return &#125; console.log(`$&#123;key&#125;属性被修改了`); val = newVal; &#125; &#125;)&#125; 我们定义了observer类，它用来将一个正常的object转换成可观测的object。 并且给value新增一个__ob__属性，值为该value的Observer实例。这个操作相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作 通过类型判断，如果是object类型，则会调用walk方法，通过循环遍历，调用defineReactive将每一个属性都转换成getter/setter的形式，如果子属性也是一个对象，则通过new Observer(val) 来递归子属性,这样object的所以属性（包括属性）都转化成getter和setting的形式来侦测变化， 1234let car = new Observer(&#123; 'brand':'BMW', 'price':3000&#125;) 这样，car的两个属性就是可观测了。 2.依赖收集在getter中收集依赖，在setter中通知依赖更新。 通过实现Dep类（依赖管理器）订阅器 123456789101112131415161718192021222324252627282930313233343536373839// 源码位置：src/core/observer/dep.jsexport default class Dep &#123; constructor () &#123; this.subs = [] &#125; addSub (sub) &#123; this.subs.push(sub) &#125; // 删除一个依赖 removeSub (sub) &#123; remove(this.subs, sub) &#125; // 添加一个依赖 depend () &#123; if (window.target) &#123; this.addSub(window.target) &#125; &#125; // 通知所有依赖更新 notify () &#123; const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;/** * Remove an item from an array */export function remove (arr, item) &#123; if (arr.length) &#123; const index = arr.indexOf(item) if (index &gt; -1) &#123; return arr.splice(index, 1) &#125; &#125;&#125; 在上面的依赖管理器Dep类中，我们先初始化了一个subs数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。 有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下： 123456789101112131415161718192021222324function defineReactive (obj,key,val) &#123; if (arguments.length === 2) &#123; val = obj[key] &#125; if(typeof val === 'object')&#123; new Observer(val) &#125; const dep = new Dep() //实例化一个依赖管理器，生成一个依赖管理数组dep Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; dep.depend() // 在getter中收集依赖 return val; &#125;, set(newVal)&#123; if(val === newVal)&#123; return &#125; val = newVal; dep.notify() // 在setter中通知依赖更新 &#125; &#125;)&#125; 在getter中调用了dep.depend()方法收集依赖，在setter中调用dep.notify()方法通知所有依赖更新 3.依赖到底是谁实现Watcher类（依赖）订阅者 123456789101112131415161718192021222324252627282930313233343536373839404142export default class Watcher &#123; constructor (vm,expOrFn,cb) &#123; this.vm = vm; this.cb = cb; this.getter = parsePath(expOrFn) this.value = this.get() &#125; get () &#123; window.target = this; const vm = this.vm let value = this.getter.call(vm, vm) window.target = undefined; return value &#125; update () &#123; const oldValue = this.value this.value = this.get() this.cb.call(this.vm, this.value, oldValue) &#125;&#125;/** * Parse simple path. * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125; * parsePath('a.b.c')(data) // 2 */const bailRE = /[^\\w.$]/export function parsePath (path) &#123; if (bailRE.test(path)) &#123; return &#125; const segments = path.split('.') return function (obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return obj = obj[segments[i]] &#125; return obj &#125;&#125; 谁用到了数据，谁就是依赖，我们就为谁创建一个Watcher实例，在创建Watcher实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个Watcher实例就代表这个依赖，当数据变化时，我们就通知Watcher实例，由Watcher实例再去通知真正的依赖。 那么，在创建Watcher实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？ 下面我们分析Watcher类的代码实现逻辑： 当实例化Watcher类时，会先执行其构造函数； 在构造函数中调用了this.get()实例方法； 在get()方法中，首先通过window.target = this把实例自身赋给了全局的一个唯一对象window.target上，然后通过let value = this.getter.call(vm, vm)获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的getter，上文我们说过，在getter里会调用dep.depend()收集依赖，而在dep.depend()中取到挂载window.target上的值并将其存入依赖数组中，在get()方法最后将window.target释放掉。 而当数据变化时，会触发数据的setter，在setter中调用了dep.notify()方法，在dep.notify()方法中，遍历所有依赖(即watcher实例)，执行依赖的update()方法，也就是Watcher类中的update()实例方法，在update()方法中调用数据变化的更新回调函数，从而更新视图。 简单总结一下就是：Watcher先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个watcher收集到Dep中去。收集好之后，当数据发生变化时，会向Dep中的每个Watcher发送通知。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。 4.不足之处向object数据里添加一对新的key/value或删除一对已有的key/value时，它是无法观测到的，导致当我们对object数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。 Vue增加了两个全局API:Vue.set和Vue.delete 5.总结其整个流程大致如下： Data通过observer转换成了getter/setter的形式来追踪变化。 当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。 当数据发生了变化时，会触发setter，从而向Dep中的依赖（即Watcher）发送通知。 Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。 Array的变化侦测由于数组无法使用Object .defineProperty来实现数据响应式 Array型数据还是在getter中收集依赖。 1.实现数组方法拦截器在Vue中创建了一个数组方法拦截器，它拦截在数组实例与Array.prototype之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用Array.prototype上的原生方法。 经过整理，Array原型中可以改变数组自身内容的方法有7个，分别是：push,pop,shift,unshift,splice,sort,reverse。那么源码中的拦截器代码如下： 1234567891011121314151617181920212223242526272829303132// 源码位置：/src/core/observer/array.jsconst arrayProto = Array.prototype// 创建一个对象作为拦截器export const arrayMethods = Object.create(arrayProto)// 改变数组自身内容的7个方法const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; const original = arrayProto[method] // 缓存原生方法 Object.defineProperty(arrayMethods, method, &#123; enumerable: false, configurable: true, writable: true, value:function mutator(...args)&#123; const result = original.apply(this, args) return result &#125; &#125;)&#125;) 在上面的代码中，首先创建了继承自Array原型的空对象arrayMethods，接着在arrayMethods上使用object.defineProperty方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用push方法的时候，其实用的是arrayMethods.push，而arrayMethods.push就是封装的新函数mutator，也就后说，实标上执行的是函数mutator，而mutator函数内部执行了original函数，这个original函数就是Array.prototype上对应的原生方法。 那么，接下来我们就可以在mutator函数中做一些其他的事，比如说发送变化通知 2.使用拦截器把它挂载到数组实例与Array.prototype之间，这样拦截器才能够生效。 其实挂载不难，我们只需把数据的__proto__属性设置为拦截器arrayMethods即可，源码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738// 源码位置：/src/core/observer/index.jsexport class Observer &#123; constructor (value) &#123; this.value = value if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) &#125; else &#123; this.walk(value) &#125; &#125;&#125;// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性export const hasProto = '__proto__' in &#123;&#125;const arrayKeys = Object.getOwnPropertyNames(arrayMethods)/** * Augment an target Object or Array by intercepting * the prototype chain using __proto__ */function protoAugment (target, src: Object, keys: any) &#123; target.__proto__ = src&#125;/** * Augment an target Object or Array by defining * hidden properties. *//* istanbul ignore next */function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125; 上面代码中首先判断了浏览器是否支持__proto__，如果支持，则调用protoAugment函数把value.__proto__ = arrayMethods；如果不支持，则调用copyAugment函数把拦截器中重写的7个方法循环加入到value上。这时我们就可以在拦截器中监听到数据变化了。 3.再谈依赖收集在Observer类中实例化了一个依赖管理器，用来收集数组依赖。 123456789101112131415// 源码位置：/src/core/observer/index.jsexport class Observer &#123; constructor (value) &#123; this.value = value this.dep = new Dep() // 实例化一个依赖管理器，用来收集数组依赖 if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) &#125; else &#123; this.walk(value) &#125; &#125;&#125; 数组的依赖也在getter中收集，那么在getter中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在Observer类中，而我们需要在getter中收集依赖，也就是说我们必须在getter中能够访问到Observer类中的依赖管理器，才能把依赖存进去。源码是这么做 12345678910111213141516171819202122232425262728293031323334353637383940function defineReactive (obj,key,val) &#123; let childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; if (childOb) &#123; childOb.dep.depend() &#125; return val; &#125;, set(newVal)&#123; if(val === newVal)&#123; return &#125; val = newVal; dep.notify() // 在setter中通知依赖更新 &#125; &#125;)&#125;/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。 * 如果 Value 已经存在一个Observer实例，则直接返回它 */export function observe (value, asRootData)&#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else &#123; ob = new Observer(value) &#125; return ob&#125; 在上面代码中，我们首先通过observe函数为被获取的数据arr尝试创建一个Observer实例，在observe函数内部，先判断当前传入的数据上是否有__ob__属性，因为在上篇文章中说了，如果数据有__ob__属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用new Observer(value)将其转化成响应式的，并把数据对应的Observer实例返回。 4.如何通知依赖vaule上的__ob__就是其对应的Observer类实例，有了Observer类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的dep.notify()方法，让它去通知依赖更新即可。 12345678910111213/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ // notify change ob.dep.notify() return result &#125;)&#125; 由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的this就是数据value，拿到value上的Observer类实例，从而你就可以调用Observer类实例上面依赖管理器的dep.notify()方法，以达到通知依赖的目的。 5. 深度侦测所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。 1234567891011121314151617181920212223242526272829303132333435363738394041export class Observer &#123; value: any; dep: Dep; constructor (value: any) &#123; this.value = value this.dep = new Dep() def(value, '__ob__', this) if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) // 将数组中的所有元素都转化为可被侦测的响应式 &#125; else &#123; this.walk(value) &#125; &#125; /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125;export function observe (value, asRootData)&#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else &#123; ob = new Observer(value) &#125; return ob&#125; 对于Array型数据，调用了observeArray()方法，该方法内部会遍历数组中的每一个元素，然后通过调用observe函数将每一个元素都转化成可侦测的响应式数据。 而对应object数据，在上一篇文章中我们已经在defineReactive函数中进行了递归操作 6.数组新增元素的侦测只需拿到新增的这个元素，然后调用observe函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：push、unshift、splice。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。 12345678910111213141516171819202122232425/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args // 如果是push或unshift方法，那么传入参数就是新增的元素 break case 'splice': inserted = args.slice(2) // 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素 break &#125; if (inserted) ob.observeArray(inserted) // 调用observe函数将新增的元素转化成响应式 // notify change ob.dep.notify() return result &#125;)&#125;) 在上面拦截器定义代码中，如果是push或unshift方法，那么传入参数就是新增的元素;如果是splice方法，那么传入参数列表中下标为2的就是新增的元素，拿到新增的元素后，就可以调用observe函数将新增的元素转化成响应式的了。 7. 不足之处对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据 Vue也注意到了这个问题， 为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete","categories":[{"name":"框架原理","slug":"框架原理","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"}]},{"title":"div局中","slug":"div局中","date":"2021-06-23T03:27:03.000Z","updated":"2021-06-23T03:27:17.572Z","comments":true,"path":"2021/06/23/div局中/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/06/23/div%E5%B1%80%E4%B8%AD/","excerpt":"","text":"div居中的几种方法使div水平垂直居中1、flex布局实现（已知元素宽度）给父盒子设置：display: flex;justify-content: center;align-items: center; 2、position（已知元素宽度）父元素设置为：position: relative;子元素设置为：position: absolute;距上50%，据左50%，然后减去元素自身宽度的一半距离就可以实现 3、position + transform （未知宽度）父元素设置为：position: relative;子元素设置为：position: absolute;距上50%，据左50%，然后使用transform: translate(-50%,-50%); 4、position（元素已知宽度）父元素设置为：position: relative;子元素设置为：position: absolute;left、right、bottom、top都为0，margin: auto; 如果子元素不设置宽度和高度，将会铺满整个父级(模态框) 5. table-cell 布局实现table 实现垂直居中，子集元素可以是块元素，也可以不是块元素 使内容（文字，图片）水平垂直居中（table-cell 布局）行元素 text-align ：center； 块元素 ：margin ：0 auto；text-align : center 给元素的父级加，可以使文本或者行级元素(例如：图片)水平居中line-height : 值为元素的高度，可以使元素的文本内容垂直居中margin: 0 auto 使用条件：父级元素宽度可有可无，子级元素必须使块元素，而且要有宽度（否则继承父级） display：table-cell 会使元素表现的类似一个表格中的单元格td，利用这个特性可以实现文字的垂直居中效果。同时它也会破坏一些 CSS 属性，使用 table-cell 时最好不要与 float 以及 position: absolute 一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对margin值无反应，可以响 padding 的设置，表现几乎类似一个 td 元素。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"css","slug":"css","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/css/"}]},{"title":"css性能优化","slug":"css性能优化","date":"2021-06-23T03:26:12.000Z","updated":"2021-06-23T03:26:42.175Z","comments":true,"path":"2021/06/23/css性能优化/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/06/23/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"合并css文件，如果页面加载10个css文件,每个文件1k，那么也要比只加载一个100k的css文件慢。 减少css嵌套，最好不要嵌套三层以上。 不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。 建立公共样式类，把相同样式提取出来作为公共类使用。 减少通配符*或者类似[hidden=”true”]这类选择器的使用，挨个查找所有…这性能能好吗？ 巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。 拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。 不用css表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。 少用css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。 cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。 善后工作，css压缩(在线压缩工具 YUI Compressor) GZIP压缩，是一种流行的文件压缩算法 性能优化避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。避免过分重排浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow 导致reflow发生的情况 改变窗口的大小 改变文字的大小 添加 删除样式表 内容的改变 输入框输入内容也会 伪类的激活 操作class属性 脚本操作dom js改变css类 计算offsetWidth和offsetHeight 设置style属性 改变元素的内外边距 常见重排元素 大小有关的 width,height,padding,margin,border-width,border,min-height 布局有关的 display,top,position,float,left,right,bottom 字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align 隐藏有关的 overflow,overflow-x,overflow-yrepaint 重绘 当一个元素的外观被改变，但是布局没有改变的情况当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素常见的重绘元素 颜色 color,background 边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width 背景有关 background,backgound-image,background-position,background-repeat,background-size 文件压缩性能优化时最容易想到的，也是最常见的方法，就是文件压缩，这一方案往往效果显著文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具webpack，gulp/grunt，rollup，压缩之后能够明显减少，可以大大降低浏览器的加载时间。 去除无用CSS 不同元素或者其他情况下的重复代码， 整个页面内没有生效的CSS代码 有选择地使用选择器 保持简单，不要使用嵌套过多过于复杂的选择器 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。 不要使用类选择器和ID选择器修饰元素标签，如：h3#markdown-content，这一多此一举，还会降低效率 不要为了追求速度而放弃可读性和可维护性 减少使用昂贵的属性硬件加速的好坏","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"css","slug":"css","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/css/"}]},{"title":"圣杯布局和双飞翼布局","slug":"圣杯布局和双飞翼布局","date":"2021-06-23T03:25:28.000Z","updated":"2021-06-23T03:25:52.202Z","comments":true,"path":"2021/06/23/圣杯布局和双飞翼布局/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/06/23/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"通俗的来说就是左右两栏固定宽度，中间部分自适应的三栏布局。 两者本质圣杯布局 首先把left、middle、right都放出来 给它们三个设置上float: left, 脱离文档流； 一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档 left、right设置上各自的宽度middle设置width: 100%; 接下来比较重要了： 给left、middle、right设置position: relative; left设置 left: -leftWidth, right设置 right: -rightWidth; container设置padding: 0, rightWidth, 0, leftWidth; 因为不这样设置 会遮挡middle的内容 双飞翼布局双飞翼布局和圣杯布局很类似，不过是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。 首先把left、middle、right都放出来, middle中增加inner 给它们三个设置上float: left, 脱离文档流； 一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档 left、right设置上各自的宽度 middle设置width: 100%;接下来与圣杯布局不一样的地方： left设置 margin-left: -100%, right设置 right: -rightWidth; container设置padding: 0, rightWidth, 0, leftWidth;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"css","slug":"css","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/css/"}]},{"title":"js时间循环机制","slug":"js时间循环机制","date":"2021-06-23T03:24:10.000Z","updated":"2021-06-23T03:24:40.675Z","comments":true,"path":"2021/06/23/js时间循环机制/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/06/23/js%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"浏览器环境下js引擎的事件循环机制1.执行栈与事件队列基本类型以及对象的指针存放在栈中，对象的值存放在堆内存中。执行栈：js引擎在解析一段代码的时候，将其中的同步代码按照执行顺序加入到执行栈中，然后从头开始执行。当执行完毕后，当前函数的执行上下文会从栈顶弹层出，随之函数及其执行上下文会被销毁，其中的变量会被浏览器回收。事件队列：js引擎遇到异步事件后并不会一直等待其返回结果，而会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列中，被放入的事件不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于空闲时，主线程会取查找事件队列是否又任务，如果有，那么主线程会取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码。如此反复，这样就形成一个无限循环。这个过程被称为事件循环（event loop） 2.macro task与micro task不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。 以下事件属于宏任务： setInterval() setTimeout() 以下事件属于微任务: new Promise() new MutaionObserver() 当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 node环境下的事件循环机制node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 事件循环各阶段详解node中的事件循环的顺序：外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段… timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check: setImmediate()的回调会在这个阶段执行。 close callbacks: 例如socket.on(‘close’, …)这种close事件的回调。 poll先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check阶段check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close阶段当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timer阶段这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callback阶段这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 process.nextTick,setTimeout与setImmediate的区别与使用场景在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate process.nextTick()node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 setTimeout()和setImmediate()setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"v8垃圾回收机制","slug":"v8垃圾回收机制","date":"2021-06-23T03:11:21.000Z","updated":"2021-06-23T03:11:41.425Z","comments":true,"path":"2021/06/23/v8垃圾回收机制/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/06/23/v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"1、为何需要垃圾回收在v8引擎执行js代码的过程中，当遇到函数的情况时，会为其创建一个函数执行的上下文，并添加到调用堆栈的栈顶，函数的作用域中包含了该函数中声明的所以变量，当函数执行完毕后，对面的执行上下文会从栈顶弹出，函数的作用域随之销毁，其包括的所以变量也会统一释放并自动回收。如果不回收，必然导致内存暴增，引发内存泄漏。 2、v8引擎的内存限制由于js的单线程机制和垃圾回收机制，V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个G内存这样的场景 3、v8的垃圾回收策略V8的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。 v8的内存结构主要了解新生代和老生代 新生代(new_space)：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。（Scavenge算法） 老生代(old_space)：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。Mark-Sweep(标记清除)和Mark-Compact(标记整理) 4、如何避免内存泄漏 尽可能少地创建全局变量 手动清除定时器 少用闭包 清除DOM引用 弱引用在ES6中为我们新增了两个有效的数据结构WeakMap和WeakSet，就是为了解决内存泄漏的问题而诞生的。其表示弱引用","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"this、call、apply、bind","slug":"this、call、apply、bind","date":"2021-06-17T10:05:48.000Z","updated":"2021-06-17T10:06:07.883Z","comments":true,"path":"2021/06/17/this、call、apply、bind/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/06/17/this%E3%80%81call%E3%80%81apply%E3%80%81bind/","excerpt":"","text":"this在JavaScript中，this的指向是调用时决定的，而不是创建时决定的，this永远指向最后调用它的那个对象。 全局上下文在全局上下文中，this指全局对象 this等价于window对象 var === this. === window.在浏览器里面this等价于window对象，如果你声明一些全局变量，这些变量都会作为this的属性。 函数上下文在函数内部，this的值取决于函数被调用的方式 直接调用this指向window，严格模式下是undefined 作为对象的一个方法当this所在的函数被以obj.fn()形式调用时，指向obj call()、apply，(不同点：前者传的是若干个参数列表，后者是包含多个参数的数组)this指向绑定的对象 123456789let Person = &#123; name: 'YoLin', age: 25&#125;function say(job) &#123; console.log(`我是$&#123;this.name&#125;，今天&#123;this.age&#125;,职业是$&#123;job&#125;`)&#125;say.call(Person, \"FE\")say.apply(Person, [\"FE\"]) bind()this将永久地被绑定到了bind的第一个参数。与call、apply相似，接受若干个参数列表并返回一个新的函数，不同的是需要我们手动调用。 箭头函数所有的箭头函数都没有自己的this，都指向外层。箭头函数会捕获其所在上下文的this值，作为自己的this值。箭头函数的 this 始终指向函数定义时的 this，而非执行时箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。 作为一个构造函数（new实例化一个对象）this被绑定到正在构造的新对象。通过构造函数创建一个对象其实执行这样几个步骤：1、创建新对象2、将this指向这个对象3、给对象赋值（属性、方法）4、返回this new的过程12345678var a = new myFunction(\"Li\",\"Cherry\");new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,\"Li\",\"Cherry\"); return typeof result === 'obj'? result : obj;&#125; 1、创建一个空对象 obj;2、将新创建的空对象的隐式原型指向其构造函数的显示原型。3、使用 call 改变 this 的指向4、如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 总结如果要判断一个函数的this绑定，就需要找到这个函数的直接调用位置。然后可以顺序按照下面四条规则来判断this的绑定对象： 由new调用：绑定到新创建的对象 由call或apply、bind调用：绑定到指定的对象 由上下文对象调用：绑定到上下文对象 默认：全局对象注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定this，继承外层函数调用的this绑定。 call手写call的思路： 1、将函数设置为对象的一个属性 2、执行该函数 3、删除该函数通过Arguments 对象中取值，然后放入一个数组里1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = &#123;// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// &#125;// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']');&#125;// 执行后 args为 [foo, 'kevin', 18] 把这个参数数组放到要执行的函数的参数里面去 eval() 函数会将传入的字符串当做 JavaScript 代码进行执行 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。最终代码 1234567891011121314Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125; apply与call类似，只是传入的参数是一个数组 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。 返回一个函数 可以传入参数123456789101112131415Function.prototype.myBind = function(context) &#123; if (typeof this !== 'function') &#123; return new Error('Function.prototype.bind - what is trying to be bound is not callable') &#125; var args = Array.prototype.slice.call(arguments,1) var self = this var fNOP = function() &#123;&#125; var fBound = function() &#123; var bingArgs = Array.prototype.slice.call(arguments) self.apply(this instanceof fNOP.prototype ? this : context, args.concat(bindArgs)) &#125; fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound&#125; 类数组具备与数组特征类似的对象 123456let arrayLike = &#123; 0: 1, 1: 2, 2: 3, length: 3&#125;; 获取 DOM 节点的方法方法中的 arguments 都是类数组可以通过for循环进行遍历,类数组无法使用 forEach、splice、push 等数组原型链上的方法 call的使用场景： 对象的继承1234function Parent() &#123;&#125;function Child() &#123; Parent.call(this)&#125; 借用方法类数组想用使用数组的方法1let domNodes = Array.prototype.slice.call(arr) apply的一些妙用:1、获取数组中数字最大最小值12Math.max.apply(null, arr)Math.min.apply(null, arr) 2、合并两个数组1Array.prototype.push.apply(arr1,arr2)","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"instanceof、typeof","slug":"instanceof、typeof","date":"2021-06-17T10:00:58.000Z","updated":"2021-06-17T10:02:26.072Z","comments":true,"path":"2021/06/17/instanceof、typeof/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/06/17/instanceof%E3%80%81typeof/","excerpt":"","text":"typeof实现原理typeof用于判断变量的类型，可以判断number、string、object、undefined、function、boolean、symbol 这7种类型，判断不是object类型的时候可以比较清楚的告诉我们具体是哪一类，但不能明确告诉我们object是哪一种。由于js底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息。 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 对于null和undefined比较特殊，undefined： 用 −2^30 整数来表示null：所以机器码都为0，因此通过typeof判断时候会被当作object使用instanceof判断的话，null直接判断为不是object。因此在使用typeof判断变量类型的时候，最好用来判断基本数据类型（包括symbol），避免对null的判断 还有一个不错的判断类型的方法，Object.prototype.toString,可以利用这个方法来对一个变量类型来进行比较准确的判断 1234567891011121314151617Object.prototype.toString.call(1) // \"[object Number]\"Object.prototype.toString.call('hi') // \"[object String]\"Object.prototype.toString.call(&#123;a:'hi'&#125;) // \"[object Object]\"Object.prototype.toString.call([1,'a']) // \"[object Array]\"Object.prototype.toString.call(true) // \"[object Boolean]\"Object.prototype.toString.call(() =&gt; &#123;&#125;) // \"[object Function]\"Object.prototype.toString.call(null) // \"[object Null]\"Object.prototype.toString.call(undefined) // \"[object Undefined]\"Object.prototype.toString.call(Symbol(1)) // \"[object Symbol]\" instanceof 操作符的实现原理instanceof主要的作用是判断一个实例是否属于某种类型，也可以判断一个实例是否是其父类型或者祖先类型的实例。 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。 因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。 总结：简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"原型、继承","slug":"原型、继承","date":"2021-06-17T09:31:50.000Z","updated":"2021-06-17T09:33:11.681Z","comments":true,"path":"2021/06/17/原型、继承/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/06/17/%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/","excerpt":"","text":"原型在规范里，prototype 被定义为：给其它对象提供共享属性的对象。 JS是通过函数来模拟类，当我们创建一个函数的时候，js会给这个函数自动添加prototype属性，值是一个包含constructor属性的对象，不是空对象。当我们把函数当成构造函数通过new关键词调用的时候，js会帮我们创建该构造函数的实例，实例继承构造函数prototype的所以属性和方法（实例通过设置自己的__proto__指向构造函数的prototype来实现继承） constructorconstructor属性也是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数。 所有 object 对象都有一个隐式引用什么叫隐式引用？所谓的隐式，是指不是由开发者(你和我)亲自创建/操作。__proto__ 原型链原型链的概念，仅仅是在原型这个概念基础上所作的直接推论。既然 prototype 只是恰好作为另一个对象的隐式引用的普通对象。那么，它也是对象，也符合一个对象的基本特征。也就是说，prototype 对象也有自己的隐式引用，有自己的 prototype 对象。 如此，构成了对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。 继承所谓的原型继承，就是指设置某个对象为另一个对象的原型（塞进该对象的隐式引用位置）。在 JavaScript 中，有两类原型继承的方式：显式继承和隐式继承。 显式原型继承所谓的显式原型继承，就是指我们亲自将某个对象设置为另一个对象的原型。通过调用Object.setPrototypeOf 方法 1Object.setPrototypeOf(obj1, obj2) //将obj2设置为obj1的原型对象 还有另一种途径。即是通过 Object.create 方法，直接继承另一个对象。Object.setPropertyOf 和 Object.create 的差别在于： 1）Object.setPropertyOf，给我两个对象，我把其中一个设置为另一个的原型。 2）Object.create，给我一个对象，它将作为我创建的新对象的原型。 隐式原型继承通过 new 去创建 user 对象，可以通过 user.consturctor 访问到它的构造函数。 函数对象和普通对象通过字面量或构造函数new的方式来创建对象 将对象分为函数对象和普通对象，所谓的函数对象，其实就是 JavaScript 的用函数来模拟的类实现 ES5 中的继承实现方法new 关键字手写new12345678var a = myFunction('Deng', 'yongling')function myFunction() &#123; var obj = &#123;&#125; obj.__proto__ = myFunction.prototype var result = myFunction.call(obj, ...arguments) return typeof result === 'object' ? result : obj&#125; 创建一个空对象 将该对象的隐式原型指向构造函数的显式原型 使用call改变this指向 如果无返回值或者返回值是非对象，则返回这个新建的obj，否则直接返回该返回值对象。 继承的多种方式和优缺点1、原型链继承12345678910111213function Parent() &#123; this.name = 'YoLin'&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child() &#123;&#125;Child.prototype = new Parent()var child = new Child()child.getName() // YoLin 存在问题： 1、引用类型得属性被所有实例共享 2、在创建Child实例得时候，不能向Parent传参 2、借用构造函数（经典继承）1234567891011funtion Parent() &#123; this.names = ['YoLin','Deng']&#125;function Child() &#123; Parent.call(this)&#125;var child1 = new Child()child1.names.push('123')// ['YoLin', 'Deng', '123']var child2 = new Child()child2.names // ['YoLin', 'Deng'] 优点： 1、避免了引用类型的属性被所有实例共享 2、可以在Child中向Parent传参12345678function Parent(name) &#123; this.name = name&#125;function Child(name) &#123; Parent.call(this, name)&#125;var child = new Child('YoLin')child.name // YoLin 缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法 3、组合继承原型链继承和经典继承的结合 12345678910111213function Parent(name) &#123; this.name = name; this.colors = ['red', 'blue, green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()Child.prototype.constructor = Child 优点：融合原型链继承和构造函数继承的优点，是javascript中最常用的继承模式 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型时 一次在创建子类型实例的时候 4、原型式继承12345function createObj(o) &#123; funtion F() &#123;&#125; F.prototype = o return new F()&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。缺点：包含引用类型的属性始终都会共享相应的值 5、寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj(o) &#123; var clone = Object.create(o) clone.sayName = fucntion() &#123; console.log('hi') &#125; return clone&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6、寄生组合式继承为了避免重复调用父构造函数 1234567891011121314151617181920212223242526function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function prototpe(child, parent)&#123; const prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype&#125;prototype(Child, Parent) 将组合式继承中的 1Child.prototype = new Parent() 变成调用object重新创建一个新的Parent的原型实例，并赋值给Child的prototype来实现 1prototype(Child, Parent) 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"js执行上下文、作用域链、闭包","slug":"js执行上下文、作用域链、闭包","date":"2021-05-25T02:36:59.000Z","updated":"2021-05-25T02:54:10.438Z","comments":true,"path":"2021/05/25/js执行上下文、作用域链、闭包/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/25/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/","excerpt":"","text":"执行上下文是评估和执行 JavaScript 代码的环境的抽象概念，每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。执行上下文包括： 1、全局执行上下文 2、函数执行上下文 3、Eval函数执行上下文 三个重要属性 变量对象 作用域链 this 执行栈用来存储代码运行时创建的所有上下文（先进后出）但javascript引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文，并压入到当前的执行栈中，每当遇到函数调用会创建一个新的执行上下文并压入到栈顶，当函数执行结束时，执行上下文会从栈中弹出，控制流程到下一个执行上下文，直到所以代码执行完毕后从当前栈中移除全局执行上下文。创建执行上下文有两个阶段 1) 创建阶段 This 绑定 创建词法环境组件内部有两个组件： (1) 环境记录器和 (2) 一个外部环境的引用。两种类型：全局和函数（this不同，外部环境引用不同）在全局环境中，环境记录器是对象环境记录器。在函数环境中，环境记录器是声明式环境记录器。 创建变量环境组件2) 执行阶段 在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。 词法（静态）作用域与动态作用域区别javascript采用的是词法作用域，函数的作用域在函数定义的时候就确定了动态作用域的函数作用域取决于函数调用的时候。 变量对象每一个执行上下文都会分配一个变量对象(variable object)，变量对象的属性由 变量(variable) 和 函数声明(function declaration) 构成。在函数上下文情况下，参数列表(parameter list)也会被加入到变量对象(variable object)中作为属性。变量对象与当前作用域息息相关。不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。有一点特殊就是只有 函数声明(function declaration) 会被加入到变量对象中，而 函数表达式(function expression)则不会。看代码： 12345function a() &#123;&#125;console.log(typeof a) // functionvar a = function _a() &#123;&#125;console.log(typeof a) // functionconsole.log(typeof _a) // undefined 活动对象当函数被激活，那么一个活动对象(activation object)就会被创建并且分配给执行上下文。活动对象由特殊对象 arguments 初始化而成。随后，他被当做变量对象(variable object)用于变量初始化 作用域链由多个执行上下文的变量对象构成的链表就叫做作用域链。以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端Scope = [AO].concat([[Scope]]); 闭包闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束闭包的外部作用域是在其定义的时候已决定，而不是执行的时候（词法作用域） 当外部作用域执行完后，内部函数还存活时，闭包才真正发挥它的作用譬如一下几种情况： 异步任务（定时器，事件处理，ajax请求中的回调） 被外部函数作为返回结果，或者返回结果对象中引用该内部函数 闭包与封装性封装意味着信息隐藏函数与私有状态：通过闭包，可以创建拥有私有状态的函数，闭包使得状态被封装起来。 工厂模式与私有原型对象我们可以通过闭包，只用创建原型对象一次，也能够被所有 Todo 函数调用所公用，并且保证其私有性。示例如下： 12345678910111213let Todo = (function createTodoFactory()&#123; let todoPrototype = &#123; toString : function() &#123; return this.id + \" \" + this.userName + \": \" + this.title; &#125; &#125; return function(todo)&#123; let newTodo = Object.create(todoPrototype); Object.assign(newTodo, todo); return newTodo; &#125;&#125;)();let todo = Todo(&#123;id : 1, title: \"This is a title\", userName: \"Cristi\", completed: false &#125;); 工厂模式与私有构造函数 12345678910let Todo = (function createTodoFactory()&#123; function Todo(spec)&#123; Object.assign(this, spec); &#125; return function(spec)&#123; let todo = new Todo(spec); return Object.freeze(todo); &#125;&#125;)(); 这里，Todo() 工厂函数就是一个闭包。通过它，不管是否使用 new ，我们都可以创建不可变对象，原型对象也只用创建一次，并且它是私有的。 垃圾回收在 Javascript中，局部变量会随着函数的执行完毕而被销毁，除非还有指向他们的引用。当闭包本身也被垃圾回收之后，这些闭包中的私有状态随后也会被垃圾回收。通常我们可以通过切断闭包的引用来达到这一目的。将闭包函数置为 null 总结闭包是一个可以访问外部作用域中变量的内部函数。 这些被引用的变量直到闭包被销毁时才会被销毁。 闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。 可以通过闭包来达到封装性。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"常用的ES6优化升级内容","slug":"常用的ES6优化升级内容","date":"2021-05-24T05:57:59.000Z","updated":"2021-05-24T05:58:36.192Z","comments":true,"path":"2021/05/24/常用的ES6优化升级内容/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/24/%E5%B8%B8%E7%94%A8%E7%9A%84ES6%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E5%86%85%E5%AE%B9/","excerpt":"","text":"一、let 和 const 命令let具有自己的块级作用域，且修复了var声明带来的变量提升问题。使用const声明常量，是不可更改的。 二、对String字符串类型做的常用升级优化 模板字符串（``） 在String的原型上新增includes()方法，取代传统的indexof，语义更清晰 另外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法 1、startsWith: str.startsWith(searchString[, position])*以什么开头，接受两个参数，一个是要搜索的字符串，第二个是搜索开始的位置，默认为0，找到为true，否则为fasle。 2、endsWith：str.endsWith(searchString[, length])*以什么结尾，第一个参数也是搜索的字符串，第二个则是被搜索的字符串长度，默认是str.length 3、padStart:str.padStart(targetLength [, padString])*在原字符串开头填充字符串，直到达到目标长度第一个参数是目标长度，第二个参数是填充字符串，如果字符串太长，则保留左侧 4、padEnd：str.padEnd(targetLength [, padString])*在原字符串末尾填充指定字符串，直到目标长度。与padStart参数相同 5、str.repeat(count)*repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。count：重复的次数，表示新构造的字符串中重复了多少遍原字符串。三、对Array数组类型做的常用升级优化 数组解构赋值:let [a,b,c] = [1,2,3] 扩展运算符: 12let a = [1,2,3];let b = [...a] find和findIndex方法1、find：数组实例find方法，它可接收一个回调函数作为参数，该回调函数可传3个参数分别是当前值、当前位置、原数组。[1,2,3].find((value, index, arr) =&gt; value &gt; 1)执行结果会返回符合条件的首个成员，若没有符合的则返回undefined2、findIndex：与find使用方法类似，不同的是返回符合条件成员位置，没有符合则返回-1 这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。 123[NaN].indexOf(NaN) // -1[NaN].find(x =&gt; Object.is(NaN, x)) // NaN[NaN].findIndex(x =&gt; Object.is(NaN, x)) //0 copyWithin方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。arr.copyWithin(target[, start[, end]])可传如三个参数：1、target表示目标位置，从这个位置开始复制并替换，如果是负数则从尾部开始算，如果target大于arr.length，则不拷贝，若target在start后面，那么复制序列会被修改以符合arr.length2、start表示开始复制元素的起始位置，负数表示从末尾开始算,若不穿start，将从0开始复制3、end表示开始复制元素的结束位置，会拷贝到这个位置，但不包括它，如果是负数，则是从末尾开始算。若不传将复制到数组结尾（默认是arr.length） 123456789101112// 例子[1, 2, 3, 4, 5].copyWithin(-2)// [1, 2, 3, 1, 2][1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(-2, -3, -1)// [1, 2, 3, 3, 4] includesarr.includes(valueToFind[, fromIndex]) valueToFind: 需要查找的元素fromIndex：从fromIndex索引开始查找，可以是负数，表示从末尾开始若着找到对应元素，则返回true，否则返回false[1,2,3].includes(1) // true fillfill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。arr.fill(value[, start[, end]])value: 填充的值start：起始位置索引，默认为0end：结束位置所以，默认是数组长度[1,2,3].fill(6,1) // [1, 6, 6] flatflat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回var newArray = arr.flat([depth])depth: 指定要提取嵌套数组的结构深度，默认值为 1 1[1,2,[3,4,[5,6]]].flat(2) // [1,2,3,4,5,6] 四、对Number数字类型做的常用升级优化 Number原型上新增isFinite(),isNaN()方法，用于优化传统的全局isFinite(), isNaN()，会把非数值类型转为Number类型再判断，而ES6中不会转化类型。分别用于检测数值是否有限、是否是NaN。 Math对象上新增Math.cbrt()，trunc()，hypot()等科学计数法运算方法 五、对Object类型做的常用升级优化 对象属性变量式声明 如果对象属性的值的一个变量，且键值相同，则可省略值的书写 123let &#123; a,b,c &#125; = objlet newObj = &#123;a:a,b:b&#125; //等价于下面的式子let newObj = &#123;a,b&#125; 方法也可以简化为： 12345let obj = &#123; fn() &#123; &#125; &#125; 对象解构赋值let { a,b } = { a:1, b:2 } 对象扩展运算符 123let &#123; a,...rest &#125; = &#123;a:1, b:2, c:3 &#125; // rest = &#123; b:2, c:3 &#125;let obj1 = &#123; a:1, b:2 &#125;let obj2 = &#123;...obj1, c: 3&#125; super 关键字：ES6在Class类里新增了类似this的关键字super。同this总是指向当前函数所在的对象不同，super关键字总是指向当前函数所在对象的原型对象。 在Object原型上新增is()方法，修复了‘===’ 无法比较NaN 新增assign()方法，用于对象新增属性或者对象的合并。123let obj1 = &#123;a: 1, b:2 &#125;let obj2 = &#123;c: 3, d: 4 &#125;Object.assign(obj1, obj2) /// &#123; a:1,b:2,c:3,d:4 &#125; Object.assign(target, ...sources)将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。target是目标对象，将sources源对象分配到该目标对象中。 在Object原型上新增了getPrototypeOf()和setPrototypeOf()方法，用来获取或设置当前对象的prototype对象。 在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组。 六、对Function函数类型做的常用升级优化 箭头函数改变了this的指向，为函数定义时所在的对象，而不是执行时。 函数默认赋值1function fn(a = 1, b) &#123;&#125; 参考链接","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"使用Proxy实现简易的vue双向数据绑定","slug":"使用Proxy实现简易的vue双向数据绑定","date":"2021-05-21T07:52:48.000Z","updated":"2021-05-21T10:25:29.870Z","comments":true,"path":"2021/05/21/使用Proxy实现简易的vue双向数据绑定/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/%E4%BD%BF%E7%94%A8Proxy%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"在实现vue双向数据绑定之前，先了解Proxy相关的概念和用法 proxy概念Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 一些术语 handle包含捕捉器（trap）的占位符对象，可译为处理器对象 traps提供属性访问的方法。这类似于操作系统中捕获器的概念。 target被 Proxy 代理虚拟化的对象。语法const p = new Proxy(target, handler) target要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handle一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。 使用proxy实现数据劫持12345678910111213let data = &#123; name: YoLinDeng, height: '176cm'&#125;const p = new Proxy(data, &#123; get(target, prop) &#123; return Reflect.get(...arguments) &#125;, set(target, prop, newValue) &#123; return Reflect.set(...arguments) &#125;&#125;) 关于vue中数据响应式的原理对数据进行侦测 在vue2.X中，实现一个observe类，对于对象数据，通过Object.defineProperty来劫持对象的属性，实现getter和setter方法，这样就可以在getter的时候知道谁（订阅者）读取了数据，即谁依赖了当前的数据，将它通过Dep类（订阅器）收集统一管理，在setter的时候调用Dep类中的notify方法通知所以相关的订阅者进行更新视图。如果对象的属性也是一个对象的话，则需要递归调用observe进行处理。 对于数组则需要另外处理，通过实现一个拦截器类，并将它挂载到数组数据的原型上，当调用push/pop/shift/unshift/splice/sort/reverse修改数组数据时候，相当于调用的是拦截器中重新定义的方法，这样在拦截器中就可以侦测到数据改变了，并通知订阅者更新视图。 vue3中使用Proxy替代了Object.defineProperty，优点在于可以直接监听对象而非属性、可以直接监听数组的变化、多达13种拦截方法。缺点是兼容性还不够好。Proxy作为新标准将受到浏览器厂商重点持续的性能优化。对模板字符串进行编译 实现Compile解析器类，将template中的模板字符串通过正则等方式进行处理生成对应的ast（抽象语法树），通过调用定义的不同钩子函数进行处理，包括开始标签（start）并判断是否自闭和以及解析属性、结束标签（end）、文本（chars）、注释（comment） 将通过html解析与文本解析的ast进行优化处理，在静态节点上打标记，为后面dom-diff算法中性能优化使用，即在对比前后vnode的时候会跳过静态节点不作对比。 最后根据处理好的ast生产render函数，在组件挂载的时候调用render函数就可以得到虚拟dom。虚拟dom vnode的类型包括注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点，VNode可以描述的多种节点类型，它们本质上都是VNode类的实例，只是在实例化的时候传入的属性参数不同而已。 通过将模板字符串编译生成虚拟dom并缓存起来，当数据发生变化时，通过对比变化前后虚拟dom，以变化后的虚拟dom为基准，更新旧的虚拟dom，使它和新的一样。把dom-diff过程叫做patch的过程，其主要做了三件事，分别是创建/删除/更新节点。 对于子节点的更新策略，vue中为了避免双重循环数据量大时候造成时间复杂度高带来的性能问题，而选择先从子节点数组中4个特殊位置进行对比，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。如果四种情况都没有找到相同的节点，则再通过循环方式查找。实现简易的vue双向数据绑定vue的双向数据绑定主要是指，数据变化更新视图变化，视图变化更新数据。 实现代码如下*12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width= , initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"myVue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123;name&#125;&#125; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;input type=\"text\" v-model=\"test\"&gt; &lt;span&gt;&#123;&#123;test&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; let vm = new vue(&#123; el: '#app', data: &#123; name: 'YoLinDeng', message: '打篮球', test: '双向绑定数据' &#125; &#125;) // console.log(vm._data) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class vue extends EventTarget &#123; constructor(option) &#123; super() this.option = option this._data = this.option.data this.el = document.querySelector(this.option.el) this.compileNode(this.el) this.observe(this._data) &#125; // 实现监听器方法 observe(data) &#123; const context = this // 使用proxy代理，劫持数据 this._data = new Proxy(data, &#123; set(target, prop, newValue) &#123; // 自定义事件 let event = new CustomEvent(prop, &#123; detail: newValue &#125;) // 发布自定义事件 context.dispatchEvent(event) return Reflect.set(...arguments) &#125; &#125;) &#125; // 实现解析器方法，解析模板 compileNode(el) &#123; let child = el.childNodes let childArr = [...child] childArr.forEach(node =&gt; &#123; if (node.nodeType === 3) &#123; let text = node.textContent let reg = /\\&#123;\\&#123;\\s*([^\\s\\&#123;\\&#125;]+)\\s*\\&#125;\\&#125;/g if (reg.test(text)) &#123; let $1 = RegExp.$1 this._data[$1] &amp;&amp; (node.textContent = text.replace(reg, this._data[$1])) // 监听数据更改事件 this.addEventListener($1, e =&gt; &#123; node.textContent = text.replace(reg, e.detail) &#125;) &#125; &#125; else if (node.nodeType === 1) &#123; // 如果是元素节点 let attr = node.attributes // 判断属性中是否含有v-model if (attr.hasOwnProperty('v-model')) &#123; let keyName = attr['v-model'].nodeValue node.value = this._data[keyName] node.addEventListener('input', e =&gt; &#123; this._data[keyName] = node.value &#125;) &#125; // 递归调用解析器方法 this.compileNode(node) &#125; &#125;) &#125;&#125;","categories":[{"name":"框架原理","slug":"框架原理","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"}]},{"title":"手写防抖与节流函数","slug":"手写防抖与节流函数","date":"2021-05-21T07:51:32.000Z","updated":"2021-05-21T07:53:51.914Z","comments":true,"path":"2021/05/21/手写防抖与节流函数/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们经常会绑定一些持续触发的事件，比如resize、scroll、mousemove等等，如果事件调用无限制，会加重浏览器负担，导致用户体验差，我们可以使用debounce(防抖)和throttle(节流)的方式来减少频繁的调用，同时也不会影响实际的效果。 防抖的概念触发事件后n秒后才执行函数，如果在n秒内触发了事件，则会重新计算函数执行时间防抖函数可以分为立即执行，和非立即执行两个版本 非立即执行版本 1234567891011function debounce(fn, wait) &#123; let timer = null return function () &#123; const context = this const args = arguments timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125;&#125; 此函数一开始不会马上执行，而是等到用户操作结束之后等待wait秒后才执行，如果在wait之内用户又触发了事件，则会重新计算 立即执行版本 1234567891011121314function debounce(fn, wait) &#123; let timer = null return function () &#123; const args = arguments const now = !timer timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; timer = null &#125;, wait) if (now) &#123; fn.apply(this, args) &#125; &#125;&#125; 立即执行就是触发事件后马上先执行一次，直到用户停止执行事件等待wait秒后再执行一次 我们可以将两种版本合并成一种 12345678910111213141516171819202122232425/** * @desc 函数防抖 * @param fn 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表示非立即执行 */ function debounce(fn, wait, immediate) &#123; let timer = null return function () &#123; const context = this const args = arguments timer &amp;&amp; clearTimeout(timer) if (immediate) &#123; const now = !timer timer = setTimeout(() =&gt; &#123; timer = null &#125;, wait) now &amp;&amp; fn.apply(context, args) &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125; &#125; &#125; 节流的概念连续触发事件但在n秒内只执行一次函数对于节流有时间戳和定时器两种版本 时间戳版本123456789101112function throttle(fn, wait) &#123; var prev = 0 return function () &#123; let now = Date.now() let context = this let args = arguments if (now - prev &gt; wait) &#123; fn.apply(context, args) prev = now &#125; &#125;&#125; 在持续触发事件的过程中，函数会立即执行，用户在wait秒内不管执行多少次事件，都会等待wait秒后再执行。 定时器版本12345678910111213function throttle(fn, wait) &#123; var timer = null return function () &#123; const context = this const args = arguments if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null fn.apply(context, args) &#125;, wait) &#125; &#125;&#125; 在触发事件的过程中，不会立即执行，并且每wait秒执行一次，在停止触发事件后还会再执行一次。 时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 将两种方式合并 12345678910111213141516171819202122232425262728293031/** * @desc 函数节流 * @param fn 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */ function throttle(fn, wait, type) &#123; if (type === 1) &#123; var prev = 0 &#125; else &#123; var timer = null &#125; return function() &#123; const context = this const args = arguments if (type === 2) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null fn.apply(context, args) &#125;, wait) &#125; &#125; else if(type === 1) &#123; const now = Date.now() if (now - prev &gt; wait) &#123; fn.apply(context, args) prev = now &#125; &#125; &#125; &#125; 参考链接","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"react中实现导航栏状态与地址绑定","slug":"react中实现导航栏状态与地址绑定","date":"2021-05-21T07:39:19.000Z","updated":"2022-05-17T07:38:31.172Z","comments":true,"path":"2021/05/21/react中实现导航栏状态与地址绑定/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/react%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%8A%B6%E6%80%81%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A/","excerpt":"","text":"一、项目初始化1. 安装与运行构建项目：yarn create react-app my-app启动：yarn start当然也可以使用npm： 全局安装：npm install -g create-react-app 构建项目：npx create-react-app my-app 启动：npm start 2.安装路由依赖在项目中执行：npm install react-router-dom --save 3.在App.js中引入router由于简单演示，就不单独对router进行封装了。安装完成后，我们在App.js中引入路由相关组件BrowserRouter、Route、Switch、Redirect在顶部引入：import { BrowserRouter as Router, Route, Switch, Redirect } from &#39;react-router-dom&#39;详细代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react';import Home from '@/views/home'import Study from '@/views/study'import Type from '@/views/type'import Label from '@/views/label'import About from '@/views/about'import &#123; Layout &#125; from 'antd'import Header from '@/components/Header'import Persional from '@/components/Persional'import &#123; BrowserRouter as Router, Route, Switch, Redirect &#125; from 'react-router-dom'const &#123; Footer, Content, Sider&#125; = Layout;// 导入子组件class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\" &gt; &lt;Layout&gt; &lt;Sider&gt; &lt;Persional /&gt; &lt;/Sider&gt; &lt;Content&gt; &lt;Router&gt; &lt;Header /&gt; &lt;Switch&gt; &lt;Route path=\"/home\" exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/study\" component=&#123;Study&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/type\" component=&#123;Type&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/label\" component=&#123;Label&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/about\" component=&#123;About&#125;&gt;&lt;/Route&gt; &lt;Redirect from=\"/*\" to=\"/home\"&gt;&lt;/Redirect&gt; &lt;/Switch&gt; &lt;Footer&gt;Footer&lt;/Footer&gt; &lt;/Router&gt; &lt;/Content&gt; &lt;/Layout&gt; &lt;/div&gt; ); &#125;&#125;export default App; 这里用到了antd的Layout布局组件进行布局首先我们将我们的视图组件引入进来（import Home from &#39;@/views/home&#39;），并在Route标签中配置：（以home为例）&lt;Route path=&quot;/home&quot; exact component={Home}&gt;&lt;/Route&gt; 4.编写Header头部导航组件在components目录下新建Header目录，并在其目录下新建index.js及index.scss文件，这里使用scss进行编写。安装命令： 12npm install node-sass --save-dev npm install sass-loader --save-dev 为了实现导航栏状态与地址联动，关键是要实现组件初始化时的处理逻辑，也就是组件挂载的时候，即在生命周期函数componentDidMount中实现。要实现以下两点： 修改当前地址对应导航栏状态 监听浏览器前进后退，即监听history对象关键代码如下：1234567891011121314151617componentDidMount = () =&gt; &#123; let moren = this.props.location.pathname let text = moren.substring(moren.lastIndexOf('/') + 1, moren.length) // 当访问的目录不在这个数组里时候，当前状态是home，即重定向到home页面 !['home', 'study', 'type', 'label', 'about', 'search'].includes(text) &amp;&amp; (text = 'home') this.setState(&#123; current: text &#125;) // 监听history变化 history.listen((event) =&gt; &#123; let test = event.pathname let text = test.substring(test.lastIndexOf('/') + 1, test.length) this.setState(&#123; current: text &#125;) &#125;) &#125; 组件完整代码如下：index.js:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; Component &#125; from 'react';import &#123; Row, Col, Menu &#125; from 'antd';import &#123; Link, withRouter &#125; from 'react-router-dom'import &#123; HomeOutlined, FolderOpenOutlined, AppstoreOutlined, PushpinOutlined, UserOutlined, SearchOutlined &#125; from '@ant-design/icons';import './index.scss'import &#123; createBrowserHistory &#125; from 'history';const history = createBrowserHistory() // history模式class Header extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; logo: '', current: 'home' &#125; &#125; handleClick = e =&gt; &#123; this.setState(&#123; current: e.key &#125;); &#125; componentDidMount = () =&gt; &#123; let moren = this.props.location.pathname let text = moren.substring(moren.lastIndexOf('/') + 1, moren.length) !['home', 'study', 'type', 'label', 'about', 'search'].includes(text) &amp;&amp; (text = 'home') this.setState(&#123; current: text &#125;) history.listen((event) =&gt; &#123; let test = event.pathname let text = test.substring(test.lastIndexOf('/') + 1, test.length) this.setState(&#123; current: text &#125;) &#125;) &#125; render() &#123; const &#123; current &#125; = this.state; return( &lt;div className=\"header-wrapper\"&gt; &lt;Row&gt; &lt;Col span=&#123;18&#125; push=&#123;6&#125; className=\"right-box\"&gt; &lt;Menu onClick=&#123;this.handleClick&#125; selectedKeys=&#123;[current]&#125; mode=\"horizontal\"&gt; &lt;Menu.Item key=\"home\" icon=&#123;&lt;HomeOutlined /&gt;&#125;&gt; &lt;Link to=\"/home\"&gt;首页&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"study\" icon=&#123;&lt;FolderOpenOutlined /&gt;&#125;&gt; &lt;Link to=\"/study\"&gt;学习&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"type\" icon=&#123;&lt;AppstoreOutlined /&gt;&#125;&gt; &lt;Link to=\"/type\"&gt;分类&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"label\" icon=&#123;&lt;PushpinOutlined /&gt;&#125;&gt; &lt;Link to=\"/label\"&gt;标签&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"about\" icon=&#123;&lt;UserOutlined /&gt;&#125;&gt; &lt;Link to=\"/about\"&gt;关于&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"search\" icon=&#123;&lt;SearchOutlined /&gt;&#125;&gt; 搜索 &lt;/Menu.Item&gt; &lt;/Menu&gt; &lt;/Col&gt; &lt;Col span=&#123;6&#125; pull=&#123;18&#125; className=\"left-box\"&gt; &lt;strong className=\"logo-name\"&gt;Deng&lt;/strong&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; ) &#125;&#125;export default withRouter(Header) 注意：为了能够拿到this.props.location.pathname,需要使用withRouter处理组件，并把Header组件放在BrowserRouter标签中。这样就能够实现导航栏状态与地址绑定了","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"react","slug":"react","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/react/"}]},{"title":"sass常用方法","slug":"sass常用方法","date":"2021-05-21T07:37:26.000Z","updated":"2021-05-21T07:37:47.825Z","comments":true,"path":"2021/05/21/sass常用方法/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/sass%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、什么是sassSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，提供了许多便利的写法，大大提高的开发效率。下面总结了SASS的主要用法，想要了解更多可以查阅文档 二、安装1、由于sass依赖于Ruby，因此需要先安装Ruby，然后执行gem install sass2、若在vue-cli或react-create-app中使用，在项目中安装依赖： 12npm install node-sass --save-devnpm install sass-loader --save-dev 三、基础用法3.1 变量SASS允许使用变量，所有变量以$开头 1234$color: #ccc;div &#123; color: $color;&#125; 如果变量需要镶嵌在属性中之中，就必须需要写在#{}之中 1234$side: right;div &#123; border-#&#123;$side&#125;-radius: 10px;&#125; 3.2 计算能力SASS允许在代码中使用算式 123456$var: 10px;div &#123; width：(20px/2); top: 10px + 20px; left: $var * 2&#125; 3.3 嵌套能力一般我们写多个选择器时，一般这样： 123div h2 &#123; border:1px solid #ccc;&#125; 使用sass可以写成： 12345div &#123; h2 &#123; border:1px solid #ccc; &#125;&#125; 属性也可以嵌套,比如font-size属性，可以写成 12345div &#123; font：&#123; size：18px; &#125;&#125; 可以使用&amp;引用父元素 1234div &#123; &amp;::after &#123; &#125;&#125; 四、代码重用4.1 继承SASS允许一个选择器，继承另一个选择器 123.class1 &#123; color: #ccc;&#125; 如果要继承class1，需要使用@extend命令 1234.class2 &#123; @extend .class1; font-size: 18px;&#125; 4.2 Mixin(混合)使用@mixin声明代码块，达到重用代码块的作用，在需要用的地方使用@include调用 123456@mixin right &#123; margin-right: 20px;&#125;div &#123; @include right;&#125; @minxin可以设置参数以及参数默认值 123456@mixin left($value: 20px) &#123; margin-left: $value;&#125;div &#123; @include left(10px)&#125; 4.3 颜色函数1234lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 4.4 引入文件使用@import命令，用来引入外部文件@import 文件路径 五、进阶用法5.1 条件语句12345678div &#123; @if computed($width) &gt; 10 &#123; width: 10% &#125; @if computed($height) &gt; 10 &#123; height: 10px; &#125; @else &#123; height: 20px; &#125;&#125; 5.2 循环语句for循环: 12345@for $i from 1 to 10 &#123; .content-#&#123;$i&#125; &#123; width: #&#123;$i&#125;px; &#125; &#125; while循环: 12345 $x: 6; @while $x &gt; 0 &#123; .item-#&#123;$x&#125; &#123; width: $x + 10px; &#125; $x: $x - 1; &#125;z each: 12345@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url(\"/image/#&#123;$member&#125;.jpg\"); &#125; &#125; 自定义函数1234567 @function count($n) &#123; @return $n + 1; &#125; div &#123; width: count(5px); &#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scss","slug":"scss","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/scss/"}]},{"title":"vue-cli中使用svgIcon","slug":"vue-cli中使用svgIcon","date":"2021-05-21T03:28:04.000Z","updated":"2021-05-21T03:28:39.990Z","comments":true,"path":"2021/05/21/vue-cli中使用svgIcon/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/vue-cli%E4%B8%AD%E4%BD%BF%E7%94%A8svgIcon/","excerpt":"","text":"一、安装依赖包123npm install svg-sprite-loader -D或者yarn add svg-sprite-loader -D 二、配置vue.config.js文件在顶部写入 1234const path = require('path')function resolve (dir) &#123; return path.join(__dirname, dir)&#125; 在chainWebpack中增加下列配置 12345678910chainWebpack (config) &#123; config.module.rule('svg') .exclude.add(resolve('src/icons')) config.module.rule('icons') .test(/\\.svg$/) .include.add(resolve('./src/icons')).end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options(&#123; symbolId: 'icon-[name]' &#125;) &#125; 三、实现SvgIcon组件组件结构如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;svg :class=\"svgClass\" v-on=\"$listeners\"&gt; &lt;use :xlink:href=\"iconName\" /&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String, default: '' &#125; &#125;, computed: &#123; iconName () &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass () &#123; if (this.className) &#123; return 'svg-icon ' + this.className &#125; else &#123; return 'svg-icon' &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 四、根目录下创建icons/svg目录 用于存放我们所需要用的svg文件 五、新建plugins目录及index.js文件1234567import Vue from 'vue'import SvgIcon from '@/components/SvgIcon'const req = require.context('@/icons/svg', true, /\\.svg$/)req.keys().map(req)Vue.component('svg-icon', SvgIcon) 其作用是在Vue实例上创建SvgIcon组件，其中require.context的作用是获取一个特定的上下文,遍历文件夹中的指定文件，主要用来实现自动化导入模块 最后在main.js中引入plugins, import &#39;@/plugins&#39; 六、SvgIcon 组件的使用1&lt;svg-icon icon-class=\"icon-name\" class=\"down\"&gt;&lt;/svg-icon&gt; 其中icon-class为svg文件名， class为类名","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"},{"name":"组件化","slug":"组件化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"vue中组件通信之findComponents","slug":"vue中组件通信之findComponents","date":"2021-05-21T03:27:02.000Z","updated":"2021-05-21T03:27:42.935Z","comments":true,"path":"2021/05/21/vue中组件通信之findComponents/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8BfindComponents/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839// 向上查找组件 context为当前组件上下文对象，componentName为组件名const findUpwardComponent = (context, componentName) =&gt; &#123; let parent = context.$parent let name = parent.$options.name while (parent &amp;&amp; (!name || !name.includes(componentName))) &#123; parent = parent.$parent if (parent) name = parent.$options.name &#125; return parent&#125;// 查找兄弟组件const findBrotherComponents = (ctx, componentName, exceptMe = true) =&gt; &#123; const $brothers = ctx.$parent.$children.filter(item =&gt; &#123; return item.$options.name &amp;&amp; item.$options.name.includes(componentName) &#125;) const index = $brothers.findIndex(item =&gt; item._uid === ctx._uid) if (exceptMe &amp;&amp; index &gt; -1) $brothers.splice(index, 1) return $brothers&#125;// 向下查找const findDownwardComponent = (context, componentName) =&gt; &#123; const $children = context.$children let bean = null if ($children.length) &#123; for (const child of $children) &#123; const name = child.$options.name if (name &amp;&amp; name.includes(componentName)) &#123; bean = child break &#125; else &#123; bean = findDownwardComponent(child, componentName) if (bean) break &#125; &#125; &#125; return bean&#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"}]},{"title":"scss实现retina屏1px边框","slug":"scss实现retina屏1px边框","date":"2021-05-21T03:25:32.000Z","updated":"2021-05-21T03:26:10.250Z","comments":true,"path":"2021/05/21/scss实现retina屏1px边框/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/scss%E5%AE%9E%E7%8E%B0retina%E5%B1%8F1px%E8%BE%B9%E6%A1%86/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// =======================// 用法： // @include retina-border(1,1,1,1);// 数值 代表 各 边框的宽度 上右下左// =======================@mixin _border-scale($dpr) &#123; width: 100% * $dpr; height: 100% * $dpr; -webkit-transform: scale(1 / $dpr); -webkit-transform-origin: 0 0; transform: scale(1 / $dpr); transform-origin: 0 0;&#125;@mixin _border-base() &#123; content: \"\"; position: absolute; top: 0; left: 0; pointer-events: none;&#125;@mixin retina-border($top: 0, $right: 0, $bottom: 0, $left: 0, $cor: #000000) &#123; position: relative; &amp;::before &#123; border-top: #&#123;$top&#125;px solid $cor; border-right: #&#123;$right&#125;px solid $cor; border-bottom: #&#123;$bottom&#125;px solid $cor; border-left: #&#123;$left&#125;px solid $cor; @include _border-base(); @media screen and (-webkit-min-device-pixel-ratio: 1) &#123; @include _border-scale(1); &#125; @media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123; @include _border-scale(1.5); &#125; @media screen and (-webkit-min-device-pixel-ratio: 2) &#123; @include _border-scale(2); &#125; @media screen and (-webkit-min-device-pixel-ratio: 3) &#123; @include _border-scale(3); &#125; &#125;&#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scss","slug":"scss","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/scss/"}]},{"title":"常用的git命令操作","slug":"常用的git命令操作","date":"2021-05-21T03:21:47.000Z","updated":"2021-05-21T03:24:39.088Z","comments":true,"path":"2021/05/21/常用的git命令操作/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","excerpt":"","text":"安装在使用git之前需要先安装它下载git 以windows系统为例子，安装完成后，鼠标右键点击桌面，出现Git Bash Here和 Git GUI Here 说明安装成功。 命令设置用户名和邮箱12git config --global user.name \"\" git config --global user.email \"\" 克隆远程仓库与代码提交1、在github上新建项目new repositories后，复制https地址或ssh2、在相应的目录，右键选择 git bash here 进入 git操作界面3、输入 git clone “复制的仓库地址”4、对仓库内存进行修改5、cd 文件夹名称（进入文件夹）6、git add .（或git add –all）7、git commit -m “需要写的提交说明”8、git push 其中git add . 与git add –all的区别是:（1）.git add –all可以提交未跟踪、修改和删除文件。（2）.git add .可以提交未跟踪和修改文件，但是不处理删除文件。 创建新的分支1git checkout -b 分支名称 （创建并切换至该分支） 注：新建的分支第一次push： git push -u origin 分支名 查看当前分支12git branch // 本地分支git branch -a // 所以分支,包括线上 删除分支12git branch -D 分支名 // 删除本地分支git push origin --delete 分支名 // 删除远程分支 切换分支1git checkout 分支名 合并分支123456789101112131415161718191、先切换到master分支 git checkout master2、拉取最新代码 git pull3、切换到自己的分支 并将master分支与自己的分支合并，然后解决冲突git merge master 解决完冲突后，git add --all git commit -m\"\"git fetch origin master// 虚拟的更新远程的mastergit merge origin/master //合并远程mastergit push 推到自己的远程分支4、切换到 master 分支5、将自己的分子合并到master 分支git merge 分支名 跟踪到远程名字相同的分支1git branch --set-upstream-to=origin/分支名 分支名 将更改加入暂存区12345git stash save \"描述信息\"git stash list : 显示保存列表。git stash pop 恢复最近保存的记录并把恢复的记录从保存列表中删除 查看与生成公钥进入该目录并列出其中内容： 12345cd ~/.sshlscat id_rsa.pub // 查看公钥 设置邮箱与用户名 123git config --global user.name \"\"git config --global user.email \"\" 清理之前的公钥 12345mkdir key_backupcp id_rsa* key_backuprm id_rsa* 生成 1ssh-keygen -t rsa -C \"邮箱号\" // C是大写 查看 1cat id_rsa.pub 版本回滚查看版本 1git log -num // num: 版本数量 回滚到指定的版本 1git reset --hard id // id: 版本id","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/git/"}]},{"title":"vue中实现倒计时组件与毫秒效果","slug":"vue中实现倒计时组件与毫秒效果","date":"2021-05-21T03:10:58.000Z","updated":"2021-05-21T03:20:28.928Z","comments":true,"path":"2021/05/21/vue中实现倒计时组件与毫秒效果/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%AF%AB%E7%A7%92%E6%95%88%E6%9E%9C/","excerpt":"","text":"时分秒倒计时组件template12345678910111213141516171819202122232425&lt;template&gt; &lt;!-- 倒计时组件 --&gt; &lt;div class=\"downTime-wrapper\"&gt; &lt;!-- 这里是显示还未结束时的内容，这里只是我这得布局，你可以随意。 --&gt; &lt;div class=\"time\" v-show=\"!isShow\"&gt; &lt;!-- &lt;span class=\"hour\"&gt;&#123;&#123;myDay&#125;&#125;&lt;/span&gt; : --&gt; &lt;div class=\"hour\"&gt; &lt;span&gt;&#123;&#123; getHours1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getHours2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;span class=\"dian\"&gt;:&lt;/span&gt; &lt;div class=\"minute\"&gt; &lt;span&gt;&#123;&#123; getMinutes1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getMinutes2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;span class=\"dian\"&gt;:&lt;/span&gt; &lt;div class=\"second\"&gt; &lt;span&gt;&#123;&#123; getSeconds1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getSeconds2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 这里是显示结束后的内容 --&gt; &lt;span class=\"second\" v-show=\"isShow\"&gt;&#123;&#123;clocker&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; script12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;script&gt;export default &#123; name: 'downTime', props: &#123; // 接收父组件传递过来的参数,这里传了 结束时间 - 开始时间 - 结束后显示的内容 endTime: &#123; type: Number &#125;, startTime: &#123; type: Number &#125;, endMsg: &#123; type: String &#125; &#125;, data () &#123; return &#123; isShow: false, // 控制显示结束或还未结束显示的内容 clocker: '', // 结束后显示的内容 timeObj: null, // 时间对象,下方会用到 myDay: 0, // 我定义来接收计算出来的 天 的 myHours: 0, // 我定义来接收计算出来的 小时 的 myMinutes: 0, // 我定义来接收计算出来的 分钟 的 mySeconds: 0// 我定义来接收计算出来的 秒钟 的 &#125; &#125;, computed: &#123; getHours1 () &#123; return this.myHours &lt; 10 ? 0 : parseInt((this.myHours % 100) / 10) &#125;, getHours2 () &#123; return parseInt(this.myHours % 10) &#125;, getMinutes1 () &#123; return this.myMinutes &lt; 10 ? 0 : parseInt((this.myMinutes % 100) / 10) &#125;, getMinutes2 () &#123; return parseInt(this.myMinutes % 10) &#125;, getSeconds1 () &#123; return this.mySeconds &lt; 10 ? 0 : parseInt((this.mySeconds % 100) / 10) &#125;, getSeconds2 () &#123; return parseInt(this.mySeconds % 10) &#125; &#125;, mounted () &#123; &#125;, methods: &#123; option () &#123; // 计算时间差 let timeLag = (this.endTime - this.startTime) / 1000 // 判断当前是否时分秒的值是否大于10 const add = num =&gt; &#123; return num &lt; 10 ? '0' + num : num &#125; // 时间倒计时运算的方法 const timeFunction = () =&gt; &#123; const time = timeLag-- this.timeObj = &#123; // 时间对象 seconds: Math.floor(time % 60), minutes: Math.floor(time / 60) % 60, hours: Math.floor(time / 60 / 60) % 24, days: Math.floor(time / 60 / 60 / 24) &#125; // 计算出时分秒 this.myDay = `$&#123;add(this.timeObj.days)&#125;` this.myHours = `$&#123;add(this.timeObj.hours)&#125;` this.myMinutes = `$&#123;add(this.timeObj.minutes)&#125;` this.mySeconds = `$&#123;add(this.timeObj.seconds)&#125;` // 当时间差小于等于0时,停止倒计时 if (time &lt;= 0) &#123; this.isShow = true this.clocker = this.endMsg clearInterval(go) &#125; &#125; // 开始执行倒计时 timeFunction() // 每一秒执行一次 const go = setInterval(() =&gt; &#123; timeFunction() &#125;, 1000) &#125; &#125;, watch: &#123; endTime: &#123; handler (newName, oldName) &#123; this.option() &#125;, immediate: true, deep: true &#125; &#125;&#125;&lt;/script&gt; 备注：我将时分秒使用计算属性分成了个位和十位两部分展示，在watch中深度监听endTime属性的变化并重新调用定时器 style1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style lang=\"scss\" scoped&gt;.downTime-wrapper&#123; display: inline-block; .dian &#123; font-weight: bold; position: relative; top: -5px; &#125; .hour&#123; display: inline-block; font-size: 36px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125; .minute&#123; display: inline-block; font-size: 36px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125; .second &#123; display: inline-block; font-size: 36px; margin-top: -5px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125;&#125;&lt;/style&gt; 使用在页面中引入并注册后即可使用 12345&lt;timer :endTime=\"item.endTime\" :startTime=\"new Date().getTime()\" :endMsg=\"item.endMsg\"&gt;&lt;/timer&gt; 毫秒倒计时效果在template中加入&lt;b id=&quot;timehs&quot;&gt;:00&lt;/b&gt; 声明timeDt方法 123456789101112131415161718methods: &#123; timeDt () &#123; this.timer1 = setTimeout(function () &#123; var haomiao = 99 document.getElementById('timehs').innerHTML = ':' + haomiao this.timer2 = setInterval(function () &#123; const timehs = document.getElementById('timehs') if (timehs) &#123; timehs.innerHTML = `:$&#123;haomiao &lt; 10 ? `0$&#123;haomiao&#125;` : haomiao&#125;` &#125; haomiao-- if (haomiao &lt; 0) &#123; haomiao = 99 &#125; &#125;, 10) &#125;, 1000) &#125; &#125; 在create生命周期函数中调用timeDt方法 12345created () &#123; this.$nextTick(() =&gt; &#123; this.timeDt() &#125;) &#125;,","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"},{"name":"组件化","slug":"组件化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"Mongoose在egg中的运用","slug":"Mongoose在egg中的运用","date":"2021-05-21T03:04:54.000Z","updated":"2021-05-21T03:08:49.103Z","comments":true,"path":"2021/05/21/Mongoose在egg中的运用/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/Mongoose%E5%9C%A8egg%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"Mongoose是什么？Mongoose是MongoDB的一个对象模型工具，封装了许多MongoDB对文档的的增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。###在egg项目中如何使用？ 1、安装npm i egg-mongoose --save 2、配置在根目录下的/config/plugin.js中配置插件 1234exports.mongoose = &#123; enable: true, package: 'egg-mongoose',&#125;; 3、连接数据库在根目录下的/config/config.default.js增加配置，其中url为我们的数据库地址，可通过环境变量来区分开发环境还是生产环境，并且确定是否使用用户名密码的数据库const prod = process.env.npm_config_server_prod; 12345678mongoose: &#123; client: &#123; url: prod ? 'mongodb:eggadmin:123456@localhost:27017/DbName' : 'mongodb://127.0.0.1:27017/DbName', options: &#123; useUnifiedTopology: true, &#125;, &#125;, &#125;, 4、配置与使用（1）数据表配置在app目录下新建model文件夹，在model文件夹下新建JS文件作为数据表的配置内容，下面以书籍表的配置为例 123456789101112131415161718192021222324252627282930'use strict';/** * @description: Mongoose book Schema, */module.exports = app =&gt; &#123; const mongoose = app.mongoose; const Schema = mongoose.Schema; const BookSchema = new Schema(&#123; desc: &#123; type: String &#125;, /* 书籍描述 */ name: &#123; type: String &#125;, /* 书籍名称 */ press: &#123; type: String &#125;, /* 出版社 */ author: &#123; type: String &#125;, /* 作者 */ image: &#123; type: Array &#125;, /* 书籍图片列表*/ price: &#123; type: String &#125;, /* 价格 */ book_type: &#123; /* 书籍分类id */ type: Schema.Types.ObjectId, ref: 'BookClassify', &#125;, user: &#123; /* 书籍发布者id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, create_time: &#123; type: String &#125;, /* 创建时间 */ status: &#123; type: String &#125;, /* 状态，1：待购买，2：已购买*/ look: &#123; type: Number &#125; /* 浏览数量 */ &#125;); return mongoose.model('Book', BookSchema);&#125;; 可以看到我们可以通过Schema来定义表结构，可以指定字段的类型及关联，设置完字段后就可以生成model了，这里算是非常简单的配置，更多配置方法可参考文档 (2)、使用mongoose方法配置完数据表结构后，我们就可以再service层中调用mongoose的方法对文档进行增删查改了，已书籍列表的处理逻辑为例子 12345678910111213141516171819202122232425262728293031323334353637383940async findbookList(data) &#123; const &#123; type, page, pageSize, desc, status, userId &#125; = data; const searchVal = &#123;&#125; if (type) &#123; searchVal.book_type = mongoose.Types.ObjectId(type) &#125; if (status) &#123; searchVal.status = status &#125; if (userId) &#123; searchVal.user = mongoose.Types.ObjectId(userId) &#125; const search_term = &#123; $or: [ &#123; desc: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; name: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; author: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; press: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, ], &#125;; const totalNum = await this.ctx.model.Book.find(searchVal).and(search_term).countDocuments(); const result = await this.ctx.model.Book.find(searchVal) .populate(&#123; path: 'user', select: &#123; name: 1, image: 1 &#125; &#125;) .populate(&#123; path: 'book_type' &#125;) .and(search_term) .sort(&#123; create_time: -1 &#125;) .skip((parseInt(page) - 1) * parseInt(pageSize)) .limit(parseInt(pageSize)); return result ? &#123; bean: &#123; records: result, current: page, size: result.length, total: totalNum, &#125;, ...app.config.msg.GET_SUCCESS &#125; : app.config.msg.GET_ERR;&#125; 可以看到，通过this.ctx.model.Book就可以获取到Book的model并且可以调用mongoose需要的方法，例如populate、find、and、sort、skip、limit 等等。 5、egg-Mongoose常用的方法增加数据1this.ctx.model.Book.create(data,callback); 其中data为json数据结构，callback为操作后的回调函数 查询数据获取所有数据，返回是一个数组1this.ctx.model.Book.find() 获取一个数据，返回是一个对象1this.ctx.model.Book.findOne() 条件查询1this.ctx.model.Article.find(conditions,callback); 其中conditions为查询的条件，callback为回调函数conditions有一下几种情况： 具体数据： 1this.ctx.model.Book.find(&#123;_id：5c4a19fb87ba4002a47ac4d, name: \"射雕英雄传\" &#125;, callback); 条件查询： 1234567\"$lt\" 小于\"$lte\" 小于等于\"$gt\" 大于\"$gte\" 大于等于\"$ne\" 不等于// 查询价格大于100小于200的书籍数组this.ctx.model.Book.find(&#123; \"price\": &#123; $get:100 , $lte:200 &#125;); 或查询 OR 123456\"$in\" 一个键对应多个值\"$nin\" 同上取反, 一个键不对应指定值\"$or\" 多个条件匹配, 可以嵌套 $in 使用\"$not\" 同上取反, 查询与特定模式不匹配的文档this.ctx.model.Book.find(&#123;\"name\":&#123; $in: [\"射雕\",\"倚天\"]&#125; ); 删除数据1this.ctx.model.Book.remove(conditions,callback); 更新数据1this.ctx.model.Book.update(conditions, update, callback) conditions为条件，update是更新的值对象 排序1this.ctx.model.Book.sort(&#123; create_time: -1 &#125;); 其中-1表示降序返回。 1表示升序返回 限制数量1this.ctx.model.Book.limit(number); number表示限制的个数 跳过文档返回1this.ctx.model.Book.skip(number); number表示跳过的个数,skip经常搭配limit实现分页的功能 条件数组and在find后面可使用and对查询结果进行进一步条件筛选，相当于并且的意思。 123456789const search_term = &#123; $or: [ &#123; desc: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; name: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; author: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; press: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, ], &#125;; this.ctx.model.Book.find().and(search_term) 关联查询populate123456789101112// 在model中配置字段时候指定关联的表名，就可以通过populate来进行表的关联查询user: &#123; /* 书籍发布者id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, this.ctx.model.Book.find() .populate(&#123; path: 'user', select: &#123; name: 1, image: 1 &#125; &#125;) 聚合管道Aggregate12345this.ctx.model.Template.aggregate([ &#123; $match: &#123; name &#125; &#125;, &#123; $sort: &#123; create_time: -1 &#125; &#125;, &#123; $group: &#123; _id: '$name', user_id: &#123; $first: '$modifier' &#125; &#125; &#125;, ]); Mongoose聚合管道aggregate常用的操作有$project 、$match 、$group、$sort、$limit、$skip、$lookup 表关联 批量操作bulkWrite12345678910111213141516const template_list = await ctx.model.Template.aggregate([ &#123; $sort: &#123; create_time: -1 &#125; &#125;, &#123; $group: &#123; _id: '$name', template_id: &#123; $first: '$_id' &#125;, label: &#123; $first: '$label' &#125; &#125; &#125;, ]); const update_value = []; template_list.forEach(item =&gt; &#123; if (!item.label) &#123; update_value.push(&#123; updateOne: &#123; filter: &#123; _id: item.template_id &#125;, update: &#123; label: '' &#125;, &#125;, &#125;); &#125; &#125;); await ctx.model.Template.bulkWrite(update_value); 可以进行一系列批量增加、删除、更新等操作。 mongoose还有非常多的方法可以提供给我的灵活使用，我们在使用的时候可以结合业务逻辑选择合适的方法来提高我们操作数据库的效率。在我们使用它之前可以认真的阅读官方文档","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/mongoDB/"}]},{"title":"egg.js+mongoose实现二级评论","slug":"egg-js-mongoose实现二级评论","date":"2021-05-21T02:57:33.000Z","updated":"2021-05-21T02:58:54.227Z","comments":true,"path":"2021/05/21/egg-js-mongoose实现二级评论/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/egg-js-mongoose%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA/","excerpt":"","text":"1、首先我们先在model目录下新建comment.js文件，这里使用egg-mongoose进行配置表以及字段，这里关键需要parent_id作为父级字段，若默认为0则是第一级评论，如果为id，则是二级评论。 12345678910111213141516171819202122232425262728'use strict';/** * @description: Mongoose comment Schema, */module.exports = app =&gt; &#123; const mongoose = app.mongoose; const Schema = mongoose.Schema; const CommentSchema = new Schema(&#123; from: &#123; /* 评论人id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, to: &#123; /* 被评论人id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, content: &#123; type: String &#125;, /* 内容 */ create_time: &#123; type: String &#125;, /* 评论时间 */ book: &#123; /* 书籍id */ type: Schema.Types.ObjectId, ref: 'Book', &#125;, parent_id: &#123; type: String, required: true, default: 0 &#125; /* 父级 */ &#125;); return mongoose.model('Comment', CommentSchema);&#125;; 2、在controller 目录下新建comment.js 用于编写 评论相关的控制器方法，这里我定义了新增评论和查询评论，使用egg-validate进行请求参数验证如下： 123456789101112131415161718192021222324252627282930313233343536373839'use strict';const Controller = require('egg').Controller;// 定义新增评论请求参数规则const createCommentRule = &#123; from: 'string', to: &#123; type: 'string', required: false, &#125;, content: 'string', book: 'string', parentId: &#123; type: 'string', required: false, &#125;,&#125;// 定义查询评论请求参数规则const findCommentRule = &#123; book: 'string', page: 'string', pageSize: 'string'&#125;class CommentController extends Controller &#123; async create() &#123; const &#123; ctx &#125; = this; ctx.validate(createCommentRule, ctx.request.body); const result = await this.ctx.service.comment.createComment(ctx.request.body); ctx.body = result; &#125; async find() &#123; const &#123; ctx &#125; = this; ctx.validate(findCommentRule, ctx.query); const result = await this.ctx.service.comment.findComment(ctx.query); ctx.body = result; &#125;&#125;module.exports = CommentController; 在对应的控制器方法调用service层里面的方法，在service的方法进行数据库操作与逻辑处理。 3、在service目录下新建comment.js用于编写评论相关service方法。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081'use strict';/** * @description: 评论相关Service */const Service = require('egg').Service;const mongoose = require('mongoose');const dayjs = require('dayjs');module.exports = app =&gt; &#123; class CommentService extends Service &#123; /** * 新增评论 * @param &#123;Object&#125; data 包括评论人id，被评论人id，书籍id， 评论父级id，评论内容 */ async createComment(data) &#123; const &#123; from, to, content, book, parentId &#125; = data; const result = await this.ctx.model.Comment.create(&#123; from, to, content, book, parent_id: parentId ? mongoose.Types.ObjectId(parentId) : 0, create_time: dayjs().unix(), &#125;); return result ? app.config.msg.CREARE_SUCCESS : app.config.msg.CREARE_ERR; &#125; /** * 查询评论 * @param &#123;Object&#125; data 包括书籍id，页码，页数 */ async findComment(data) &#123; const &#123; book, page, pageSize &#125; = data const totalNum = await this.ctx.model.Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: 0 &#125;).countDocuments(); const oneList = await this.ctx.model.Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: 0 &#125;) .populate(&#123; path: 'from', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .populate(&#123; path: 'to', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .sort(&#123; create_time: 1&#125;) .skip((parseInt(page) - 1) * parseInt(pageSize)) .limit(parseInt(pageSize)).lean(); const Comment = this.ctx.model.Comment var promises = oneList.map(item =&gt; &#123; return Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: item._id &#125;) .populate(&#123; path: 'from', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .populate(&#123; path: 'to', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .sort(&#123; create_time: 1&#125;) .select('-__v').lean() &#125;); var list = await Promise.all(promises) oneList.forEach(item =&gt; &#123; item.items = [] list.forEach(code =&gt; &#123; if (code.length &gt; 0 &amp;&amp; item._id == code[0].parent_id) &#123; item.items = code &#125; &#125;) &#125;) return oneList ? &#123; bean: &#123; records: oneList, current: page, size: oneList.length, total: totalNum, &#125;, ...app.config.msg.GET_SUCCESS &#125; : app.config.msg.GET_ERR; &#125; &#125; return CommentService;&#125;; 注：首先我们需要查询一级评论的分页数据，然后用map遍历一级评论列表，返回一个promises数组，数组的每一项是查询该一级评论下的所有二级评论，我这里没有进行分页，也可以加上分页。使用Promise.all异步执行所有的查询函数，完成后的结果赋值为list，最后遍历一级评论列表与二级评论列表，当一级评论id 等于 二级评论列表中parent_id时候 给当前一级评论列表增加 items属性用于存放它的二级评论。 最后在router.js中定义接口路径与请求类型，如下： 1234// 新建评论router.post('/api/comment/create', controller.comment.create);// 查询评论router.get('/api/comment/find', controller.comment.find);","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/mongoDB/"}]},{"title":"项目使用axios拦截器封装api","slug":"项目使用axios拦截器封装api","date":"2021-05-21T02:55:08.000Z","updated":"2021-05-21T02:58:16.365Z","comments":true,"path":"2021/05/21/项目使用axios拦截器封装api/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B0%81%E8%A3%85api/","excerpt":"","text":"在api目录下新建一个http.js，实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import Qs from 'qs'import axios from 'axios'import store from '@/store'import * as utils from '@/utils' //工具类import &#123; Toast &#125; from 'mand-mobile'const instance = axios.create(&#123; baseURL: '', // 后端接口根目录 message: true&#125;)// 错误控制const errorHandle = (status, message) =&gt; &#123; switch (status) &#123; case 401: // store.dispatch('logout') break case 403: break case 404: break default: Toast.failed(message) &#125;&#125;// axios请求拦截器/* 拦截器一般做什么？ 1. 修改请求头的一些配置项 2. 给请求的过程添加一些请求的图标 3. 给请求添加参数 */instance .interceptors .request .use(config =&gt; &#123; const token = utils.env !== 'dev' ? store.state.auth.token : '' token &amp;&amp; (config.headers.common.token = token) if (config.method === 'post' &amp;&amp; config.data) &#123; if (Object.prototype.toString.call(config.data) !== '[object FormData]') &#123; config.data = Qs.stringify(config.data) &#125; config.headers.common['Content-Type'] = 'multipart/form-data' &#125; return config &#125;, error =&gt; &#123; return Promise.reject(error) &#125;)// 响应拦截器，接受响应接口后的统一处理instance .interceptors .response .use(response =&gt; &#123; response.success = response.data.success if (response.config.message) &#123; if (!response.success) &#123; response.data.message &amp;&amp; Toast.failed(response.data.message) &#125; else &#123; response.config.method === 'post' &amp;&amp; Toast.succeed(response.data.message || '操作成功') &#125; &#125; return response &#125;, error =&gt; &#123; const &#123; response &#125; = error response ? errorHandle(response.status, response.data.message || '网络连接失败，请稍后重试！') : Toast.info('网络连接失败，请稍后重试！') return Promise.reject(error) &#125;)export const createAPI = (url, method, params, config = &#123;&#125;) =&gt; &#123; if (method === 'get') &#123; config.params = params &#125; else &#123; config.data = params &#125; return instance(&#123; url, method, ...config &#125;)&#125;export default instance 配置接口方式：在api目录下新建个index.jsimport { createAPI } from &#39;./http&#39; 123export default &#123; wxOuth: params =&gt; createAPI('/wechat/getOauthUrl', 'get', params)&#125; 最后在我们的vue组件中引入即可 import * as api from &#39;@/api&#39;调用方式为： api.wxOuth(params).then(res=&gt; {}).catch(err =&gt; {})","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"web端的微信支付可分为JSAPI与H5","slug":"web端的微信支付可分为JSAPI与H5","date":"2021-05-21T02:44:02.000Z","updated":"2021-05-21T02:53:41.403Z","comments":true,"path":"2021/05/21/web端的微信支付可分为JSAPI与H5/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2021/05/21/web%E7%AB%AF%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%AF%E5%88%86%E4%B8%BAJSAPI%E4%B8%8EH5/","excerpt":"","text":"web端的微信支付可分为JSAPI与H5JSAPI使用场景为微信内部，而H5支付则是使用在非微信下的外部浏览器。 1.JSAPI在微信内部可以直接唤起微信浏览器的内置对象WeixinJSBridge废话不多说直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 调用后端接口拿到JSAPI支付所需参数，我在beforeRouteEnter的时候调用。api.apply.jsApiPay(obj).then(res =&gt; &#123; if (res.data.code === '0000') &#123; vm.params = res.data.bean &#125; else &#123; alert('微信支付调起失败！') &#125; &#125;).catch(err =&gt; &#123; alert(err) &#125;)// 点击支付时候调用if (typeof WeixinJSBridge === 'undefined') &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', this.onBridgeReady(this.params), false) &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', this.onBridgeReady(this.params)) document.attachEvent('onWeixinJSBridgeReady', this.onBridgeReady(this.params)) &#125; &#125; else &#123; this.onBridgeReady(this.params) &#125;onBridgeReady (params) &#123; const that = this WeixinJSBridge.invoke( 'getBrandWCPayRequest', &#123; appId: params.appId, // 公众号名称，由商户传入 timeStamp: params.timeStamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: params.nonceStr, // 支付签名随机串，不长于 32 位 package: params.prepay_id, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*） signType: params.signType, // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: params.paySign // 支付签名 &#125;, function (res) &#123; if (res.err_msg === 'get_brand_wcpay_request:ok') &#123; that.queryOrder() // 这里是查询订单是否支付完成，然后执行成功和失败的业务逻辑 &#125; else if (res.err_msg === 'get_brand_wcpay_request:fail') &#123; alert('支付失败！') &#125; &#125; ) &#125;, 在微信支付的回调函数中，当res.err_msg 为get_brand_wcpay_request:ok 时，支付状态不一定准确，因此需要调用后端的查询订单接口，查询是否支付完成，然后再执行相应的逻辑。 2、H5支付h5相对简单，前端只需要跳转到后端返回的链接即可 1234567891011api.apply.h5Pay(&#123; title: '' orderNum: '', expireMinute: 10, redirectUrl: `$&#123;window.location.origin&#125;/pay/card?orderId=$&#123;vm.orderId&#125;` &#125;).then(res =&gt; &#123; vm.h5PayUrl = res.data.bean // 查询订单 &#125;).catch(err =&gt; &#123; alert(err) &#125;) 第一步，请求后端接口，需要传支付的标题，订单号，支付时间，重定向链接。 第二部，们只需要点击支付按钮时候跳转至后端返回链接即可。window.location.href = this.h5PayUrl需要注意的是H5支付查询订单需要用户去手动触发，因此需要增加一个确定订单的弹层。如图：查询订单是否支付成功与JSAPI一致~","categories":[{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"微信体系","slug":"微信体系","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB/"}]},{"title":"基础知识积累","slug":"基础知识积累","date":"2020-10-17T08:54:00.000Z","updated":"2022-05-17T09:03:14.522Z","comments":true,"path":"2020/10/17/基础知识积累/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2020/10/17/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"一、从输入url地址栏到所有内容显示在界面上发生了什么？ 1、浏览器向dns服务器请求解析该URL中的域名所对应的IP地址 2、建立TCP链接（三次握手） 3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器 4、服务器对浏览器请求作出响应，并把对应的html文本发送给浏览器 5、浏览器将该html文本显示内容 6、释放TCP连接（四次挥手） 二、TCP的三次握手和四次挥手123456ack --- 确认号码seq --- 顺序号码ISN --- 初始序列号ACK --- 确认，使得确认号有效（握手使用）SYN --- 用于初始化一个连接的序列号，建立联机(同步序列编号)FIN --- 该报文的发送方已经结束向对方发送数据 三次握手 第一次握手（SYN=1，ACK=0，seq=x） Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等 待Server确认。 第二次握手（SYN=1, ACK=1, seq=y, ack=x+1） Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：(ACK=1，seq=x+1，ack=y+1) Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 TCP四次挥手 第一次挥手(FIN=1，seq=u) Client 想要关闭连接，Client 会发送一个FIN标志位置为1，当前序列号为u的包，表示需要关闭连接了。Client进入 FIN_WAIT_1 状态。 第二次挥手(ACK=1，seq=v，ack=u+1) Server收到Client的FIN包之后，会发送一个确认序号为收到的序列号u+1的包，表明自己接受到了Client关闭连接的请求，但还未准备好关闭连接。Server进入 CLOSE_WAIT 状态，Client进入 FIN_WAIT_2 状态。 第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1) 当Server将剩余数据发送完之后，会发送一个自己的FIN包，序列号为u+1。Server进入 LAST_ACK 状态，等待来自Client的最后一个ACK。 第四次挥手(ACK=1，seq=u+1，ack=w+1) Client接收到来自Server端的关闭请求之后，发送最后一个ACK确认包，确认序号设置为收到序号加1。Client进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。Server接收到这个确认包之后，关闭连接，进入CLOSED状态。(Client会等待2MSL之后，没有收到Server的ACK ，就确认Server进入CLOSED状态，自己也关闭进入CLOSED状态。) 三、for in 与 for of 的区别 for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合，得到的是value值，for of不能对象用 for in遍历对象得到key值，遍历数组得到下标 四、九种跨域方式实现原理严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。 同源策略：所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了 跨域解决方案1.jsonp（优点是简单兼容性好，缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击） 原理：利用&lt;script&gt;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据，JSONP请求一定需要对方的服务器做支持才可以。 实现jsonp函数 123456789101112131415161718192021222324function jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement('script') params = &#123; ...params, callback &#125; let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) window[callback] = data =&gt; &#123; resolve(data) document.body.removeChild(script) &#125; &#125;)&#125;jsonp(&#123; url: 'http://localhost:3000/say', params: &#123; wd: 'ILoveYou' &#125;, callback: 'show'&#125;).then(data =&gt; &#123; console.log(data)&#125;) 服务端实现 123456789let express = require('express')let app = express()app.get('/say', function(req, res) &#123; let &#123; wd, callback &#125; = req.query console.log(wd) // Iloveyou console.log(callback) // show res.end(`$&#123;callback&#125;('我不爱你')`)&#125;)app.listen(3000) Jquery 的jsonp形式 123456789$.ajax(&#123;url:\"http://crossdomain.com/jsonServerResponse\",dataType:\"jsonp\",type:\"get\",//可以省略jsonpCallback:\"show\",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略jsonp:\"callback\",//-&gt;把传递函数名的那个形参callback，可省略success:function (data)&#123;console.log(data);&#125;&#125;); 2.cors CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现 浏览器如果支持会自动进行CORS通信，实现的关键在于后端 服务端设置Access-Control-Allow-Origin就开启了CORS,该属性表示哪些域名可以访问资源，设置通配符表示所有都可以访问。 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求: 条件1：使用下列方法之一：GET/HEAD/POST 条件2：Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 复杂请求: 不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 3.postMessage postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 1otherWindow.postMessage(message, targetOrigin, [transfer]); 123456789101112// a.html &lt;iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt; //等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html &lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125; &lt;/script&gt; 12345// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你', e.origin) &#125; 4.websocket Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 使用Socket.io 12345678910// socket.html&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function () &#123; socket.send('我爱你');//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt; 1234567891011// server.jslet express = require('express');let app = express();let WebSocket = require('ws');//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection',function(ws) &#123; ws.on('message', function (data) &#123; console.log(data); ws.send('我不爱你') &#125;);&#125;) 5.Node中间件代理(两次跨域) 实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 实现一个node服务作为中间件，浏览器访问node 代理服务器，node代理服务器转发请求给目标服务器，目标服务器返回响应给node服务，node服务再转发响应给浏览器 6.nginx反向代理 实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 7.window.name + iframe 通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 8.location.hash + iframe a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 9.document.domain + iframe 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。 五、http和https的区别及优缺点 http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性。 http 协议的默认端口为 80，https 的默认端口为 443。 http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 https 缓存不如 http 高效，会增加数据开销。 Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。 六、Cookie、sessionStorage、localStorage 的区别相同点： 都是客户端缓存 不同点 cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+ cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地 七、浏览器重绘和重排的区别？ 重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。 重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变 『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。 浏览器缓存原理强缓存：Cache-Control优先于Expires, 协商缓存：ETag优先于Last-Modified总结：强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存 八、进程、线程和协程进程: 是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。线程: 是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成协程: 是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。 九、HTML5 新特性、语义化HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构 语义化标签header nav section main article aside footer语义化的优点 在没CSS样式的情况下，页面整体也会呈现很好的结构效果 代码结构清晰，易于阅读 利于开发和维护 有利于搜索引擎优化（SEO） 十、盒子模型 标准盒子模型：width是指content部分的高度 ie盒子模型：width表示 content + padding + border 三个部分组成 十一、BFC（块级格式化上下文）BFC是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。 如何创建bfc 根元素，即HTML元素 float的值不为none position 为absolute或fixed display的值为inline-block、table-cell、table-caption overflow的值不为visible 十二、JS中数据类型及区别 基本数据类型: Number、String、Boolean、 undefined、null、 Symbol, 在内存中占据固定大小，保存在栈内存中 引用数据类型： Object(对象)、Function(函数)，其他还有Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。 十三、JS中的数据类型检测方案 1、typeof能快速区分基本数据类型，不能区分Object、Array、Null，都返回object 2、instanceof能够区分Array、Object和Function，适合用于判断自定义的类实例对象，Number，Boolean，String基本数据类型不能判断 3、Object.prototype.toString.call()精准判断数据类型 十四、var &amp;&amp; let &amp;&amp; const三者的区别 1、var定义变量，没有块的概念，可以跨块访问，但不能跨函数访问。let定义变量，只能在块作用域中访问，不能跨块访问，也不能跨函数访问。const用于定义常量，使用时候必须初始化（必须赋值），只能在块作用域中访问，且不能修改 2、var可以先试用后声明，因为存在变量提升；let必须先声明后使用 3、var是允许在相同作用域内重复声明同一个变量的，而let与const不允许这一现象。 4、在全局上下文中，基于let声明的全局变量和全局对象globel（window）没有任何关系 ; var声明的变量会和globel有映射关系； 5、会产生暂时性死区 6、let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决 十五、JS垃圾回收机制1、项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。浏览器垃圾回收机制/内存回收机制:浏览器的Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 标记清除: 谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。 IE浏览器：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。2、内存泄漏在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器 十六、作用域和作用域链定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成 1、全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。 2、函数作用域：在固定的代码片段才能被访问作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。 十七、闭包的两大作用：保存/保护 闭包是一个可以访问外部作用域中变量的内部函数。 这些被引用的变量直到闭包被销毁时才会被销毁。 闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。 可以通过闭包来达到封装性。 （1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了； 闭包形成的条件： 1、函数的嵌套 2、内部函数引用外部函数的局部变量，延长外部函数的变量生命周期 闭包的用途： 1、模仿块级作用域 保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收) 封装私有化变量 创建模块 闭包的优点：延长局部变量的生命周期闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏 十八、JS 中 this 的五种情况 1、作为普通函数执行时，非严格模式（window）、严格模式（undefined） 2、当函数作为对象的方法被调用时，this就会指向这个对象 3、构造器调用，this指向返回的这个对象 4、箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象。如果有嵌套的情况，则this绑定到最近的一层对象上。 5、基于Function.prototype上的 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。apply接收参数的是数组，call接受参数列表， bind方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this指向除了使用new 时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。 十九、原型 &amp;&amp; 原型链在规范里，prototype 被定义为：给其它对象提供共享属性的对象。 JS是通过函数来模拟类，当我们创建一个函数的时候，js会给这个函数自动添加prototype属性，值是一个包含constructor属性的对象，不是空对象。当我们把函数当成构造函数通过new关键词调用的时候，js会帮我们创建该构造函数的实例，实例继承构造函数prototype的所以属性和方法（实例通过设置自己的proto指向构造函数的prototype来实现继承） 原型链的概念，仅仅是在原型这个概念基础上所作的直接推论。既然 prototype 只是恰好作为另一个对象的隐式引用的普通对象。那么，它也是对象，也符合一个对象的基本特征。 也就是说，prototype 对象也有自己的隐式引用，有自己的 prototype 对象。如此，构成了对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。 二十、new运算符的实现机制1、创建一个新的空对象2、设置新对象的隐式原型（proto）为构造函数的显式原型（prototype）3、使用apply改变构造函数this指向新的对象4、根据函数apply的返回值，判断返回值，如果值是一个对象，则返回这个对象，若不是，则返回这个新创建的对象。 手写实现new 1234567function objectFactory() &#123; const obj = new Object() Constructor = [].shift.call(arguments) obj.__proto__ = Constructor.prototype const result = Constructor.apply(obj, arguments) return typeof result === 'object' ? result : obj&#125; 二一、EventLoop 事件循环js是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以将同步代码压入执行栈中，依次执行，将异步代码推入异步队列中，异步队列分为宏任务和微任务队列。微任务队列优先于宏任务队列，微任务的代表：Promise.then，MutationObserver，宏任务的代表：setImmediate setTimeout setInterval。 浏览器的事件循环事件环的运行机制是：先会执行执行栈中的内容，然后执行当前上下文的微任务队列，微任务队列执行完毕后，再执行宏任务，然后执行其中的同步代码。如此反复，这样就形成一个循环。这个过程被称为事件循环（event loop） 事件循环可以简单的描述为以下四个步骤: 1、函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空； 2、此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列） 3、执行栈为空时，Event Loop把微任务队列执行清空； 4、微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。 node环境的事件环执行顺序如下： timers: 计时器，执行setTimeout和setInterval的回调 pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调 idle, prepare: 队列的移动，仅系统内部使用 poll轮询: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。 check: 执行setImmediate回调，setImmediate在这里执行 close callbacks: 执行close事件的callback，一些关闭的回调函数，如：socket.on(‘close’, …) 二二、setTimeout、Promise、Async/Await 的区别 setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行 Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行。 async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。 二三、介绍节流防抖原理、区别以及应用节流： 事件触发后，在一段时间内只会触发一次,包括时间戳版和定时器版 1234567891011//时间戳版function throttle(fn, wait) &#123; let prev = 0 return function() &#123; let now = new Date() if (now - prev &gt; wait) &#123; fn.apply(this, arguments) prev = now &#125; &#125;&#125; 123456789101112//定时器版function throttle(fn, wait) &#123; let timer = null return function() &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timer = null &#125;, wait) &#125; &#125;&#125; 防抖：事件触发后，在一段时间后才会执行函数，如果在这段时间内再次触发，会重新计算函数的执行时间，分为非立即执行和立即执行两个版本 12345678910111213141516171819202122232425// 非立即执行版function debounce(fn, wait) &#123; let timer = null return function() &#123; timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, wait) &#125;&#125;// 立即执行版function debounce(fn, wait) &#123; let timer = null return function() &#123; const now = !timer timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; timer = null &#125;, wait) if (now) &#123; fn.apply(this, arguments) &#125; &#125;&#125; 使用场景： 节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交…… 索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]},{"title":"前端日常开发常用技巧与方法","slug":"前端日常开发常用技巧与方法","date":"2020-06-09T10:10:36.000Z","updated":"2022-05-17T07:37:36.584Z","comments":true,"path":"2020/06/09/前端日常开发常用技巧与方法/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2020/06/09/%E5%89%8D%E7%AB%AF%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/","excerpt":"","text":"CSS部分盒子边倾斜clip-path: polygon(12% 0, 100% 0, 100% 100%, 0 100%); 禁止点击事件/鼠标事件“穿透”123div * &#123; pointer-events: none; /*链接啊，点击事件啊，都没有效果了*/ &#125; 用来控制元素在移动设备上使用滚动回弹效果123.main&#123; -webkit-overflow-scrolling: touch;&#125; 可解决在IOS中使用overflow:auto 形成的滚动条，滚动不流畅的情况 文字渐变效果12345.text-gradient&#123; background-image: linear-gradient(135deg, deeppink, deepskyblue); -webkit-background-clip: text; color: transparent;&#125; css三角形12345678910111213#triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red;&#125; JS部分JavaScript中检测数组的方法(1)、typeof操作符 这种方法对一些常用的类型检查没有问题，但对array和null 都判断为object(2)、instanceof操作符 这个操作符是检测对象的原型链是否指向构造函数的prototype对象的(3)、对象的constructor属性 123const arr = []console.log(arr.constructor === Array) // true (4)、Object.prototype.toString 123const arr = []console.log(Object.prototype.toString.call(arr) === '[object Array]') // true (5)、Array.isArray() 常用的字符串操作 字符串转化toString() 字符串分隔split() 字符串替换replace() 获取长度length 查询子字符串 indexOf 返回指定位置的字符串或字符串编码 charAt charCodeAt 字符串匹配 match 字符串拼接concat 字符串的切割或提取slice() substring() substr() 字符串大小写转化 toLowerCase toUpperCase 字符串去空格 trim() 用来删除字符串前后的空格 其中第9中三者的区别如下：（1）slice(), 参数可以是负数，负数表示从字符串最后一个位置开始切割到对应结束位置（2）substring()，参数不可为负数，切割第一个位置到第二个位置的字符串（3）substr()， 参数不可为负数，第一个参数是开始位置，第二个参数为切割的长度字符串去重const str = ‘11122223333’const arr = str.split(‘’)const uniqueStr = […new Set(arr)].join(‘’) 常用的数组操作1、Array.map()此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组2、Array.forEach()此方法是将数组中的每个元素执行传进提供的函数，没有返回值，注意和map方法区分3、Array.filter()此方法是将满足条件的元素作为一个新数组返回4、Array.every()此方法将数组所有元素进行判断返回一个布尔值，如果所有元素都符合判断条件，则返回true，否则返回false5、Array.some()此方法将数组所有元素进行判断返回一个布尔值,如果有一个元素满足判断条件，则返回true，所有元素都不满足则返回false6、Array.reduce()此方法为所有元素调用返回函数7、Array.push()在数组最后面添加新元素8、Array.shift()删除数组第一个元素9、Array.pop()删除数组最后一个元素10、Array.unshift()在数组最前面增加元素11、Array.isArray()判断是否为一个数组12、Array.concat()数组拼接13、Array.toString()数组转化为字符串14、Array.join()数组转化为字符串，并用第一个参数作为连接符15、Array.splice(开始位置，删除个数，元素)####常用对象方法1、Object.assign()用于克隆，两个参数，将第二个对象分配到第一个中2、Object.is()用于判断两个值是否相同//注意，该函数与==运算符不同，不会强制转换任何类型， 应该更加类似于===，但值得注意的是它会将+0和-0视作不同值3、Object.keys()用于返回对象可枚举的属性和方法的名称，返回一个属性或方法名称的字符串数组。4、Object.defineProperty()劫持变量的set和get方法,将属性添加到对象，或修改现有属性的特性 12345var a = &#123;&#125;;Object.defineProperty(a, 'name', &#123; value : 'kong', enumerable : true //该属性是否可枚举&#125;) 5、Object.defineProperties()可添加多个属性,与Object.defineProperty()对应,6、isPrototypeOf 123function a()&#123;&#125; var b = new a();console.log(a.prototype.isPrototypeOf(b));//true 安卓监听可视区域变化，让输入框移动至可视区域123456789if (/Android/gi.test(navigator.userAgent)) &#123; window.addEventListener('resize', function () &#123; if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') &#123; window.setTimeout(function () &#123; document.activeElement.scrollIntoViewIfNeeded(); &#125;, 0); &#125; &#125;); &#125;; vue中平滑滚动到某个位置this.$refs.rule.scrollIntoView({ block: ‘start’, behavior: ‘smooth’ }) 好用的JavaSrcipt库与模块（包）日期时间处理库1、monent.js2、day.jsday相对于monent要轻量许多 高精度数学运算number-precision 123456NP.strip(num) // strip a number to nearest right numberNP.plus(num1, num2, num3, ...) // addition, num + num2 + num3, two numbers is required at least.NP.minus(num1, num2, num3, ...) // subtraction, num1 - num2 - num3NP.times(num1, num2, num3, ...) // multiplication, num1 * num2 * num3NP.divide(num1, num2, num3, ...) // division, num1 / num2 / num3NP.round(num, ratio) // round a number based on ratio 实用工具库Lodashlodash 是一个 JavaScript 实用工具库，提供一致性，及模块化、性能和配件等功能。Lodash 消除了处理数组的麻烦，从而简化了 JavaScript、 数字、对象、字符串等","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"css","slug":"css","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/css/"}]},{"title":"JS的数据类型及深浅拷贝介绍","slug":"JS的数据类型及深浅拷贝介绍","date":"2020-06-09T10:06:22.000Z","updated":"2021-05-20T09:25:44.542Z","comments":true,"path":"2020/06/09/JS的数据类型及深浅拷贝介绍/","link":"","permalink":"https://yolindeng.github.io/my-hexo-blog/2020/06/09/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1、数据类型JS分为两种数据类型：基本数组类型： Number、String、Boolean、Null、Undefined、Symbol引用数组类型：Object(JS中除了基本数据类型，其他都是对象。例如数组、函数、正则表达式等) （1）基本数据类型（存放在栈中）基本数据类型是指直接存放在栈中的简单数据段，数据大小确定，内存k空间可分配，按值存放和访问注：栈(stack)和堆（heap）stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放 （2）引用数据类型（存放在堆内存中的对象）引用数据类型是存放在堆内存里的对象，而指向堆内存值的引用也就是指针是存在栈内存中的。 2、浅拷贝当我们使用对象拷贝时，如果属性是对象或者数组时，我们只是拷贝的数组或对象的引用地址，因此两者的属性值会指向同一个内存空间。实现数组的片浅拷贝使用concat、slice这个两个是技巧类，如何实现一个浅拷贝呢？简单的思路是遍历对象，把属性和属性值都放在一个新的对象中如下： 12345678910111213var shallowCopy = function(obj) &#123; // 只拷贝对象 if (typeof obj !== 'object') return; // 根据obj的类型判断是新建一个数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125;; // 遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125; &#125; return newObj;&#125; 12345let a = &#123; name: '123', obj: &#123; name: '456' &#125;&#125;const b = shallowCopy(a)b.obj.name = '666'console.log(b) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125;console.log(a) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125; 这样如果改变b中的对象，a中的对象也会同时改变。 3、深拷贝实现数组或对象的深拷贝，可以使用JSON.parse(JSON.stringify(obj))如何手写一个深度拷贝呢？思路是通过递归调用拷贝函数 12345678910var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return var newObj = obj instanceof Array ? [] : &#123;&#125; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key] &#125; &#125; return newObj&#125; 12345let a = &#123; name: '123', obj: &#123; name: '456' &#125;&#125;const b = deepCopy(a)b.obj.name = '666'console.log(b) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125;console.log(a) // &#123; name: '123', obj: &#123; name: '456' &#125; &#125; 这样就实现了深度拷贝，当改变b中对象值时，a没有发生变化。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"}]}],"categories":[{"name":"前端基础","slug":"前端基础","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"日常开发","slug":"日常开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"},{"name":"性能优化","slug":"性能优化","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"框架原理","slug":"框架原理","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"后端开发","slug":"后端开发","permalink":"https://yolindeng.github.io/my-hexo-blog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vue/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"性能优化","slug":"性能优化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"vuex","slug":"vuex","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/vuex/"},{"name":"pinia","slug":"pinia","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/pinia/"},{"name":"工程化","slug":"工程化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"低代码","slug":"低代码","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"页面加载优化","slug":"页面加载优化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/"},{"name":"基础知识","slug":"基础知识","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"HTTP","slug":"HTTP","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/HTTP/"},{"name":"webpack","slug":"webpack","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/webpack/"},{"name":"Promise","slug":"Promise","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/Promise/"},{"name":"模块化","slug":"模块化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"typeScript","slug":"typeScript","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/typeScript/"},{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"},{"name":"css","slug":"css","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/css/"},{"name":"react","slug":"react","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/react/"},{"name":"scss","slug":"scss","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/scss/"},{"name":"组件化","slug":"组件化","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"git","slug":"git","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/git/"},{"name":"node.js","slug":"node-js","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/mongoDB/"},{"name":"微信体系","slug":"微信体系","permalink":"https://yolindeng.github.io/my-hexo-blog/tags/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB/"}]}