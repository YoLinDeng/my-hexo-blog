{"meta":{"title":"YoLinDeng's blog","subtitle":"","description":"YoLinDeng blog","author":"YoLin Deng","url":"http://yolindeng.gitee.io/myblog","root":"/myblog/"},"pages":[{"title":"About me","date":"2020-05-27T07:46:53.000Z","updated":"2020-12-15T01:45:28.823Z","comments":false,"path":"about/me.html","permalink":"http://yolindeng.gitee.io/myblog/about/me.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-09T10:45:44.000Z","updated":"2021-05-21T02:31:57.598Z","comments":false,"path":"about/index.html","permalink":"http://yolindeng.gitee.io/myblog/about/index.html","excerpt":"","text":"关于我 博主本名邓咏凌，来自美丽客都、世界长寿之乡梅州蕉岭。2019年毕业于广东药科大学，信息管理与信息系统专业。在成为一名出色的前端开发者的道路上不断努力，让自己变成越来越优秀。平时喜欢打篮球、短跑、唱歌、听歌，想要踏足祖国的大好河山，领略不同地域的风土人情。等到秋叶终于金黄，华发悄然苍苍，愿我们相约老地方～ 在校经历 大学四年时光是如此的短暂且美好，脑海中的点点滴滴都已成回忆，在心间不停流转。 社团生活丰富多彩，大一加入学生会组织部作为干事、校田径队短跑队员，大二成为组织部部长、加入院篮球队，大三作为学生副书记。 获得二等奖学金，及运动类、社团类奖学金。三年参加了3次校运会，分别斩获2次第三，一次第一的成绩，最好成绩11.53。 大学期间最喜欢的运动莫过于篮球，成为我大学不可或缺的伙伴。 做过家教、手机店销售等兼职 工作经历 广东万丈金数信息技术股份有限公司（2019.5 - 至今）前端开发工程师（初级、中级） 移动端活动营销页面、微信公众号页面、微信及支付宝小程序开发 活动组件平台的node后端开发（基于egg.js和mongoDB） 公司内部后台管理系统开发 百家保系列产品开发… 深圳云之家网络有限公司(金蝶云之家)（2018.12 - 2019.3）web前端开发实习生 生态圈产品移动端及管理系统功能迭代开发 配合产品、UI、UE、后端、测试，完成页面功能交互，并上线。 中山蕉神科技（2018.7 - 2018.11）H5前端开发工程师实习生 负责活动页面开发 公众号体系开发"}],"posts":[{"title":"commonJs与ESModule的区别","slug":"commonJs与ESModule的区别","date":"2021-11-02T07:48:01.000Z","updated":"2021-11-02T09:33:50.283Z","comments":true,"path":"2021/11/02/commonJs与ESModule的区别/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/11/02/commonJs%E4%B8%8EESModule%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"开篇学习之前引出几个问题： Commonjs 和 Es Module 有什么区别 ？ Commonjs 如何解决的循环引用问题 ？ Es Module 如何解决循环引用问题 ？ exports 和 module.exports 有何不同？ require 模块查找机制 ？ import() 的动态引入？ Es Module 如何改变模块下的私有变量 ？ 模块化开发很容易存在全局污染和依赖管理混乱问题，所以就需要模块化来解决这两个问题，今天介绍的是前端模块化的两个重要方案，commonjs 和 ESModule Commonjscommonjs的提出弥补了，前端模块化的空缺，nodejs借鉴了commonjs，实现了模块化管理。 目前commonjs广泛应用于以下几个场景： Node（commonjs在服务端的一个具体代表性实现） Browserify（ commonjs 在浏览器中的一种实现） wepack 打包工具对 CommonJS 的支持和转换 特点 在commonjs中每个js文件就是一个单独的模块，称为module。 模块中包含commonjs的核心变量：exports、module.exports、require exports 和 module.export可以用于导出模块中的内容 require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容 实现原理每个模块文件上存在 module，exports，require三个变量，然而这三个变量是没有被定义的，但是我们可以在 Commonjs 规范下每一个 js 模块上直接使用它们 module 记录当前模块信息。 require 引入模块的方法。 exports 当前模块导出的属性 在编译的过程中，实际 Commonjs 对 js 的代码块进行了首尾包装 123456789(function(exports,require,module,__filename,__dirname)&#123; const sayName = require('./hello.js') module.exports = function say()&#123; return &#123; name:sayName(), author:'YoLin' &#125; &#125;&#125;) 在 Commonjs 规范下模块中，会形成一个包装函数，我们写的代码将作为包装函数的执行上下文，使用的 require ，exports ，module 本质上是通过形参的方式传递到包装函数中的。 12345function wrapper (script) &#123; return '(function (exports, require, module, __filename, __dirname) &#123;' + script + '\\n&#125;)'&#125; 包装函数执行 123456789const modulefunction = wrapper(` const sayName = require('./hello.js') module.exports = function say()&#123; return &#123; name:sayName(), author:'YoLin' &#125; &#125;`) 1runInThisContext(modulefunction)(module.exports, require, module, __filename, __dirname) 在模块加载的时候，会通过 runInThisContext (可以理解成 eval ) 执行 modulefunction ，传入require ，exports ，module 等参数。最终我们写的 nodejs 文件就这么执行了。 require 文件加载流程1231、const fs = require('fs') // 核心模块2、const sayName = require('./sayName.js') // 文件模块3、const crypto = require('crypto-js') // 第三方模块 如上所示：require可以加载核心模块、文件模块、第三方自定义模块。当 require 方法执行的时候，接收的唯一参数作为一个标识符 ，Commonjs 下对不同的标识符，处理流程不同，但是目的相同，都是找到对应的模块。 require 加载标识符原则nodejs中对标识符的处理原则 对fs、http、path等标识符，会被作为核心模块 ./和../作为相对路径的文件模块，/作为绝对路径的文件模块 非路径形式也非核心模块的模块，将作为自定义模块 核心模块的处理：核心模块的优先级仅次于缓存加载，在 Node 源码编译中，已被编译成二进制代码，所以加载核心模块，加载过程中速度最快。 路径形式的文件模块处理：已 ./ ，../ 和 / 开始的标识符，会被当作文件模块处理。require() 方法会将路径转换成真实路径，并以真实路径作为索引，将编译后的结果缓存起来，第二次加载的时候会更快。 自定义模块处理：自定义模块，一般指的是非核心的模块，它可能是一个文件或者一个包，它的查找会遵循以下原则： 在当前目录下的 node_modules 目录查找。 如果没有，在父级目录的 node_modules 查找，如果没有在父级目录的父级目录的 node_modules 中查找 沿着路径向上递归，直到根目录下的 node_modules 目录。 在查找过程中，会找 package.json 下 main 属性指向的文件，如果没有 package.json ，在 node 环境下会以此查找 index.js ，index.json ，index.node。 require 模块引入与处理CommonJS 模块同步加载并执行模块文件，CommonJS 模块在执行阶段分析模块依赖，采用深度优先遍历（depth-first traversal），执行顺序是父 -&gt; 子 -&gt; 父； require 加载原理过程： require 会接收一个参数——文件标识符，然后分析定位文件，分析过程我们上述已经讲到了，加下来会从 Module 上查找有没有缓存，如果有缓存，那么直接返回缓存的内容。 如果没有缓存，会创建一个 module 对象，缓存到 Module 上，然后执行文件，加载完文件，将 loaded 属性设置为 true ，然后返回 module.exports 对象。借此完成模块加载流程。 模块导出就是 return 这个变量的其实跟 a = b 赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址。 exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对 exports 进行赋值会导致 exports 操作的不再是 module.exports 的引用。 require 避免重复加载加载之后的文件的 module 会被缓存到 Module 上，如果其他模块再次引入，则会直接读取缓存中的，无需再次执行模块 require 避免循环引用","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"typescript知识点","slug":"typescript知识点","date":"2021-11-02T07:45:11.000Z","updated":"2021-11-02T07:46:22.982Z","comments":true,"path":"2021/11/02/typescript知识点/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/11/02/typescript%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"TypeScript基础学习基础类型12345678910111213let isDone: boolean = truelet age: number = 20let binaryNumber: number = 0b1111 // 支持二进制或八进制let fistName: string = 'YoLinDeng'let u: undefined = undefinedlet n: null = nulllet num: number = undefined // 说明undefined和null类型是所以类型的子类型 null和undefined的区别null表示“没有对象”，即该处不该有值 1）作为函数的参数，表示该函数的参数不是对象 2）作为对象原型链的终点 undefined表示缺少值，就是此处应该有值，但是还没有定义 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 any类型和联合类型1234let notSure: any = 1// 有明确类型的时候避免使用any类型，没有代码提示以及校验let numberOrString: number | string = 123numberOrString = 'abc' Array 和 Tuple（元组）123456// 定义数组let arrOfNumbers: number[] = [1, 2, 3]let arr2: Array&lt;number&gt; = [1, 2, 3]// 定义元组,限定了一定数据类型的数组let user: [string, number] = ['YoLinDeng', 20] interface(接口) 对对象的形状进行描述 对类进行抽象 Duck Typing(鸭子类型) 12345678910interface Person &#123; readonly id: number; // 只读 name: string; age?: number; // 可选&#125;let yoLin: Person &#123; id: 1, name: 'YoLinDeng'&#125; 函数和类型推断1234567891011121314151617181920function add(x: number, y: number, z?: number): number &#123; if (typeof z === 'number') &#123; return x + y + z &#125; else &#123; return x + y &#125;&#125;let result = add(1, 2, 3)// 函数表达式const add = function(x: number, y: number, z?: number): number &#123; if (typeof z === 'number') &#123; return x + y + z &#125; else &#123; return x + y &#125;&#125;const add2 = (x: number, y: number, z?: number) =&gt; number = add当我们没有指定类型的时候，ts的complier会给我推断出一个类型 类Class类(Class)：定义了一切事物的抽象特点对象（Object）:类的实例面向对象（OOP）:三大特征：封装，继承，多态 1234567891011121314151617181920212223242526272829303132333435class Animal &#123; name: string; constructor(name: string) &#123; this.name = name &#125; run() &#123; return `$&#123;this.name&#125; is running` &#125;&#125;const snake = new Animal('liLy')console.log(snake.run())class Dog extends Animal &#123; bark() &#123; return `$&#123;this.name&#125; is barking` &#125;&#125;const xiaobao = new Dog('xiaobao')console.log(xiaobao.run())console.log(xiaobao.bark())class Cat extends Animal &#123; constructor(name) &#123; super(name) console.log(this.name) &#125; run() &#123; return `Meow,$&#123;super.run()&#125;` &#125;&#125;const maomao = new Cat('maomao')console.log(maomao.run()) 修饰符：public（公有的）、private（私有的）、protected(只有自己和子类可以访问)、readonly（只读）、static（静态，不需要实例化，可以在类上直接调用） 类和接口：使用interface和implements抽象和验证类的属性和方法，对类的一部分内容进行抽象。将特性提取成接口，使用implements来实现,像一种契约，定义和约束object的样子。 123456789101112131415161718192021222324interface Radio &#123; switchRadio(): void;&#125;interface Battery &#123; checkBatteryStatus(): void;&#125;interface RadioWithBattery extends Radio &#123; checkBatteryStatus(): void;&#125;class Car implements RadioWithBattery &#123; switchRadio() &#123; &#125; checkBatteryStatus() &#123;&#125;&#125;class CellPhone implements RadioWithBattery &#123; switchRadio() &#123; &#125; checkBatteryStatus() &#123; &#125;&#125; Enum枚举12345678910111213141516// 常量枚举, 提升性能，不会编译成js代码，只有常量值才可以进行常量枚举，计算值不行。const enum Direction1 &#123; left, right, top, bottom&#125;enum Direction2 &#123; left = 'LEFT', right = 'RIGHT', top = 'TOP', bottom = 'BOTTOM'&#125;console.log(Direction1.left)console.log(Direction1[0])console.log(Direction2.left === 'LEFT') 泛型在定义函数接口或类的时候，先不指定具体类型，在使用的时候才指定。 1234567891011function echo&lt;T&gt;(arg: T): T &#123; return arg&#125;const result1: number = echo(123)const result2: string = echo('string')function swap&lt;T, U&gt;(tuple: [T, U]): [T, U] &#123; return [tuple[0], tuple[1]]&#125;const result3 = swap(['string', 123]) 约束泛型使用extends继承接口进行约束 1234567891011interface IWithLength &#123; length: number&#125;function echoWithLength&lt;T extends IWithLength&gt;(arg: T): T &#123; console.log(arg.length) return arg&#125;const str = echoWithLength('str')const obj = echoWithLength(&#123; length: 10 &#125;)const arr = echoWithLength([1, 2, 3]) 泛型在类中的使用 123456789101112class Queue&lt;T&gt; &#123; private data = [] push(item: T) &#123; return this.data.push(item) &#125; pop(): T &#123; return this.data.shift() &#125;&#125;const queue = new Queue&lt;number&gt;()queue.push(1)console.log(queue.pop().toFixed()) 接口interface中使用泛型 123456interface KeyPair&lt;T, U&gt; &#123; key: T; value: U;&#125;let kp1: KeyPair&lt;number, string&gt; = &#123; key: 123, value: '123'&#125;let kp2: KeyPair&lt;string, number&gt; = &#123; key: 'str', value: 123&#125; 使用泛型定义数组 1let arr: Array&lt;number&gt; = [1,2,3] interface描述函数 1234567891011interface IPlus&lt;T&gt; &#123; (a: T, b: T): number&#125;function plus(a: number, b: number): number &#123; return a + b;&#125;function connect(a: string, b: string): string &#123; return a + b&#125;const a: IPlus&lt;number&gt; = plusconst b: IPlus&lt;string&gt; = connect 类型别名和类型断言type aliases 12345678910111213141516type PlusType = (x: number, y: number) =&gt; numberfunction sum(x: number, y: number): number &#123; return x + y&#125;const sum2: PlusType = sum// 联合类型中使用类型别名type NameResolver = () =&gt; stringtype NameOrResolver = string | NameResolverfunction getName(n: NameOrResolver): string &#123; if (typeof n === 'string') &#123; return n &#125; else &#123; return n() &#125;&#125; type assertion 断言 12345function getLength(input: number | string): number &#123; const str = input as String // or &lt;string&gt;input&#125; 声明文件创建.d.ts文件，例如jQuery.d.ts 1declare var Jquery: (selector: string) =&gt; any 再tsconfig.json中写配置 123&#123; \"include\": [\"**/*\"] //编译当前文件夹下的所有文件&#125;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://yolindeng.gitee.io/myblog/tags/typeScript/"}]},{"title":"div局中","slug":"div局中","date":"2021-06-23T03:27:03.000Z","updated":"2021-06-23T03:27:17.572Z","comments":true,"path":"2021/06/23/div局中/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/06/23/div%E5%B1%80%E4%B8%AD/","excerpt":"","text":"div居中的几种方法使div水平垂直居中1、flex布局实现（已知元素宽度）给父盒子设置：display: flex;justify-content: center;align-items: center; 2、position（已知元素宽度）父元素设置为：position: relative;子元素设置为：position: absolute;距上50%，据左50%，然后减去元素自身宽度的一半距离就可以实现 3、position + transform （未知宽度）父元素设置为：position: relative;子元素设置为：position: absolute;距上50%，据左50%，然后使用transform: translate(-50%,-50%); 4、position（元素已知宽度）父元素设置为：position: relative;子元素设置为：position: absolute;left、right、bottom、top都为0，margin: auto; 如果子元素不设置宽度和高度，将会铺满整个父级(模态框) 5. table-cell 布局实现table 实现垂直居中，子集元素可以是块元素，也可以不是块元素 使内容（文字，图片）水平垂直居中（table-cell 布局）行元素 text-align ：center； 块元素 ：margin ：0 auto；text-align : center 给元素的父级加，可以使文本或者行级元素(例如：图片)水平居中line-height : 值为元素的高度，可以使元素的文本内容垂直居中margin: 0 auto 使用条件：父级元素宽度可有可无，子级元素必须使块元素，而且要有宽度（否则继承父级） display：table-cell 会使元素表现的类似一个表格中的单元格td，利用这个特性可以实现文字的垂直居中效果。同时它也会破坏一些 CSS 属性，使用 table-cell 时最好不要与 float 以及 position: absolute 一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对margin值无反应，可以响 padding 的设置，表现几乎类似一个 td 元素。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yolindeng.gitee.io/myblog/tags/css/"}]},{"title":"css性能优化","slug":"css性能优化","date":"2021-06-23T03:26:12.000Z","updated":"2021-06-23T03:26:42.175Z","comments":true,"path":"2021/06/23/css性能优化/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/06/23/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"合并css文件，如果页面加载10个css文件,每个文件1k，那么也要比只加载一个100k的css文件慢。 减少css嵌套，最好不要嵌套三层以上。 不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。 建立公共样式类，把相同样式提取出来作为公共类使用。 减少通配符*或者类似[hidden=”true”]这类选择器的使用，挨个查找所有…这性能能好吗？ 巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。 拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。 不用css表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。 少用css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。 cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。 善后工作，css压缩(在线压缩工具 YUI Compressor) GZIP压缩，是一种流行的文件压缩算法 性能优化避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。避免过分重排浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow 导致reflow发生的情况 改变窗口的大小 改变文字的大小 添加 删除样式表 内容的改变 输入框输入内容也会 伪类的激活 操作class属性 脚本操作dom js改变css类 计算offsetWidth和offsetHeight 设置style属性 改变元素的内外边距 常见重排元素 大小有关的 width,height,padding,margin,border-width,border,min-height 布局有关的 display,top,position,float,left,right,bottom 字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align 隐藏有关的 overflow,overflow-x,overflow-yrepaint 重绘 当一个元素的外观被改变，但是布局没有改变的情况当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素常见的重绘元素 颜色 color,background 边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width 背景有关 background,backgound-image,background-position,background-repeat,background-size 文件压缩性能优化时最容易想到的，也是最常见的方法，就是文件压缩，这一方案往往效果显著文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具webpack，gulp/grunt，rollup，压缩之后能够明显减少，可以大大降低浏览器的加载时间。 去除无用CSS 不同元素或者其他情况下的重复代码， 整个页面内没有生效的CSS代码 有选择地使用选择器 保持简单，不要使用嵌套过多过于复杂的选择器 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。 不要使用类选择器和ID选择器修饰元素标签，如：h3#markdown-content，这一多此一举，还会降低效率 不要为了追求速度而放弃可读性和可维护性 减少使用昂贵的属性硬件加速的好坏","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yolindeng.gitee.io/myblog/tags/css/"}]},{"title":"圣杯布局和双飞翼布局","slug":"圣杯布局和双飞翼布局","date":"2021-06-23T03:25:28.000Z","updated":"2021-06-23T03:25:52.202Z","comments":true,"path":"2021/06/23/圣杯布局和双飞翼布局/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/06/23/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"通俗的来说就是左右两栏固定宽度，中间部分自适应的三栏布局。 两者本质圣杯布局 首先把left、middle、right都放出来 给它们三个设置上float: left, 脱离文档流； 一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档 left、right设置上各自的宽度middle设置width: 100%; 接下来比较重要了： 给left、middle、right设置position: relative; left设置 left: -leftWidth, right设置 right: -rightWidth; container设置padding: 0, rightWidth, 0, leftWidth; 因为不这样设置 会遮挡middle的内容 双飞翼布局双飞翼布局和圣杯布局很类似，不过是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。 首先把left、middle、right都放出来, middle中增加inner 给它们三个设置上float: left, 脱离文档流； 一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档 left、right设置上各自的宽度 middle设置width: 100%;接下来与圣杯布局不一样的地方： left设置 margin-left: -100%, right设置 right: -rightWidth; container设置padding: 0, rightWidth, 0, leftWidth;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yolindeng.gitee.io/myblog/tags/css/"}]},{"title":"js时间循环机制","slug":"js时间循环机制","date":"2021-06-23T03:24:10.000Z","updated":"2021-06-23T03:24:40.675Z","comments":true,"path":"2021/06/23/js时间循环机制/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/06/23/js%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"浏览器环境下js引擎的事件循环机制1.执行栈与事件队列基本类型以及对象的指针存放在栈中，对象的值存放在堆内存中。执行栈：js引擎在解析一段代码的时候，将其中的同步代码按照执行顺序加入到执行栈中，然后从头开始执行。当执行完毕后，当前函数的执行上下文会从栈顶弹层出，随之函数及其执行上下文会被销毁，其中的变量会被浏览器回收。事件队列：js引擎遇到异步事件后并不会一直等待其返回结果，而会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列中，被放入的事件不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于空闲时，主线程会取查找事件队列是否又任务，如果有，那么主线程会取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码。如此反复，这样就形成一个无限循环。这个过程被称为事件循环（event loop） 2.macro task与micro task不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。 以下事件属于宏任务： setInterval() setTimeout() 以下事件属于微任务: new Promise() new MutaionObserver() 当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 node环境下的事件循环机制node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。 事件循环各阶段详解node中的事件循环的顺序：外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段… timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。 I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。 idle, prepare: 这个阶段仅在内部使用，可以不必理会。 poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。 check: setImmediate()的回调会在这个阶段执行。 close callbacks: 例如socket.on(‘close’, …)这种close事件的回调。 poll先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。 有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。 check阶段check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。 close阶段当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。 timer阶段这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。 I/O callback阶段这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。 process.nextTick,setTimeout与setImmediate的区别与使用场景在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate process.nextTick()node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。 setTimeout()和setImmediate()setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。 setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"v8垃圾回收机制","slug":"v8垃圾回收机制","date":"2021-06-23T03:11:21.000Z","updated":"2021-06-23T03:11:41.425Z","comments":true,"path":"2021/06/23/v8垃圾回收机制/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/06/23/v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"1、为何需要垃圾回收在v8引擎执行js代码的过程中，当遇到函数的情况时，会为其创建一个函数执行的上下文，并添加到调用堆栈的栈顶，函数的作用域中包含了该函数中声明的所以变量，当函数执行完毕后，对面的执行上下文会从栈顶弹出，函数的作用域随之销毁，其包括的所以变量也会统一释放并自动回收。如果不回收，必然导致内存暴增，引发内存泄漏。 2、v8引擎的内存限制由于js的单线程机制和垃圾回收机制，V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个G内存这样的场景 3、v8的垃圾回收策略V8的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。 v8的内存结构主要了解新生代和老生代 新生代(new_space)：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。（Scavenge算法） 老生代(old_space)：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。Mark-Sweep(标记清除)和Mark-Compact(标记整理) 4、如何避免内存泄漏 尽可能少地创建全局变量 手动清除定时器 少用闭包 清除DOM引用 弱引用在ES6中为我们新增了两个有效的数据结构WeakMap和WeakSet，就是为了解决内存泄漏的问题而诞生的。其表示弱引用","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"this、call、apply、bind","slug":"this、call、apply、bind","date":"2021-06-17T10:05:48.000Z","updated":"2021-06-17T10:06:07.883Z","comments":true,"path":"2021/06/17/this、call、apply、bind/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/06/17/this%E3%80%81call%E3%80%81apply%E3%80%81bind/","excerpt":"","text":"this在JavaScript中，this的指向是调用时决定的，而不是创建时决定的，this永远指向最后调用它的那个对象。 全局上下文在全局上下文中，this指全局对象 this等价于window对象 var === this. === window.在浏览器里面this等价于window对象，如果你声明一些全局变量，这些变量都会作为this的属性。 函数上下文在函数内部，this的值取决于函数被调用的方式 直接调用this指向window，严格模式下是undefined 作为对象的一个方法当this所在的函数被以obj.fn()形式调用时，指向obj call()、apply，(不同点：前者传的是若干个参数列表，后者是包含多个参数的数组)this指向绑定的对象 123456789let Person = &#123; name: 'YoLin', age: 25&#125;function say(job) &#123; console.log(`我是$&#123;this.name&#125;，今天&#123;this.age&#125;,职业是$&#123;job&#125;`)&#125;say.call(Person, \"FE\")say.apply(Person, [\"FE\"]) bind()this将永久地被绑定到了bind的第一个参数。与call、apply相似，接受若干个参数列表并返回一个新的函数，不同的是需要我们手动调用。 箭头函数所有的箭头函数都没有自己的this，都指向外层。箭头函数会捕获其所在上下文的this值，作为自己的this值。箭头函数的 this 始终指向函数定义时的 this，而非执行时箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。 作为一个构造函数（new实例化一个对象）this被绑定到正在构造的新对象。通过构造函数创建一个对象其实执行这样几个步骤：1、创建新对象2、将this指向这个对象3、给对象赋值（属性、方法）4、返回this new的过程12345678var a = new myFunction(\"Li\",\"Cherry\");new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,\"Li\",\"Cherry\"); return typeof result === 'obj'? result : obj;&#125; 1、创建一个空对象 obj;2、将新创建的空对象的隐式原型指向其构造函数的显示原型。3、使用 call 改变 this 的指向4、如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 总结如果要判断一个函数的this绑定，就需要找到这个函数的直接调用位置。然后可以顺序按照下面四条规则来判断this的绑定对象： 由new调用：绑定到新创建的对象 由call或apply、bind调用：绑定到指定的对象 由上下文对象调用：绑定到上下文对象 默认：全局对象注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定this，继承外层函数调用的this绑定。 call手写call的思路： 1、将函数设置为对象的一个属性 2、执行该函数 3、删除该函数通过Arguments 对象中取值，然后放入一个数组里1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = &#123;// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// &#125;// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']');&#125;// 执行后 args为 [foo, 'kevin', 18] 把这个参数数组放到要执行的函数的参数里面去 eval() 函数会将传入的字符串当做 JavaScript 代码进行执行 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。最终代码 1234567891011121314Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125; apply与call类似，只是传入的参数是一个数组 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。 返回一个函数 可以传入参数123456789101112131415Function.prototype.myBind = function(context) &#123; if (typeof this !== 'function') &#123; return new Error('Function.prototype.bind - what is trying to be bound is not callable') &#125; var args = Array.prototype.slice.call(arguments,1) var self = this var fNOP = function() &#123;&#125; var fBound = function() &#123; var bingArgs = Array.prototype.slice.call(arguments) self.apply(this instanceof fNOP.prototype ? this : context, args.concat(bindArgs)) &#125; fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound&#125; 类数组具备与数组特征类似的对象 123456let arrayLike = &#123; 0: 1, 1: 2, 2: 3, length: 3&#125;; 获取 DOM 节点的方法方法中的 arguments 都是类数组可以通过for循环进行遍历,类数组无法使用 forEach、splice、push 等数组原型链上的方法 call的使用场景： 对象的继承1234function Parent() &#123;&#125;function Child() &#123; Parent.call(this)&#125; 借用方法类数组想用使用数组的方法1let domNodes = Array.prototype.slice.call(arr) apply的一些妙用:1、获取数组中数字最大最小值12Math.max.apply(null, arr)Math.min.apply(null, arr) 2、合并两个数组1Array.prototype.push.apply(arr1,arr2)","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"instanceof、typeof","slug":"instanceof、typeof","date":"2021-06-17T10:00:58.000Z","updated":"2021-06-17T10:02:26.072Z","comments":true,"path":"2021/06/17/instanceof、typeof/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/06/17/instanceof%E3%80%81typeof/","excerpt":"","text":"typeof实现原理typeof用于判断变量的类型，可以判断number、string、object、undefined、function、boolean、symbol 这7种类型，判断不是object类型的时候可以比较清楚的告诉我们具体是哪一类，但不能明确告诉我们object是哪一种。由于js底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息。 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 对于null和undefined比较特殊，undefined： 用 −2^30 整数来表示null：所以机器码都为0，因此通过typeof判断时候会被当作object使用instanceof判断的话，null直接判断为不是object。因此在使用typeof判断变量类型的时候，最好用来判断基本数据类型（包括symbol），避免对null的判断 还有一个不错的判断类型的方法，Object.prototype.toString,可以利用这个方法来对一个变量类型来进行比较准确的判断 1234567891011121314151617Object.prototype.toString.call(1) // \"[object Number]\"Object.prototype.toString.call('hi') // \"[object String]\"Object.prototype.toString.call(&#123;a:'hi'&#125;) // \"[object Object]\"Object.prototype.toString.call([1,'a']) // \"[object Array]\"Object.prototype.toString.call(true) // \"[object Boolean]\"Object.prototype.toString.call(() =&gt; &#123;&#125;) // \"[object Function]\"Object.prototype.toString.call(null) // \"[object Null]\"Object.prototype.toString.call(undefined) // \"[object Undefined]\"Object.prototype.toString.call(Symbol(1)) // \"[object Symbol]\" instanceof 操作符的实现原理instanceof主要的作用是判断一个实例是否属于某种类型，也可以判断一个实例是否是其父类型或者祖先类型的实例。 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。 因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。 总结：简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"原型、继承","slug":"原型、继承","date":"2021-06-17T09:31:50.000Z","updated":"2021-06-17T09:33:11.681Z","comments":true,"path":"2021/06/17/原型、继承/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/06/17/%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/","excerpt":"","text":"原型在规范里，prototype 被定义为：给其它对象提供共享属性的对象。 JS是通过函数来模拟类，当我们创建一个函数的时候，js会给这个函数自动添加prototype属性，值是一个包含constructor属性的对象，不是空对象。当我们把函数当成构造函数通过new关键词调用的时候，js会帮我们创建该构造函数的实例，实例继承构造函数prototype的所以属性和方法（实例通过设置自己的__proto__指向构造函数的prototype来实现继承） constructorconstructor属性也是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数。 所有 object 对象都有一个隐式引用什么叫隐式引用？所谓的隐式，是指不是由开发者(你和我)亲自创建/操作。__proto__ 原型链原型链的概念，仅仅是在原型这个概念基础上所作的直接推论。既然 prototype 只是恰好作为另一个对象的隐式引用的普通对象。那么，它也是对象，也符合一个对象的基本特征。也就是说，prototype 对象也有自己的隐式引用，有自己的 prototype 对象。 如此，构成了对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。 继承所谓的原型继承，就是指设置某个对象为另一个对象的原型（塞进该对象的隐式引用位置）。在 JavaScript 中，有两类原型继承的方式：显式继承和隐式继承。 显式原型继承所谓的显式原型继承，就是指我们亲自将某个对象设置为另一个对象的原型。通过调用Object.setPrototypeOf 方法 1Object.setPrototypeOf(obj1, obj2) //将obj2设置为obj1的原型对象 还有另一种途径。即是通过 Object.create 方法，直接继承另一个对象。Object.setPropertyOf 和 Object.create 的差别在于： 1）Object.setPropertyOf，给我两个对象，我把其中一个设置为另一个的原型。 2）Object.create，给我一个对象，它将作为我创建的新对象的原型。 隐式原型继承通过 new 去创建 user 对象，可以通过 user.consturctor 访问到它的构造函数。 函数对象和普通对象通过字面量或构造函数new的方式来创建对象 将对象分为函数对象和普通对象，所谓的函数对象，其实就是 JavaScript 的用函数来模拟的类实现 ES5 中的继承实现方法new 关键字手写new12345678var a = myFunction('Deng', 'yongling')function myFunction() &#123; var obj = &#123;&#125; obj.__proto__ = myFunction.prototype var result = myFunction.call(obj, ...arguments) return typeof result === 'object' ? result : obj&#125; 创建一个空对象 将该对象的隐式原型指向构造函数的显式原型 使用call改变this指向 如果无返回值或者返回值是非对象，则返回这个新建的obj，否则直接返回该返回值对象。 继承的多种方式和优缺点1、原型链继承12345678910111213function Parent() &#123; this.name = 'YoLin'&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child() &#123;&#125;Child.prototype = new Parent()var child = new Child()child.getName() // YoLin 存在问题： 1、引用类型得属性被所有实例共享 2、在创建Child实例得时候，不能向Parent传参 2、借用构造函数（经典继承）1234567891011funtion Parent() &#123; this.names = ['YoLin','Deng']&#125;function Child() &#123; Parent.call(this)&#125;var child1 = new Child()child1.names.push('123')// ['YoLin', 'Deng', '123']var child2 = new Child()child2.names // ['YoLin', 'Deng'] 优点： 1、避免了引用类型的属性被所有实例共享 2、可以在Child中向Parent传参12345678function Parent(name) &#123; this.name = name&#125;function Child(name) &#123; Parent.call(this, name)&#125;var child = new Child('YoLin')child.name // YoLin 缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法 3、组合继承原型链继承和经典继承的结合 12345678910111213function Parent(name) &#123; this.name = name; this.colors = ['red', 'blue, green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()Child.prototype.constructor = Child 优点：融合原型链继承和构造函数继承的优点，是javascript中最常用的继承模式 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型时 一次在创建子类型实例的时候 4、原型式继承12345function createObj(o) &#123; funtion F() &#123;&#125; F.prototype = o return new F()&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。缺点：包含引用类型的属性始终都会共享相应的值 5、寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj(o) &#123; var clone = Object.create(o) clone.sayName = fucntion() &#123; console.log('hi') &#125; return clone&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6、寄生组合式继承为了避免重复调用父构造函数 1234567891011121314151617181920212223242526function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function prototpe(child, parent)&#123; const prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype&#125;prototype(Child, Parent) 将组合式继承中的 1Child.prototype = new Parent() 变成调用object重新创建一个新的Parent的原型实例，并赋值给Child的prototype来实现 1prototype(Child, Parent) 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"js执行上下文、作用域链、闭包","slug":"js执行上下文、作用域链、闭包","date":"2021-05-25T02:36:59.000Z","updated":"2021-05-25T02:54:10.438Z","comments":true,"path":"2021/05/25/js执行上下文、作用域链、闭包/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/25/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/","excerpt":"","text":"执行上下文是评估和执行 JavaScript 代码的环境的抽象概念，每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。执行上下文包括： 1、全局执行上下文 2、函数执行上下文 3、Eval函数执行上下文 三个重要属性 变量对象 作用域链 this 执行栈用来存储代码运行时创建的所有上下文（先进后出）但javascript引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文，并压入到当前的执行栈中，每当遇到函数调用会创建一个新的执行上下文并压入到栈顶，当函数执行结束时，执行上下文会从栈中弹出，控制流程到下一个执行上下文，直到所以代码执行完毕后从当前栈中移除全局执行上下文。创建执行上下文有两个阶段 1) 创建阶段 This 绑定 创建词法环境组件内部有两个组件： (1) 环境记录器和 (2) 一个外部环境的引用。两种类型：全局和函数（this不同，外部环境引用不同）在全局环境中，环境记录器是对象环境记录器。在函数环境中，环境记录器是声明式环境记录器。 创建变量环境组件2) 执行阶段 在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。 词法（静态）作用域与动态作用域区别javascript采用的是词法作用域，函数的作用域在函数定义的时候就确定了动态作用域的函数作用域取决于函数调用的时候。 变量对象每一个执行上下文都会分配一个变量对象(variable object)，变量对象的属性由 变量(variable) 和 函数声明(function declaration) 构成。在函数上下文情况下，参数列表(parameter list)也会被加入到变量对象(variable object)中作为属性。变量对象与当前作用域息息相关。不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。有一点特殊就是只有 函数声明(function declaration) 会被加入到变量对象中，而 函数表达式(function expression)则不会。看代码： 12345function a() &#123;&#125;console.log(typeof a) // functionvar a = function _a() &#123;&#125;console.log(typeof a) // functionconsole.log(typeof _a) // undefined 活动对象当函数被激活，那么一个活动对象(activation object)就会被创建并且分配给执行上下文。活动对象由特殊对象 arguments 初始化而成。随后，他被当做变量对象(variable object)用于变量初始化 作用域链由多个执行上下文的变量对象构成的链表就叫做作用域链。以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端Scope = [AO].concat([[Scope]]); 闭包闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束闭包的外部作用域是在其定义的时候已决定，而不是执行的时候（词法作用域） 当外部作用域执行完后，内部函数还存活时，闭包才真正发挥它的作用譬如一下几种情况： 异步任务（定时器，事件处理，ajax请求中的回调） 被外部函数作为返回结果，或者返回结果对象中引用该内部函数 闭包与封装性封装意味着信息隐藏函数与私有状态：通过闭包，可以创建拥有私有状态的函数，闭包使得状态被封装起来。 工厂模式与私有原型对象我们可以通过闭包，只用创建原型对象一次，也能够被所有 Todo 函数调用所公用，并且保证其私有性。示例如下： 12345678910111213let Todo = (function createTodoFactory()&#123; let todoPrototype = &#123; toString : function() &#123; return this.id + \" \" + this.userName + \": \" + this.title; &#125; &#125; return function(todo)&#123; let newTodo = Object.create(todoPrototype); Object.assign(newTodo, todo); return newTodo; &#125;&#125;)();let todo = Todo(&#123;id : 1, title: \"This is a title\", userName: \"Cristi\", completed: false &#125;); 工厂模式与私有构造函数 12345678910let Todo = (function createTodoFactory()&#123; function Todo(spec)&#123; Object.assign(this, spec); &#125; return function(spec)&#123; let todo = new Todo(spec); return Object.freeze(todo); &#125;&#125;)(); 这里，Todo() 工厂函数就是一个闭包。通过它，不管是否使用 new ，我们都可以创建不可变对象，原型对象也只用创建一次，并且它是私有的。 垃圾回收在 Javascript中，局部变量会随着函数的执行完毕而被销毁，除非还有指向他们的引用。当闭包本身也被垃圾回收之后，这些闭包中的私有状态随后也会被垃圾回收。通常我们可以通过切断闭包的引用来达到这一目的。将闭包函数置为 null 总结闭包是一个可以访问外部作用域中变量的内部函数。 这些被引用的变量直到闭包被销毁时才会被销毁。 闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。 可以通过闭包来达到封装性。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"常用的ES6优化升级内容","slug":"常用的ES6优化升级内容","date":"2021-05-24T05:57:59.000Z","updated":"2021-05-24T05:58:36.192Z","comments":true,"path":"2021/05/24/常用的ES6优化升级内容/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/24/%E5%B8%B8%E7%94%A8%E7%9A%84ES6%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E5%86%85%E5%AE%B9/","excerpt":"","text":"一、let 和 const 命令let具有自己的块级作用域，且修复了var声明带来的变量提升问题。使用const声明常量，是不可更改的。 二、对String字符串类型做的常用升级优化 模板字符串（``） 在String的原型上新增includes()方法，取代传统的indexof，语义更清晰 另外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法 1、startsWith: str.startsWith(searchString[, position])*以什么开头，接受两个参数，一个是要搜索的字符串，第二个是搜索开始的位置，默认为0，找到为true，否则为fasle。 2、endsWith：str.endsWith(searchString[, length])*以什么结尾，第一个参数也是搜索的字符串，第二个则是被搜索的字符串长度，默认是str.length 3、padStart:str.padStart(targetLength [, padString])*在原字符串开头填充字符串，直到达到目标长度第一个参数是目标长度，第二个参数是填充字符串，如果字符串太长，则保留左侧 4、padEnd：str.padEnd(targetLength [, padString])*在原字符串末尾填充指定字符串，直到目标长度。与padStart参数相同 5、str.repeat(count)*repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。count：重复的次数，表示新构造的字符串中重复了多少遍原字符串。三、对Array数组类型做的常用升级优化 数组解构赋值:let [a,b,c] = [1,2,3] 扩展运算符: 12let a = [1,2,3];let b = [...a] find和findIndex方法1、find：数组实例find方法，它可接收一个回调函数作为参数，该回调函数可传3个参数分别是当前值、当前位置、原数组。[1,2,3].find((value, index, arr) =&gt; value &gt; 1)执行结果会返回符合条件的首个成员，若没有符合的则返回undefined2、findIndex：与find使用方法类似，不同的是返回符合条件成员位置，没有符合则返回-1 这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。 123[NaN].indexOf(NaN) // -1[NaN].find(x =&gt; Object.is(NaN, x)) // NaN[NaN].findIndex(x =&gt; Object.is(NaN, x)) //0 copyWithin方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。arr.copyWithin(target[, start[, end]])可传如三个参数：1、target表示目标位置，从这个位置开始复制并替换，如果是负数则从尾部开始算，如果target大于arr.length，则不拷贝，若target在start后面，那么复制序列会被修改以符合arr.length2、start表示开始复制元素的起始位置，负数表示从末尾开始算,若不穿start，将从0开始复制3、end表示开始复制元素的结束位置，会拷贝到这个位置，但不包括它，如果是负数，则是从末尾开始算。若不传将复制到数组结尾（默认是arr.length） 123456789101112// 例子[1, 2, 3, 4, 5].copyWithin(-2)// [1, 2, 3, 1, 2][1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(-2, -3, -1)// [1, 2, 3, 3, 4] includesarr.includes(valueToFind[, fromIndex]) valueToFind: 需要查找的元素fromIndex：从fromIndex索引开始查找，可以是负数，表示从末尾开始若着找到对应元素，则返回true，否则返回false[1,2,3].includes(1) // true fillfill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。arr.fill(value[, start[, end]])value: 填充的值start：起始位置索引，默认为0end：结束位置所以，默认是数组长度[1,2,3].fill(6,1) // [1, 6, 6] flatflat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回var newArray = arr.flat([depth])depth: 指定要提取嵌套数组的结构深度，默认值为 1 1[1,2,[3,4,[5,6]]].flat(2) // [1,2,3,4,5,6] 四、对Number数字类型做的常用升级优化 Number原型上新增isFinite(),isNaN()方法，用于优化传统的全局isFinite(), isNaN()，会把非数值类型转为Number类型再判断，而ES6中不会转化类型。分别用于检测数值是否有限、是否是NaN。 Math对象上新增Math.cbrt()，trunc()，hypot()等科学计数法运算方法 五、对Object类型做的常用升级优化 对象属性变量式声明 如果对象属性的值的一个变量，且键值相同，则可省略值的书写 123let &#123; a,b,c &#125; = objlet newObj = &#123;a:a,b:b&#125; //等价于下面的式子let newObj = &#123;a,b&#125; 方法也可以简化为： 12345let obj = &#123; fn() &#123; &#125; &#125; 对象解构赋值let { a,b } = { a:1, b:2 } 对象扩展运算符 123let &#123; a,...rest &#125; = &#123;a:1, b:2, c:3 &#125; // rest = &#123; b:2, c:3 &#125;let obj1 = &#123; a:1, b:2 &#125;let obj2 = &#123;...obj1, c: 3&#125; super 关键字：ES6在Class类里新增了类似this的关键字super。同this总是指向当前函数所在的对象不同，super关键字总是指向当前函数所在对象的原型对象。 在Object原型上新增is()方法，修复了‘===’ 无法比较NaN 新增assign()方法，用于对象新增属性或者对象的合并。123let obj1 = &#123;a: 1, b:2 &#125;let obj2 = &#123;c: 3, d: 4 &#125;Object.assign(obj1, obj2) /// &#123; a:1,b:2,c:3,d:4 &#125; Object.assign(target, ...sources)将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。target是目标对象，将sources源对象分配到该目标对象中。 在Object原型上新增了getPrototypeOf()和setPrototypeOf()方法，用来获取或设置当前对象的prototype对象。 在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组。 六、对Function函数类型做的常用升级优化 箭头函数改变了this的指向，为函数定义时所在的对象，而不是执行时。 函数默认赋值1function fn(a = 1, b) &#123;&#125; 参考链接","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"使用Proxy实现简易的vue双向数据绑定","slug":"使用Proxy实现简易的vue双向数据绑定","date":"2021-05-21T07:52:48.000Z","updated":"2021-05-21T10:25:29.870Z","comments":true,"path":"2021/05/21/使用Proxy实现简易的vue双向数据绑定/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/%E4%BD%BF%E7%94%A8Proxy%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"在实现vue双向数据绑定之前，先了解Proxy相关的概念和用法 proxy概念Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 一些术语 handle包含捕捉器（trap）的占位符对象，可译为处理器对象 traps提供属性访问的方法。这类似于操作系统中捕获器的概念。 target被 Proxy 代理虚拟化的对象。语法const p = new Proxy(target, handler) target要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handle一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。 使用proxy实现数据劫持12345678910111213let data = &#123; name: YoLinDeng, height: '176cm'&#125;const p = new Proxy(data, &#123; get(target, prop) &#123; return Reflect.get(...arguments) &#125;, set(target, prop, newValue) &#123; return Reflect.set(...arguments) &#125;&#125;) 关于vue中数据响应式的原理对数据进行侦测 在vue2.X中，实现一个observe类，对于对象数据，通过Object.defineProperty来劫持对象的属性，实现getter和setter方法，这样就可以在getter的时候知道谁（订阅者）读取了数据，即谁依赖了当前的数据，将它通过Dep类（订阅器）收集统一管理，在setter的时候调用Dep类中的notify方法通知所以相关的订阅者进行更新视图。如果对象的属性也是一个对象的话，则需要递归调用observe进行处理。 对于数组则需要另外处理，通过实现一个拦截器类，并将它挂载到数组数据的原型上，当调用push/pop/shift/unshift/splice/sort/reverse修改数组数据时候，相当于调用的是拦截器中重新定义的方法，这样在拦截器中就可以侦测到数据改变了，并通知订阅者更新视图。 vue3中使用Proxy替代了Object.defineProperty，优点在于可以直接监听对象而非属性、可以直接监听数组的变化、多达13种拦截方法。缺点是兼容性还不够好。Proxy作为新标准将受到浏览器厂商重点持续的性能优化。对模板字符串进行编译 实现Compile解析器类，将template中的模板字符串通过正则等方式进行处理生成对应的ast（抽象语法树），通过调用定义的不同钩子函数进行处理，包括开始标签（start）并判断是否自闭和以及解析属性、结束标签（end）、文本（chars）、注释（comment） 将通过html解析与文本解析的ast进行优化处理，在静态节点上打标记，为后面dom-diff算法中性能优化使用，即在对比前后vnode的时候会跳过静态节点不作对比。 最后根据处理好的ast生产render函数，在组件挂载的时候调用render函数就可以得到虚拟dom。虚拟dom vnode的类型包括注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点，VNode可以描述的多种节点类型，它们本质上都是VNode类的实例，只是在实例化的时候传入的属性参数不同而已。 通过将模板字符串编译生成虚拟dom并缓存起来，当数据发生变化时，通过对比变化前后虚拟dom，以变化后的虚拟dom为基准，更新旧的虚拟dom，使它和新的一样。把dom-diff过程叫做patch的过程，其主要做了三件事，分别是创建/删除/更新节点。 对于子节点的更新策略，vue中为了避免双重循环数据量大时候造成时间复杂度高带来的性能问题，而选择先从子节点数组中4个特殊位置进行对比，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。如果四种情况都没有找到相同的节点，则再通过循环方式查找。实现简易的vue双向数据绑定vue的双向数据绑定主要是指，数据变化更新视图变化，视图变化更新数据。 实现代码如下*12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width= , initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"myVue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123;name&#125;&#125; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;input type=\"text\" v-model=\"test\"&gt; &lt;span&gt;&#123;&#123;test&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; let vm = new vue(&#123; el: '#app', data: &#123; name: 'YoLinDeng', message: '打篮球', test: '双向绑定数据' &#125; &#125;) // console.log(vm._data) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class vue extends EventTarget &#123; constructor(option) &#123; super() this.option = option this._data = this.option.data this.el = document.querySelector(this.option.el) this.compileNode(this.el) this.observe(this._data) &#125; // 实现监听器方法 observe(data) &#123; const context = this // 使用proxy代理，劫持数据 this._data = new Proxy(data, &#123; set(target, prop, newValue) &#123; // 自定义事件 let event = new CustomEvent(prop, &#123; detail: newValue &#125;) // 发布自定义事件 context.dispatchEvent(event) return Reflect.set(...arguments) &#125; &#125;) &#125; // 实现解析器方法，解析模板 compileNode(el) &#123; let child = el.childNodes let childArr = [...child] childArr.forEach(node =&gt; &#123; if (node.nodeType === 3) &#123; let text = node.textContent let reg = /\\&#123;\\&#123;\\s*([^\\s\\&#123;\\&#125;]+)\\s*\\&#125;\\&#125;/g if (reg.test(text)) &#123; let $1 = RegExp.$1 this._data[$1] &amp;&amp; (node.textContent = text.replace(reg, this._data[$1])) // 监听数据更改事件 this.addEventListener($1, e =&gt; &#123; node.textContent = text.replace(reg, e.detail) &#125;) &#125; &#125; else if (node.nodeType === 1) &#123; // 如果是元素节点 let attr = node.attributes // 判断属性中是否含有v-model if (attr.hasOwnProperty('v-model')) &#123; let keyName = attr['v-model'].nodeValue node.value = this._data[keyName] node.addEventListener('input', e =&gt; &#123; this._data[keyName] = node.value &#125;) &#125; // 递归调用解析器方法 this.compileNode(node) &#125; &#125;) &#125;&#125;","categories":[{"name":"框架原理","slug":"框架原理","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"}]},{"title":"手写防抖与节流函数","slug":"手写防抖与节流函数","date":"2021-05-21T07:51:32.000Z","updated":"2021-05-21T07:53:51.914Z","comments":true,"path":"2021/05/21/手写防抖与节流函数/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们经常会绑定一些持续触发的事件，比如resize、scroll、mousemove等等，如果事件调用无限制，会加重浏览器负担，导致用户体验差，我们可以使用debounce(防抖)和throttle(节流)的方式来减少频繁的调用，同时也不会影响实际的效果。 防抖的概念触发事件后n秒后才执行函数，如果在n秒内触发了事件，则会重新计算函数执行时间防抖函数可以分为立即执行，和非立即执行两个版本 非立即执行版本 1234567891011function debounce(fn, wait) &#123; let timer = null return function () &#123; const context = this const args = arguments timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125;&#125; 此函数一开始不会马上执行，而是等到用户操作结束之后等待wait秒后才执行，如果在wait之内用户又触发了事件，则会重新计算 立即执行版本 1234567891011121314function debounce(fn, wait) &#123; let timer = null return function () &#123; const args = arguments const now = !timer timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; timer = null &#125;, wait) if (now) &#123; fn.apply(this, args) &#125; &#125;&#125; 立即执行就是触发事件后马上先执行一次，直到用户停止执行事件等待wait秒后再执行一次 我们可以将两种版本合并成一种 12345678910111213141516171819202122232425/** * @desc 函数防抖 * @param fn 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表示非立即执行 */ function debounce(fn, wait, immediate) &#123; let timer = null return function () &#123; const context = this const args = arguments timer &amp;&amp; clearTimeout(timer) if (immediate) &#123; const now = !timer timer = setTimeout(() =&gt; &#123; timer = null &#125;, wait) now &amp;&amp; fn.apply(context, args) &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125; &#125; &#125; 节流的概念连续触发事件但在n秒内只执行一次函数对于节流有时间戳和定时器两种版本 时间戳版本123456789101112function throttle(fn, wait) &#123; var prev = 0 return function () &#123; let now = Date.now() let context = this let args = arguments if (now - prev &gt; wait) &#123; fn.apply(context, args) prev = now &#125; &#125;&#125; 在持续触发事件的过程中，函数会立即执行，用户在wait秒内不管执行多少次事件，都会等待wait秒后再执行。 定时器版本12345678910111213function throttle(fn, wait) &#123; var timer = null return function () &#123; const context = this const args = arguments if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null fn.apply(context, args) &#125;, wait) &#125; &#125;&#125; 在触发事件的过程中，不会立即执行，并且每wait秒执行一次，在停止触发事件后还会再执行一次。 时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 将两种方式合并 12345678910111213141516171819202122232425262728293031/** * @desc 函数节流 * @param fn 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */ function throttle(fn, wait, type) &#123; if (type === 1) &#123; var prev = 0 &#125; else &#123; var timer = null &#125; return function() &#123; const context = this const args = arguments if (type === 2) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null fn.apply(context, args) &#125;, wait) &#125; &#125; else if(type === 1) &#123; const now = Date.now() if (now - prev &gt; wait) &#123; fn.apply(context, args) prev = now &#125; &#125; &#125; &#125; 参考链接","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"react中实现导航栏状态与地址绑定","slug":"react中实现导航栏状态与地址绑定","date":"2021-05-21T07:39:19.000Z","updated":"2022-05-17T07:38:31.172Z","comments":true,"path":"2021/05/21/react中实现导航栏状态与地址绑定/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/react%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%8A%B6%E6%80%81%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A/","excerpt":"","text":"一、项目初始化1. 安装与运行构建项目：yarn create react-app my-app启动：yarn start当然也可以使用npm： 全局安装：npm install -g create-react-app 构建项目：npx create-react-app my-app 启动：npm start 2.安装路由依赖在项目中执行：npm install react-router-dom --save 3.在App.js中引入router由于简单演示，就不单独对router进行封装了。安装完成后，我们在App.js中引入路由相关组件BrowserRouter、Route、Switch、Redirect在顶部引入：import { BrowserRouter as Router, Route, Switch, Redirect } from &#39;react-router-dom&#39;详细代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react';import Home from '@/views/home'import Study from '@/views/study'import Type from '@/views/type'import Label from '@/views/label'import About from '@/views/about'import &#123; Layout &#125; from 'antd'import Header from '@/components/Header'import Persional from '@/components/Persional'import &#123; BrowserRouter as Router, Route, Switch, Redirect &#125; from 'react-router-dom'const &#123; Footer, Content, Sider&#125; = Layout;// 导入子组件class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\" &gt; &lt;Layout&gt; &lt;Sider&gt; &lt;Persional /&gt; &lt;/Sider&gt; &lt;Content&gt; &lt;Router&gt; &lt;Header /&gt; &lt;Switch&gt; &lt;Route path=\"/home\" exact component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/study\" component=&#123;Study&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/type\" component=&#123;Type&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/label\" component=&#123;Label&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/about\" component=&#123;About&#125;&gt;&lt;/Route&gt; &lt;Redirect from=\"/*\" to=\"/home\"&gt;&lt;/Redirect&gt; &lt;/Switch&gt; &lt;Footer&gt;Footer&lt;/Footer&gt; &lt;/Router&gt; &lt;/Content&gt; &lt;/Layout&gt; &lt;/div&gt; ); &#125;&#125;export default App; 这里用到了antd的Layout布局组件进行布局首先我们将我们的视图组件引入进来（import Home from &#39;@/views/home&#39;），并在Route标签中配置：（以home为例）&lt;Route path=&quot;/home&quot; exact component={Home}&gt;&lt;/Route&gt; 4.编写Header头部导航组件在components目录下新建Header目录，并在其目录下新建index.js及index.scss文件，这里使用scss进行编写。安装命令： 12npm install node-sass --save-dev npm install sass-loader --save-dev 为了实现导航栏状态与地址联动，关键是要实现组件初始化时的处理逻辑，也就是组件挂载的时候，即在生命周期函数componentDidMount中实现。要实现以下两点： 修改当前地址对应导航栏状态 监听浏览器前进后退，即监听history对象关键代码如下：1234567891011121314151617componentDidMount = () =&gt; &#123; let moren = this.props.location.pathname let text = moren.substring(moren.lastIndexOf('/') + 1, moren.length) // 当访问的目录不在这个数组里时候，当前状态是home，即重定向到home页面 !['home', 'study', 'type', 'label', 'about', 'search'].includes(text) &amp;&amp; (text = 'home') this.setState(&#123; current: text &#125;) // 监听history变化 history.listen((event) =&gt; &#123; let test = event.pathname let text = test.substring(test.lastIndexOf('/') + 1, test.length) this.setState(&#123; current: text &#125;) &#125;) &#125; 组件完整代码如下：index.js:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; Component &#125; from 'react';import &#123; Row, Col, Menu &#125; from 'antd';import &#123; Link, withRouter &#125; from 'react-router-dom'import &#123; HomeOutlined, FolderOpenOutlined, AppstoreOutlined, PushpinOutlined, UserOutlined, SearchOutlined &#125; from '@ant-design/icons';import './index.scss'import &#123; createBrowserHistory &#125; from 'history';const history = createBrowserHistory() // history模式class Header extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; logo: '', current: 'home' &#125; &#125; handleClick = e =&gt; &#123; this.setState(&#123; current: e.key &#125;); &#125; componentDidMount = () =&gt; &#123; let moren = this.props.location.pathname let text = moren.substring(moren.lastIndexOf('/') + 1, moren.length) !['home', 'study', 'type', 'label', 'about', 'search'].includes(text) &amp;&amp; (text = 'home') this.setState(&#123; current: text &#125;) history.listen((event) =&gt; &#123; let test = event.pathname let text = test.substring(test.lastIndexOf('/') + 1, test.length) this.setState(&#123; current: text &#125;) &#125;) &#125; render() &#123; const &#123; current &#125; = this.state; return( &lt;div className=\"header-wrapper\"&gt; &lt;Row&gt; &lt;Col span=&#123;18&#125; push=&#123;6&#125; className=\"right-box\"&gt; &lt;Menu onClick=&#123;this.handleClick&#125; selectedKeys=&#123;[current]&#125; mode=\"horizontal\"&gt; &lt;Menu.Item key=\"home\" icon=&#123;&lt;HomeOutlined /&gt;&#125;&gt; &lt;Link to=\"/home\"&gt;首页&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"study\" icon=&#123;&lt;FolderOpenOutlined /&gt;&#125;&gt; &lt;Link to=\"/study\"&gt;学习&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"type\" icon=&#123;&lt;AppstoreOutlined /&gt;&#125;&gt; &lt;Link to=\"/type\"&gt;分类&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"label\" icon=&#123;&lt;PushpinOutlined /&gt;&#125;&gt; &lt;Link to=\"/label\"&gt;标签&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"about\" icon=&#123;&lt;UserOutlined /&gt;&#125;&gt; &lt;Link to=\"/about\"&gt;关于&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;Menu.Item key=\"search\" icon=&#123;&lt;SearchOutlined /&gt;&#125;&gt; 搜索 &lt;/Menu.Item&gt; &lt;/Menu&gt; &lt;/Col&gt; &lt;Col span=&#123;6&#125; pull=&#123;18&#125; className=\"left-box\"&gt; &lt;strong className=\"logo-name\"&gt;Deng&lt;/strong&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; ) &#125;&#125;export default withRouter(Header) 注意：为了能够拿到this.props.location.pathname,需要使用withRouter处理组件，并把Header组件放在BrowserRouter标签中。这样就能够实现导航栏状态与地址绑定了","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yolindeng.gitee.io/myblog/tags/react/"}]},{"title":"sass常用方法","slug":"sass常用方法","date":"2021-05-21T07:37:26.000Z","updated":"2021-05-21T07:37:47.825Z","comments":true,"path":"2021/05/21/sass常用方法/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/sass%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、什么是sassSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，提供了许多便利的写法，大大提高的开发效率。下面总结了SASS的主要用法，想要了解更多可以查阅文档 二、安装1、由于sass依赖于Ruby，因此需要先安装Ruby，然后执行gem install sass2、若在vue-cli或react-create-app中使用，在项目中安装依赖： 12npm install node-sass --save-devnpm install sass-loader --save-dev 三、基础用法3.1 变量SASS允许使用变量，所有变量以$开头 1234$color: #ccc;div &#123; color: $color;&#125; 如果变量需要镶嵌在属性中之中，就必须需要写在#{}之中 1234$side: right;div &#123; border-#&#123;$side&#125;-radius: 10px;&#125; 3.2 计算能力SASS允许在代码中使用算式 123456$var: 10px;div &#123; width：(20px/2); top: 10px + 20px; left: $var * 2&#125; 3.3 嵌套能力一般我们写多个选择器时，一般这样： 123div h2 &#123; border:1px solid #ccc;&#125; 使用sass可以写成： 12345div &#123; h2 &#123; border:1px solid #ccc; &#125;&#125; 属性也可以嵌套,比如font-size属性，可以写成 12345div &#123; font：&#123; size：18px; &#125;&#125; 可以使用&amp;引用父元素 1234div &#123; &amp;::after &#123; &#125;&#125; 四、代码重用4.1 继承SASS允许一个选择器，继承另一个选择器 123.class1 &#123; color: #ccc;&#125; 如果要继承class1，需要使用@extend命令 1234.class2 &#123; @extend .class1; font-size: 18px;&#125; 4.2 Mixin(混合)使用@mixin声明代码块，达到重用代码块的作用，在需要用的地方使用@include调用 123456@mixin right &#123; margin-right: 20px;&#125;div &#123; @include right;&#125; @minxin可以设置参数以及参数默认值 123456@mixin left($value: 20px) &#123; margin-left: $value;&#125;div &#123; @include left(10px)&#125; 4.3 颜色函数1234lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 4.4 引入文件使用@import命令，用来引入外部文件@import 文件路径 五、进阶用法5.1 条件语句12345678div &#123; @if computed($width) &gt; 10 &#123; width: 10% &#125; @if computed($height) &gt; 10 &#123; height: 10px; &#125; @else &#123; height: 20px; &#125;&#125; 5.2 循环语句for循环: 12345@for $i from 1 to 10 &#123; .content-#&#123;$i&#125; &#123; width: #&#123;$i&#125;px; &#125; &#125; while循环: 12345 $x: 6; @while $x &gt; 0 &#123; .item-#&#123;$x&#125; &#123; width: $x + 10px; &#125; $x: $x - 1; &#125;z each: 12345@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url(\"/image/#&#123;$member&#125;.jpg\"); &#125; &#125; 自定义函数1234567 @function count($n) &#123; @return $n + 1; &#125; div &#123; width: count(5px); &#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scss","slug":"scss","permalink":"http://yolindeng.gitee.io/myblog/tags/scss/"}]},{"title":"vue-cli中使用svgIcon","slug":"vue-cli中使用svgIcon","date":"2021-05-21T03:28:04.000Z","updated":"2021-05-21T03:28:39.990Z","comments":true,"path":"2021/05/21/vue-cli中使用svgIcon/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/vue-cli%E4%B8%AD%E4%BD%BF%E7%94%A8svgIcon/","excerpt":"","text":"一、安装依赖包123npm install svg-sprite-loader -D或者yarn add svg-sprite-loader -D 二、配置vue.config.js文件在顶部写入 1234const path = require('path')function resolve (dir) &#123; return path.join(__dirname, dir)&#125; 在chainWebpack中增加下列配置 12345678910chainWebpack (config) &#123; config.module.rule('svg') .exclude.add(resolve('src/icons')) config.module.rule('icons') .test(/\\.svg$/) .include.add(resolve('./src/icons')).end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options(&#123; symbolId: 'icon-[name]' &#125;) &#125; 三、实现SvgIcon组件组件结构如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;svg :class=\"svgClass\" v-on=\"$listeners\"&gt; &lt;use :xlink:href=\"iconName\" /&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String, default: '' &#125; &#125;, computed: &#123; iconName () &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass () &#123; if (this.className) &#123; return 'svg-icon ' + this.className &#125; else &#123; return 'svg-icon' &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 四、根目录下创建icons/svg目录 用于存放我们所需要用的svg文件 五、新建plugins目录及index.js文件1234567import Vue from 'vue'import SvgIcon from '@/components/SvgIcon'const req = require.context('@/icons/svg', true, /\\.svg$/)req.keys().map(req)Vue.component('svg-icon', SvgIcon) 其作用是在Vue实例上创建SvgIcon组件，其中require.context的作用是获取一个特定的上下文,遍历文件夹中的指定文件，主要用来实现自动化导入模块 最后在main.js中引入plugins, import &#39;@/plugins&#39; 六、SvgIcon 组件的使用1&lt;svg-icon icon-class=\"icon-name\" class=\"down\"&gt;&lt;/svg-icon&gt; 其中icon-class为svg文件名， class为类名","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"},{"name":"组件化","slug":"组件化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"vue中组件通信之findComponents","slug":"vue中组件通信之findComponents","date":"2021-05-21T03:27:02.000Z","updated":"2021-05-21T03:27:42.935Z","comments":true,"path":"2021/05/21/vue中组件通信之findComponents/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8BfindComponents/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839// 向上查找组件 context为当前组件上下文对象，componentName为组件名const findUpwardComponent = (context, componentName) =&gt; &#123; let parent = context.$parent let name = parent.$options.name while (parent &amp;&amp; (!name || !name.includes(componentName))) &#123; parent = parent.$parent if (parent) name = parent.$options.name &#125; return parent&#125;// 查找兄弟组件const findBrotherComponents = (ctx, componentName, exceptMe = true) =&gt; &#123; const $brothers = ctx.$parent.$children.filter(item =&gt; &#123; return item.$options.name &amp;&amp; item.$options.name.includes(componentName) &#125;) const index = $brothers.findIndex(item =&gt; item._uid === ctx._uid) if (exceptMe &amp;&amp; index &gt; -1) $brothers.splice(index, 1) return $brothers&#125;// 向下查找const findDownwardComponent = (context, componentName) =&gt; &#123; const $children = context.$children let bean = null if ($children.length) &#123; for (const child of $children) &#123; const name = child.$options.name if (name &amp;&amp; name.includes(componentName)) &#123; bean = child break &#125; else &#123; bean = findDownwardComponent(child, componentName) if (bean) break &#125; &#125; &#125; return bean&#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"}]},{"title":"scss实现retina屏1px边框","slug":"scss实现retina屏1px边框","date":"2021-05-21T03:25:32.000Z","updated":"2021-05-21T03:26:10.250Z","comments":true,"path":"2021/05/21/scss实现retina屏1px边框/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/scss%E5%AE%9E%E7%8E%B0retina%E5%B1%8F1px%E8%BE%B9%E6%A1%86/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// =======================// 用法： // @include retina-border(1,1,1,1);// 数值 代表 各 边框的宽度 上右下左// =======================@mixin _border-scale($dpr) &#123; width: 100% * $dpr; height: 100% * $dpr; -webkit-transform: scale(1 / $dpr); -webkit-transform-origin: 0 0; transform: scale(1 / $dpr); transform-origin: 0 0;&#125;@mixin _border-base() &#123; content: \"\"; position: absolute; top: 0; left: 0; pointer-events: none;&#125;@mixin retina-border($top: 0, $right: 0, $bottom: 0, $left: 0, $cor: #000000) &#123; position: relative; &amp;::before &#123; border-top: #&#123;$top&#125;px solid $cor; border-right: #&#123;$right&#125;px solid $cor; border-bottom: #&#123;$bottom&#125;px solid $cor; border-left: #&#123;$left&#125;px solid $cor; @include _border-base(); @media screen and (-webkit-min-device-pixel-ratio: 1) &#123; @include _border-scale(1); &#125; @media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123; @include _border-scale(1.5); &#125; @media screen and (-webkit-min-device-pixel-ratio: 2) &#123; @include _border-scale(2); &#125; @media screen and (-webkit-min-device-pixel-ratio: 3) &#123; @include _border-scale(3); &#125; &#125;&#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scss","slug":"scss","permalink":"http://yolindeng.gitee.io/myblog/tags/scss/"}]},{"title":"常用的git命令操作","slug":"常用的git命令操作","date":"2021-05-21T03:21:47.000Z","updated":"2021-05-21T03:24:39.088Z","comments":true,"path":"2021/05/21/常用的git命令操作/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","excerpt":"","text":"安装在使用git之前需要先安装它下载git 以windows系统为例子，安装完成后，鼠标右键点击桌面，出现Git Bash Here和 Git GUI Here 说明安装成功。 命令设置用户名和邮箱12git config --global user.name \"\" git config --global user.email \"\" 克隆远程仓库与代码提交1、在github上新建项目new repositories后，复制https地址或ssh2、在相应的目录，右键选择 git bash here 进入 git操作界面3、输入 git clone “复制的仓库地址”4、对仓库内存进行修改5、cd 文件夹名称（进入文件夹）6、git add .（或git add –all）7、git commit -m “需要写的提交说明”8、git push 其中git add . 与git add –all的区别是:（1）.git add –all可以提交未跟踪、修改和删除文件。（2）.git add .可以提交未跟踪和修改文件，但是不处理删除文件。 创建新的分支1git checkout -b 分支名称 （创建并切换至该分支） 注：新建的分支第一次push： git push -u origin 分支名 查看当前分支12git branch // 本地分支git branch -a // 所以分支,包括线上 删除分支12git branch -D 分支名 // 删除本地分支git push origin --delete 分支名 // 删除远程分支 切换分支1git checkout 分支名 合并分支123456789101112131415161718191、先切换到master分支 git checkout master2、拉取最新代码 git pull3、切换到自己的分支 并将master分支与自己的分支合并，然后解决冲突git merge master 解决完冲突后，git add --all git commit -m\"\"git fetch origin master// 虚拟的更新远程的mastergit merge origin/master //合并远程mastergit push 推到自己的远程分支4、切换到 master 分支5、将自己的分子合并到master 分支git merge 分支名 跟踪到远程名字相同的分支1git branch --set-upstream-to=origin/分支名 分支名 将更改加入暂存区12345git stash save \"描述信息\"git stash list : 显示保存列表。git stash pop 恢复最近保存的记录并把恢复的记录从保存列表中删除 查看与生成公钥进入该目录并列出其中内容： 12345cd ~/.sshlscat id_rsa.pub // 查看公钥 设置邮箱与用户名 123git config --global user.name \"\"git config --global user.email \"\" 清理之前的公钥 12345mkdir key_backupcp id_rsa* key_backuprm id_rsa* 生成 1ssh-keygen -t rsa -C \"邮箱号\" // C是大写 查看 1cat id_rsa.pub 版本回滚查看版本 1git log -num // num: 版本数量 回滚到指定的版本 1git reset --hard id // id: 版本id","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yolindeng.gitee.io/myblog/tags/git/"}]},{"title":"vue中实现倒计时组件与毫秒效果","slug":"vue中实现倒计时组件与毫秒效果","date":"2021-05-21T03:10:58.000Z","updated":"2021-05-21T03:20:28.928Z","comments":true,"path":"2021/05/21/vue中实现倒计时组件与毫秒效果/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%AF%AB%E7%A7%92%E6%95%88%E6%9E%9C/","excerpt":"","text":"时分秒倒计时组件template12345678910111213141516171819202122232425&lt;template&gt; &lt;!-- 倒计时组件 --&gt; &lt;div class=\"downTime-wrapper\"&gt; &lt;!-- 这里是显示还未结束时的内容，这里只是我这得布局，你可以随意。 --&gt; &lt;div class=\"time\" v-show=\"!isShow\"&gt; &lt;!-- &lt;span class=\"hour\"&gt;&#123;&#123;myDay&#125;&#125;&lt;/span&gt; : --&gt; &lt;div class=\"hour\"&gt; &lt;span&gt;&#123;&#123; getHours1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getHours2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;span class=\"dian\"&gt;:&lt;/span&gt; &lt;div class=\"minute\"&gt; &lt;span&gt;&#123;&#123; getMinutes1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getMinutes2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;span class=\"dian\"&gt;:&lt;/span&gt; &lt;div class=\"second\"&gt; &lt;span&gt;&#123;&#123; getSeconds1 &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; getSeconds2 &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 这里是显示结束后的内容 --&gt; &lt;span class=\"second\" v-show=\"isShow\"&gt;&#123;&#123;clocker&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; script12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;script&gt;export default &#123; name: 'downTime', props: &#123; // 接收父组件传递过来的参数,这里传了 结束时间 - 开始时间 - 结束后显示的内容 endTime: &#123; type: Number &#125;, startTime: &#123; type: Number &#125;, endMsg: &#123; type: String &#125; &#125;, data () &#123; return &#123; isShow: false, // 控制显示结束或还未结束显示的内容 clocker: '', // 结束后显示的内容 timeObj: null, // 时间对象,下方会用到 myDay: 0, // 我定义来接收计算出来的 天 的 myHours: 0, // 我定义来接收计算出来的 小时 的 myMinutes: 0, // 我定义来接收计算出来的 分钟 的 mySeconds: 0// 我定义来接收计算出来的 秒钟 的 &#125; &#125;, computed: &#123; getHours1 () &#123; return this.myHours &lt; 10 ? 0 : parseInt((this.myHours % 100) / 10) &#125;, getHours2 () &#123; return parseInt(this.myHours % 10) &#125;, getMinutes1 () &#123; return this.myMinutes &lt; 10 ? 0 : parseInt((this.myMinutes % 100) / 10) &#125;, getMinutes2 () &#123; return parseInt(this.myMinutes % 10) &#125;, getSeconds1 () &#123; return this.mySeconds &lt; 10 ? 0 : parseInt((this.mySeconds % 100) / 10) &#125;, getSeconds2 () &#123; return parseInt(this.mySeconds % 10) &#125; &#125;, mounted () &#123; &#125;, methods: &#123; option () &#123; // 计算时间差 let timeLag = (this.endTime - this.startTime) / 1000 // 判断当前是否时分秒的值是否大于10 const add = num =&gt; &#123; return num &lt; 10 ? '0' + num : num &#125; // 时间倒计时运算的方法 const timeFunction = () =&gt; &#123; const time = timeLag-- this.timeObj = &#123; // 时间对象 seconds: Math.floor(time % 60), minutes: Math.floor(time / 60) % 60, hours: Math.floor(time / 60 / 60) % 24, days: Math.floor(time / 60 / 60 / 24) &#125; // 计算出时分秒 this.myDay = `$&#123;add(this.timeObj.days)&#125;` this.myHours = `$&#123;add(this.timeObj.hours)&#125;` this.myMinutes = `$&#123;add(this.timeObj.minutes)&#125;` this.mySeconds = `$&#123;add(this.timeObj.seconds)&#125;` // 当时间差小于等于0时,停止倒计时 if (time &lt;= 0) &#123; this.isShow = true this.clocker = this.endMsg clearInterval(go) &#125; &#125; // 开始执行倒计时 timeFunction() // 每一秒执行一次 const go = setInterval(() =&gt; &#123; timeFunction() &#125;, 1000) &#125; &#125;, watch: &#123; endTime: &#123; handler (newName, oldName) &#123; this.option() &#125;, immediate: true, deep: true &#125; &#125;&#125;&lt;/script&gt; 备注：我将时分秒使用计算属性分成了个位和十位两部分展示，在watch中深度监听endTime属性的变化并重新调用定时器 style1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style lang=\"scss\" scoped&gt;.downTime-wrapper&#123; display: inline-block; .dian &#123; font-weight: bold; position: relative; top: -5px; &#125; .hour&#123; display: inline-block; font-size: 36px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125; .minute&#123; display: inline-block; font-size: 36px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125; .second &#123; display: inline-block; font-size: 36px; margin-top: -5px; span &#123; border-radius:6px; color: #FFFFFF; background:rgba(27,23,22,1); padding: 1px 10px; margin: 0 2px; &#125; &#125;&#125;&lt;/style&gt; 使用在页面中引入并注册后即可使用 12345&lt;timer :endTime=\"item.endTime\" :startTime=\"new Date().getTime()\" :endMsg=\"item.endMsg\"&gt;&lt;/timer&gt; 毫秒倒计时效果在template中加入&lt;b id=&quot;timehs&quot;&gt;:00&lt;/b&gt; 声明timeDt方法 123456789101112131415161718methods: &#123; timeDt () &#123; this.timer1 = setTimeout(function () &#123; var haomiao = 99 document.getElementById('timehs').innerHTML = ':' + haomiao this.timer2 = setInterval(function () &#123; const timehs = document.getElementById('timehs') if (timehs) &#123; timehs.innerHTML = `:$&#123;haomiao &lt; 10 ? `0$&#123;haomiao&#125;` : haomiao&#125;` &#125; haomiao-- if (haomiao &lt; 0) &#123; haomiao = 99 &#125; &#125;, 10) &#125;, 1000) &#125; &#125; 在create生命周期函数中调用timeDt方法 12345created () &#123; this.$nextTick(() =&gt; &#123; this.timeDt() &#125;) &#125;,","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"},{"name":"组件化","slug":"组件化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"Mongoose在egg中的运用","slug":"Mongoose在egg中的运用","date":"2021-05-21T03:04:54.000Z","updated":"2021-05-21T03:08:49.103Z","comments":true,"path":"2021/05/21/Mongoose在egg中的运用/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/Mongoose%E5%9C%A8egg%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/","excerpt":"","text":"Mongoose是什么？Mongoose是MongoDB的一个对象模型工具，封装了许多MongoDB对文档的的增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。###在egg项目中如何使用？ 1、安装npm i egg-mongoose --save 2、配置在根目录下的/config/plugin.js中配置插件 1234exports.mongoose = &#123; enable: true, package: 'egg-mongoose',&#125;; 3、连接数据库在根目录下的/config/config.default.js增加配置，其中url为我们的数据库地址，可通过环境变量来区分开发环境还是生产环境，并且确定是否使用用户名密码的数据库const prod = process.env.npm_config_server_prod; 12345678mongoose: &#123; client: &#123; url: prod ? 'mongodb:eggadmin:123456@localhost:27017/DbName' : 'mongodb://127.0.0.1:27017/DbName', options: &#123; useUnifiedTopology: true, &#125;, &#125;, &#125;, 4、配置与使用（1）数据表配置在app目录下新建model文件夹，在model文件夹下新建JS文件作为数据表的配置内容，下面以书籍表的配置为例 123456789101112131415161718192021222324252627282930'use strict';/** * @description: Mongoose book Schema, */module.exports = app =&gt; &#123; const mongoose = app.mongoose; const Schema = mongoose.Schema; const BookSchema = new Schema(&#123; desc: &#123; type: String &#125;, /* 书籍描述 */ name: &#123; type: String &#125;, /* 书籍名称 */ press: &#123; type: String &#125;, /* 出版社 */ author: &#123; type: String &#125;, /* 作者 */ image: &#123; type: Array &#125;, /* 书籍图片列表*/ price: &#123; type: String &#125;, /* 价格 */ book_type: &#123; /* 书籍分类id */ type: Schema.Types.ObjectId, ref: 'BookClassify', &#125;, user: &#123; /* 书籍发布者id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, create_time: &#123; type: String &#125;, /* 创建时间 */ status: &#123; type: String &#125;, /* 状态，1：待购买，2：已购买*/ look: &#123; type: Number &#125; /* 浏览数量 */ &#125;); return mongoose.model('Book', BookSchema);&#125;; 可以看到我们可以通过Schema来定义表结构，可以指定字段的类型及关联，设置完字段后就可以生成model了，这里算是非常简单的配置，更多配置方法可参考文档 (2)、使用mongoose方法配置完数据表结构后，我们就可以再service层中调用mongoose的方法对文档进行增删查改了，已书籍列表的处理逻辑为例子 12345678910111213141516171819202122232425262728293031323334353637383940async findbookList(data) &#123; const &#123; type, page, pageSize, desc, status, userId &#125; = data; const searchVal = &#123;&#125; if (type) &#123; searchVal.book_type = mongoose.Types.ObjectId(type) &#125; if (status) &#123; searchVal.status = status &#125; if (userId) &#123; searchVal.user = mongoose.Types.ObjectId(userId) &#125; const search_term = &#123; $or: [ &#123; desc: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; name: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; author: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; press: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, ], &#125;; const totalNum = await this.ctx.model.Book.find(searchVal).and(search_term).countDocuments(); const result = await this.ctx.model.Book.find(searchVal) .populate(&#123; path: 'user', select: &#123; name: 1, image: 1 &#125; &#125;) .populate(&#123; path: 'book_type' &#125;) .and(search_term) .sort(&#123; create_time: -1 &#125;) .skip((parseInt(page) - 1) * parseInt(pageSize)) .limit(parseInt(pageSize)); return result ? &#123; bean: &#123; records: result, current: page, size: result.length, total: totalNum, &#125;, ...app.config.msg.GET_SUCCESS &#125; : app.config.msg.GET_ERR;&#125; 可以看到，通过this.ctx.model.Book就可以获取到Book的model并且可以调用mongoose需要的方法，例如populate、find、and、sort、skip、limit 等等。 5、egg-Mongoose常用的方法增加数据1this.ctx.model.Book.create(data,callback); 其中data为json数据结构，callback为操作后的回调函数 查询数据获取所有数据，返回是一个数组1this.ctx.model.Book.find() 获取一个数据，返回是一个对象1this.ctx.model.Book.findOne() 条件查询1this.ctx.model.Article.find(conditions,callback); 其中conditions为查询的条件，callback为回调函数conditions有一下几种情况： 具体数据： 1this.ctx.model.Book.find(&#123;_id：5c4a19fb87ba4002a47ac4d, name: \"射雕英雄传\" &#125;, callback); 条件查询： 1234567\"$lt\" 小于\"$lte\" 小于等于\"$gt\" 大于\"$gte\" 大于等于\"$ne\" 不等于// 查询价格大于100小于200的书籍数组this.ctx.model.Book.find(&#123; \"price\": &#123; $get:100 , $lte:200 &#125;); 或查询 OR 123456\"$in\" 一个键对应多个值\"$nin\" 同上取反, 一个键不对应指定值\"$or\" 多个条件匹配, 可以嵌套 $in 使用\"$not\" 同上取反, 查询与特定模式不匹配的文档this.ctx.model.Book.find(&#123;\"name\":&#123; $in: [\"射雕\",\"倚天\"]&#125; ); 删除数据1this.ctx.model.Book.remove(conditions,callback); 更新数据1this.ctx.model.Book.update(conditions, update, callback) conditions为条件，update是更新的值对象 排序1this.ctx.model.Book.sort(&#123; create_time: -1 &#125;); 其中-1表示降序返回。 1表示升序返回 限制数量1this.ctx.model.Book.limit(number); number表示限制的个数 跳过文档返回1this.ctx.model.Book.skip(number); number表示跳过的个数,skip经常搭配limit实现分页的功能 条件数组and在find后面可使用and对查询结果进行进一步条件筛选，相当于并且的意思。 123456789const search_term = &#123; $or: [ &#123; desc: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; name: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; author: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, &#123; press: &#123; $regex: desc ? desc : '', $options: '$i' &#125; &#125;, ], &#125;; this.ctx.model.Book.find().and(search_term) 关联查询populate123456789101112// 在model中配置字段时候指定关联的表名，就可以通过populate来进行表的关联查询user: &#123; /* 书籍发布者id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, this.ctx.model.Book.find() .populate(&#123; path: 'user', select: &#123; name: 1, image: 1 &#125; &#125;) 聚合管道Aggregate12345this.ctx.model.Template.aggregate([ &#123; $match: &#123; name &#125; &#125;, &#123; $sort: &#123; create_time: -1 &#125; &#125;, &#123; $group: &#123; _id: '$name', user_id: &#123; $first: '$modifier' &#125; &#125; &#125;, ]); Mongoose聚合管道aggregate常用的操作有$project 、$match 、$group、$sort、$limit、$skip、$lookup 表关联 批量操作bulkWrite12345678910111213141516const template_list = await ctx.model.Template.aggregate([ &#123; $sort: &#123; create_time: -1 &#125; &#125;, &#123; $group: &#123; _id: '$name', template_id: &#123; $first: '$_id' &#125;, label: &#123; $first: '$label' &#125; &#125; &#125;, ]); const update_value = []; template_list.forEach(item =&gt; &#123; if (!item.label) &#123; update_value.push(&#123; updateOne: &#123; filter: &#123; _id: item.template_id &#125;, update: &#123; label: '' &#125;, &#125;, &#125;); &#125; &#125;); await ctx.model.Template.bulkWrite(update_value); 可以进行一系列批量增加、删除、更新等操作。 mongoose还有非常多的方法可以提供给我的灵活使用，我们在使用的时候可以结合业务逻辑选择合适的方法来提高我们操作数据库的效率。在我们使用它之前可以认真的阅读官方文档","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yolindeng.gitee.io/myblog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://yolindeng.gitee.io/myblog/tags/mongoDB/"}]},{"title":"egg.js+mongoose实现二级评论","slug":"egg-js-mongoose实现二级评论","date":"2021-05-21T02:57:33.000Z","updated":"2021-05-21T02:58:54.227Z","comments":true,"path":"2021/05/21/egg-js-mongoose实现二级评论/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/egg-js-mongoose%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA/","excerpt":"","text":"1、首先我们先在model目录下新建comment.js文件，这里使用egg-mongoose进行配置表以及字段，这里关键需要parent_id作为父级字段，若默认为0则是第一级评论，如果为id，则是二级评论。 12345678910111213141516171819202122232425262728'use strict';/** * @description: Mongoose comment Schema, */module.exports = app =&gt; &#123; const mongoose = app.mongoose; const Schema = mongoose.Schema; const CommentSchema = new Schema(&#123; from: &#123; /* 评论人id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, to: &#123; /* 被评论人id */ type: Schema.Types.ObjectId, ref: 'User', &#125;, content: &#123; type: String &#125;, /* 内容 */ create_time: &#123; type: String &#125;, /* 评论时间 */ book: &#123; /* 书籍id */ type: Schema.Types.ObjectId, ref: 'Book', &#125;, parent_id: &#123; type: String, required: true, default: 0 &#125; /* 父级 */ &#125;); return mongoose.model('Comment', CommentSchema);&#125;; 2、在controller 目录下新建comment.js 用于编写 评论相关的控制器方法，这里我定义了新增评论和查询评论，使用egg-validate进行请求参数验证如下： 123456789101112131415161718192021222324252627282930313233343536373839'use strict';const Controller = require('egg').Controller;// 定义新增评论请求参数规则const createCommentRule = &#123; from: 'string', to: &#123; type: 'string', required: false, &#125;, content: 'string', book: 'string', parentId: &#123; type: 'string', required: false, &#125;,&#125;// 定义查询评论请求参数规则const findCommentRule = &#123; book: 'string', page: 'string', pageSize: 'string'&#125;class CommentController extends Controller &#123; async create() &#123; const &#123; ctx &#125; = this; ctx.validate(createCommentRule, ctx.request.body); const result = await this.ctx.service.comment.createComment(ctx.request.body); ctx.body = result; &#125; async find() &#123; const &#123; ctx &#125; = this; ctx.validate(findCommentRule, ctx.query); const result = await this.ctx.service.comment.findComment(ctx.query); ctx.body = result; &#125;&#125;module.exports = CommentController; 在对应的控制器方法调用service层里面的方法，在service的方法进行数据库操作与逻辑处理。 3、在service目录下新建comment.js用于编写评论相关service方法。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081'use strict';/** * @description: 评论相关Service */const Service = require('egg').Service;const mongoose = require('mongoose');const dayjs = require('dayjs');module.exports = app =&gt; &#123; class CommentService extends Service &#123; /** * 新增评论 * @param &#123;Object&#125; data 包括评论人id，被评论人id，书籍id， 评论父级id，评论内容 */ async createComment(data) &#123; const &#123; from, to, content, book, parentId &#125; = data; const result = await this.ctx.model.Comment.create(&#123; from, to, content, book, parent_id: parentId ? mongoose.Types.ObjectId(parentId) : 0, create_time: dayjs().unix(), &#125;); return result ? app.config.msg.CREARE_SUCCESS : app.config.msg.CREARE_ERR; &#125; /** * 查询评论 * @param &#123;Object&#125; data 包括书籍id，页码，页数 */ async findComment(data) &#123; const &#123; book, page, pageSize &#125; = data const totalNum = await this.ctx.model.Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: 0 &#125;).countDocuments(); const oneList = await this.ctx.model.Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: 0 &#125;) .populate(&#123; path: 'from', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .populate(&#123; path: 'to', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .sort(&#123; create_time: 1&#125;) .skip((parseInt(page) - 1) * parseInt(pageSize)) .limit(parseInt(pageSize)).lean(); const Comment = this.ctx.model.Comment var promises = oneList.map(item =&gt; &#123; return Comment.find(&#123; book: mongoose.Types.ObjectId(book), parent_id: item._id &#125;) .populate(&#123; path: 'from', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .populate(&#123; path: 'to', select: &#123; name: 1, image: 1, _id: 1 &#125; &#125;) .sort(&#123; create_time: 1&#125;) .select('-__v').lean() &#125;); var list = await Promise.all(promises) oneList.forEach(item =&gt; &#123; item.items = [] list.forEach(code =&gt; &#123; if (code.length &gt; 0 &amp;&amp; item._id == code[0].parent_id) &#123; item.items = code &#125; &#125;) &#125;) return oneList ? &#123; bean: &#123; records: oneList, current: page, size: oneList.length, total: totalNum, &#125;, ...app.config.msg.GET_SUCCESS &#125; : app.config.msg.GET_ERR; &#125; &#125; return CommentService;&#125;; 注：首先我们需要查询一级评论的分页数据，然后用map遍历一级评论列表，返回一个promises数组，数组的每一项是查询该一级评论下的所有二级评论，我这里没有进行分页，也可以加上分页。使用Promise.all异步执行所有的查询函数，完成后的结果赋值为list，最后遍历一级评论列表与二级评论列表，当一级评论id 等于 二级评论列表中parent_id时候 给当前一级评论列表增加 items属性用于存放它的二级评论。 最后在router.js中定义接口路径与请求类型，如下： 1234// 新建评论router.post('/api/comment/create', controller.comment.create);// 查询评论router.get('/api/comment/find', controller.comment.find);","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yolindeng.gitee.io/myblog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://yolindeng.gitee.io/myblog/tags/mongoDB/"}]},{"title":"项目使用axios拦截器封装api","slug":"项目使用axios拦截器封装api","date":"2021-05-21T02:55:08.000Z","updated":"2021-05-21T02:58:16.365Z","comments":true,"path":"2021/05/21/项目使用axios拦截器封装api/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B0%81%E8%A3%85api/","excerpt":"","text":"在api目录下新建一个http.js，实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import Qs from 'qs'import axios from 'axios'import store from '@/store'import * as utils from '@/utils' //工具类import &#123; Toast &#125; from 'mand-mobile'const instance = axios.create(&#123; baseURL: '', // 后端接口根目录 message: true&#125;)// 错误控制const errorHandle = (status, message) =&gt; &#123; switch (status) &#123; case 401: // store.dispatch('logout') break case 403: break case 404: break default: Toast.failed(message) &#125;&#125;// axios请求拦截器/* 拦截器一般做什么？ 1. 修改请求头的一些配置项 2. 给请求的过程添加一些请求的图标 3. 给请求添加参数 */instance .interceptors .request .use(config =&gt; &#123; const token = utils.env !== 'dev' ? store.state.auth.token : '' token &amp;&amp; (config.headers.common.token = token) if (config.method === 'post' &amp;&amp; config.data) &#123; if (Object.prototype.toString.call(config.data) !== '[object FormData]') &#123; config.data = Qs.stringify(config.data) &#125; config.headers.common['Content-Type'] = 'multipart/form-data' &#125; return config &#125;, error =&gt; &#123; return Promise.reject(error) &#125;)// 响应拦截器，接受响应接口后的统一处理instance .interceptors .response .use(response =&gt; &#123; response.success = response.data.success if (response.config.message) &#123; if (!response.success) &#123; response.data.message &amp;&amp; Toast.failed(response.data.message) &#125; else &#123; response.config.method === 'post' &amp;&amp; Toast.succeed(response.data.message || '操作成功') &#125; &#125; return response &#125;, error =&gt; &#123; const &#123; response &#125; = error response ? errorHandle(response.status, response.data.message || '网络连接失败，请稍后重试！') : Toast.info('网络连接失败，请稍后重试！') return Promise.reject(error) &#125;)export const createAPI = (url, method, params, config = &#123;&#125;) =&gt; &#123; if (method === 'get') &#123; config.params = params &#125; else &#123; config.data = params &#125; return instance(&#123; url, method, ...config &#125;)&#125;export default instance 配置接口方式：在api目录下新建个index.jsimport { createAPI } from &#39;./http&#39; 123export default &#123; wxOuth: params =&gt; createAPI('/wechat/getOauthUrl', 'get', params)&#125; 最后在我们的vue组件中引入即可 import * as api from &#39;@/api&#39;调用方式为： api.wxOuth(params).then(res=&gt; {}).catch(err =&gt; {})","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]},{"title":"web端的微信支付可分为JSAPI与H5","slug":"web端的微信支付可分为JSAPI与H5","date":"2021-05-21T02:44:02.000Z","updated":"2021-05-21T02:53:41.403Z","comments":true,"path":"2021/05/21/web端的微信支付可分为JSAPI与H5/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2021/05/21/web%E7%AB%AF%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%AF%E5%88%86%E4%B8%BAJSAPI%E4%B8%8EH5/","excerpt":"","text":"web端的微信支付可分为JSAPI与H5JSAPI使用场景为微信内部，而H5支付则是使用在非微信下的外部浏览器。 1.JSAPI在微信内部可以直接唤起微信浏览器的内置对象WeixinJSBridge废话不多说直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 调用后端接口拿到JSAPI支付所需参数，我在beforeRouteEnter的时候调用。api.apply.jsApiPay(obj).then(res =&gt; &#123; if (res.data.code === '0000') &#123; vm.params = res.data.bean &#125; else &#123; alert('微信支付调起失败！') &#125; &#125;).catch(err =&gt; &#123; alert(err) &#125;)// 点击支付时候调用if (typeof WeixinJSBridge === 'undefined') &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', this.onBridgeReady(this.params), false) &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', this.onBridgeReady(this.params)) document.attachEvent('onWeixinJSBridgeReady', this.onBridgeReady(this.params)) &#125; &#125; else &#123; this.onBridgeReady(this.params) &#125;onBridgeReady (params) &#123; const that = this WeixinJSBridge.invoke( 'getBrandWCPayRequest', &#123; appId: params.appId, // 公众号名称，由商户传入 timeStamp: params.timeStamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: params.nonceStr, // 支付签名随机串，不长于 32 位 package: params.prepay_id, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*） signType: params.signType, // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: params.paySign // 支付签名 &#125;, function (res) &#123; if (res.err_msg === 'get_brand_wcpay_request:ok') &#123; that.queryOrder() // 这里是查询订单是否支付完成，然后执行成功和失败的业务逻辑 &#125; else if (res.err_msg === 'get_brand_wcpay_request:fail') &#123; alert('支付失败！') &#125; &#125; ) &#125;, 在微信支付的回调函数中，当res.err_msg 为get_brand_wcpay_request:ok 时，支付状态不一定准确，因此需要调用后端的查询订单接口，查询是否支付完成，然后再执行相应的逻辑。 2、H5支付h5相对简单，前端只需要跳转到后端返回的链接即可 1234567891011api.apply.h5Pay(&#123; title: '' orderNum: '', expireMinute: 10, redirectUrl: `$&#123;window.location.origin&#125;/pay/card?orderId=$&#123;vm.orderId&#125;` &#125;).then(res =&gt; &#123; vm.h5PayUrl = res.data.bean // 查询订单 &#125;).catch(err =&gt; &#123; alert(err) &#125;) 第一步，请求后端接口，需要传支付的标题，订单号，支付时间，重定向链接。 第二部，们只需要点击支付按钮时候跳转至后端返回链接即可。window.location.href = this.h5PayUrl需要注意的是H5支付查询订单需要用户去手动触发，因此需要增加一个确定订单的弹层。如图：查询订单是否支付成功与JSAPI一致~","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"微信体系","slug":"微信体系","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB/"}]},{"title":"前端日常开发常用技巧与方法","slug":"前端日常开发常用技巧与方法","date":"2020-06-09T10:10:36.000Z","updated":"2022-05-17T07:37:36.584Z","comments":true,"path":"2020/06/09/前端日常开发常用技巧与方法/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2020/06/09/%E5%89%8D%E7%AB%AF%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/","excerpt":"","text":"CSS部分盒子边倾斜clip-path: polygon(12% 0, 100% 0, 100% 100%, 0 100%); 禁止点击事件/鼠标事件“穿透”123div * &#123; pointer-events: none; /*链接啊，点击事件啊，都没有效果了*/ &#125; 用来控制元素在移动设备上使用滚动回弹效果123.main&#123; -webkit-overflow-scrolling: touch;&#125; 可解决在IOS中使用overflow:auto 形成的滚动条，滚动不流畅的情况 文字渐变效果12345.text-gradient&#123; background-image: linear-gradient(135deg, deeppink, deepskyblue); -webkit-background-clip: text; color: transparent;&#125; css三角形12345678910111213#triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red;&#125; JS部分JavaScript中检测数组的方法(1)、typeof操作符 这种方法对一些常用的类型检查没有问题，但对array和null 都判断为object(2)、instanceof操作符 这个操作符是检测对象的原型链是否指向构造函数的prototype对象的(3)、对象的constructor属性 123const arr = []console.log(arr.constructor === Array) // true (4)、Object.prototype.toString 123const arr = []console.log(Object.prototype.toString.call(arr) === '[object Array]') // true (5)、Array.isArray() 常用的字符串操作 字符串转化toString() 字符串分隔split() 字符串替换replace() 获取长度length 查询子字符串 indexOf 返回指定位置的字符串或字符串编码 charAt charCodeAt 字符串匹配 match 字符串拼接concat 字符串的切割或提取slice() substring() substr() 字符串大小写转化 toLowerCase toUpperCase 字符串去空格 trim() 用来删除字符串前后的空格 其中第9中三者的区别如下：（1）slice(), 参数可以是负数，负数表示从字符串最后一个位置开始切割到对应结束位置（2）substring()，参数不可为负数，切割第一个位置到第二个位置的字符串（3）substr()， 参数不可为负数，第一个参数是开始位置，第二个参数为切割的长度字符串去重const str = ‘11122223333’const arr = str.split(‘’)const uniqueStr = […new Set(arr)].join(‘’) 常用的数组操作1、Array.map()此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组2、Array.forEach()此方法是将数组中的每个元素执行传进提供的函数，没有返回值，注意和map方法区分3、Array.filter()此方法是将满足条件的元素作为一个新数组返回4、Array.every()此方法将数组所有元素进行判断返回一个布尔值，如果所有元素都符合判断条件，则返回true，否则返回false5、Array.some()此方法将数组所有元素进行判断返回一个布尔值,如果有一个元素满足判断条件，则返回true，所有元素都不满足则返回false6、Array.reduce()此方法为所有元素调用返回函数7、Array.push()在数组最后面添加新元素8、Array.shift()删除数组第一个元素9、Array.pop()删除数组最后一个元素10、Array.unshift()在数组最前面增加元素11、Array.isArray()判断是否为一个数组12、Array.concat()数组拼接13、Array.toString()数组转化为字符串14、Array.join()数组转化为字符串，并用第一个参数作为连接符15、Array.splice(开始位置，删除个数，元素)####常用对象方法1、Object.assign()用于克隆，两个参数，将第二个对象分配到第一个中2、Object.is()用于判断两个值是否相同//注意，该函数与==运算符不同，不会强制转换任何类型， 应该更加类似于===，但值得注意的是它会将+0和-0视作不同值3、Object.keys()用于返回对象可枚举的属性和方法的名称，返回一个属性或方法名称的字符串数组。4、Object.defineProperty()劫持变量的set和get方法,将属性添加到对象，或修改现有属性的特性 12345var a = &#123;&#125;;Object.defineProperty(a, 'name', &#123; value : 'kong', enumerable : true //该属性是否可枚举&#125;) 5、Object.defineProperties()可添加多个属性,与Object.defineProperty()对应,6、isPrototypeOf 123function a()&#123;&#125; var b = new a();console.log(a.prototype.isPrototypeOf(b));//true 安卓监听可视区域变化，让输入框移动至可视区域123456789if (/Android/gi.test(navigator.userAgent)) &#123; window.addEventListener('resize', function () &#123; if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') &#123; window.setTimeout(function () &#123; document.activeElement.scrollIntoViewIfNeeded(); &#125;, 0); &#125; &#125;); &#125;; vue中平滑滚动到某个位置this.$refs.rule.scrollIntoView({ block: ‘start’, behavior: ‘smooth’ }) 好用的JavaSrcipt库与模块（包）日期时间处理库1、monent.js2、day.jsday相对于monent要轻量许多 高精度数学运算number-precision 123456NP.strip(num) // strip a number to nearest right numberNP.plus(num1, num2, num3, ...) // addition, num + num2 + num3, two numbers is required at least.NP.minus(num1, num2, num3, ...) // subtraction, num1 - num2 - num3NP.times(num1, num2, num3, ...) // multiplication, num1 * num2 * num3NP.divide(num1, num2, num3, ...) // division, num1 / num2 / num3NP.round(num, ratio) // round a number based on ratio 实用工具库Lodashlodash 是一个 JavaScript 实用工具库，提供一致性，及模块化、性能和配件等功能。Lodash 消除了处理数组的麻烦，从而简化了 JavaScript、 数字、对象、字符串等","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"css","slug":"css","permalink":"http://yolindeng.gitee.io/myblog/tags/css/"}]},{"title":"JS的数据类型及深浅拷贝介绍","slug":"JS的数据类型及深浅拷贝介绍","date":"2020-06-09T10:06:22.000Z","updated":"2021-05-20T09:25:44.542Z","comments":true,"path":"2020/06/09/JS的数据类型及深浅拷贝介绍/","link":"","permalink":"http://yolindeng.gitee.io/myblog/2020/06/09/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1、数据类型JS分为两种数据类型：基本数组类型： Number、String、Boolean、Null、Undefined、Symbol引用数组类型：Object(JS中除了基本数据类型，其他都是对象。例如数组、函数、正则表达式等) （1）基本数据类型（存放在栈中）基本数据类型是指直接存放在栈中的简单数据段，数据大小确定，内存k空间可分配，按值存放和访问注：栈(stack)和堆（heap）stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放 （2）引用数据类型（存放在堆内存中的对象）引用数据类型是存放在堆内存里的对象，而指向堆内存值的引用也就是指针是存在栈内存中的。 2、浅拷贝当我们使用对象拷贝时，如果属性是对象或者数组时，我们只是拷贝的数组或对象的引用地址，因此两者的属性值会指向同一个内存空间。实现数组的片浅拷贝使用concat、slice这个两个是技巧类，如何实现一个浅拷贝呢？简单的思路是遍历对象，把属性和属性值都放在一个新的对象中如下： 12345678910111213var shallowCopy = function(obj) &#123; // 只拷贝对象 if (typeof obj !== 'object') return; // 根据obj的类型判断是新建一个数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125;; // 遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125; &#125; return newObj;&#125; 12345let a = &#123; name: '123', obj: &#123; name: '456' &#125;&#125;const b = shallowCopy(a)b.obj.name = '666'console.log(b) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125;console.log(a) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125; 这样如果改变b中的对象，a中的对象也会同时改变。 3、深拷贝实现数组或对象的深拷贝，可以使用JSON.parse(JSON.stringify(obj))如何手写一个深度拷贝呢？思路是通过递归调用拷贝函数 12345678910var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return var newObj = obj instanceof Array ? [] : &#123;&#125; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key] &#125; &#125; return newObj&#125; 12345let a = &#123; name: '123', obj: &#123; name: '456' &#125;&#125;const b = deepCopy(a)b.obj.name = '666'console.log(b) // &#123; name: '123', obj: &#123; name: '666' &#125; &#125;console.log(a) // &#123; name: '123', obj: &#123; name: '456' &#125; &#125; 这样就实现了深度拷贝，当改变b中对象值时，a没有发生变化。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"}]}],"categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"框架原理","slug":"框架原理","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"},{"name":"日常开发","slug":"日常开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"},{"name":"后端开发","slug":"后端开发","permalink":"http://yolindeng.gitee.io/myblog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"typeScript","slug":"typeScript","permalink":"http://yolindeng.gitee.io/myblog/tags/typeScript/"},{"name":"css","slug":"css","permalink":"http://yolindeng.gitee.io/myblog/tags/css/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yolindeng.gitee.io/myblog/tags/javaScript/"},{"name":"vue","slug":"vue","permalink":"http://yolindeng.gitee.io/myblog/tags/vue/"},{"name":"基础知识","slug":"基础知识","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"react","slug":"react","permalink":"http://yolindeng.gitee.io/myblog/tags/react/"},{"name":"scss","slug":"scss","permalink":"http://yolindeng.gitee.io/myblog/tags/scss/"},{"name":"组件化","slug":"组件化","permalink":"http://yolindeng.gitee.io/myblog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"git","slug":"git","permalink":"http://yolindeng.gitee.io/myblog/tags/git/"},{"name":"node.js","slug":"node-js","permalink":"http://yolindeng.gitee.io/myblog/tags/node-js/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://yolindeng.gitee.io/myblog/tags/mongoDB/"},{"name":"微信体系","slug":"微信体系","permalink":"http://yolindeng.gitee.io/myblog/tags/%E5%BE%AE%E4%BF%A1%E4%BD%93%E7%B3%BB/"}]}