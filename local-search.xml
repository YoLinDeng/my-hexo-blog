<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>commonJs与ESModule的区别</title>
    <link href="/myblog/2021/11/02/commonJs%E4%B8%8EESModule%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/myblog/2021/11/02/commonJs%E4%B8%8EESModule%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>学习之前引出几个问题：</p><ul><li>Commonjs 和 Es Module 有什么区别 ？</li><li>Commonjs 如何解决的循环引用问题 ？</li><li>Es Module 如何解决循环引用问题 ？</li><li>exports 和 module.exports 有何不同？</li><li>require 模块查找机制 ？</li><li>import() 的动态引入？</li><li>Es Module 如何改变模块下的私有变量 ？</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>开发很容易存在全局污染和依赖管理混乱问题，所以就需要模块化来解决这两个问题，今天介绍的是前端模块化的两个重要方案，commonjs 和 ESModule</p><h3 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h3><p>commonjs的提出弥补了，前端模块化的空缺，nodejs借鉴了commonjs，实现了模块化管理。</p><p>目前commonjs广泛应用于以下几个场景：</p><ul><li>Node（commonjs在服务端的一个具体代表性实现）</li><li>Browserify（ commonjs 在浏览器中的一种实现）</li><li>wepack 打包工具对 CommonJS 的支持和转换</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>在commonjs中每个js文件就是一个单独的模块，称为module。</li><li>模块中包含commonjs的核心变量：exports、module.exports、require</li><li>exports 和 module.export可以用于导出模块中的内容</li><li>require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>每个模块文件上存在 module，exports，require三个变量，然而这三个变量是没有被定义的，但是我们可以在 Commonjs 规范下每一个 js 模块上直接使用它们</p><ul><li>module 记录当前模块信息。</li><li>require 引入模块的方法。</li><li>exports 当前模块导出的属性</li></ul><p>在编译的过程中，实际 Commonjs 对 js 的代码块进行了首尾包装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exports,require,module,__filename,__dirname</span>)</span>&#123;<br>   <span class="hljs-keyword">const</span> sayName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./hello.js'</span>)<br>    <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            name:sayName(),<br>            author:<span class="hljs-string">'YoLin'</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在 Commonjs 规范下模块中，会形成一个包装函数，我们写的代码将作为包装函数的执行上下文，使用的 require ，exports ，module 本质上是通过形参的方式传递到包装函数中的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">wrapper</span> (script) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'(function (exports, require, module, __filename, __dirname) &#123;'</span> + <br>        script +<br>     <span class="hljs-string">'\n&#125;)'</span><br>&#125;<br></code></pre></td></tr></table></figure><p>包装函数执行</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const modulefunction = <span class="hljs-keyword">wrapper</span>(`<br>  const sayName = require(<span class="hljs-string">'./hello.js'</span>)<br>    module.exports = <span class="hljs-keyword">function</span> say()&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-type">name</span>:sayName(),<br>            author:<span class="hljs-string">'YoLin'</span><br>        &#125;<br>    &#125;<br>`)<br></code></pre></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">runInThisContext(<span class="hljs-name">modulefunction</span>)(<span class="hljs-name">module</span>.exports, require, module, __filename, __dirname)<br></code></pre></td></tr></table></figure><p>在模块加载的时候，会通过 runInThisContext (可以理解成 eval ) 执行 modulefunction ，传入require ，exports ，module 等参数。最终我们写的 nodejs 文件就这么执行了。</p><h4 id="require-文件加载流程"><a href="#require-文件加载流程" class="headerlink" title="require 文件加载流程"></a>require 文件加载流程</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>、<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>) <span class="hljs-comment">// 核心模块</span><br><span class="hljs-number">2</span>、<span class="hljs-keyword">const</span> sayName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./sayName.js'</span>) <span class="hljs-comment">// 文件模块</span><br><span class="hljs-number">3</span>、<span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto-js'</span>) <span class="hljs-comment">// 第三方模块</span><br></code></pre></td></tr></table></figure><p>如上所示：require可以加载核心模块、文件模块、第三方自定义模块。<br>当 require 方法执行的时候，接收的唯一参数作为一个标识符 ，Commonjs 下对不同的标识符，处理流程不同，但是目的相同，都是找到对应的模块。</p><h4 id="require-加载标识符原则"><a href="#require-加载标识符原则" class="headerlink" title="require 加载标识符原则"></a>require 加载标识符原则</h4><p>nodejs中对标识符的处理原则</p><ul><li>对fs、http、path等标识符，会被作为核心模块</li><li>./和../作为相对路径的文件模块，/作为绝对路径的文件模块</li><li>非路径形式也非核心模块的模块，将作为自定义模块</li></ul><p><strong>核心模块的处理：</strong><br>核心模块的优先级仅次于缓存加载，在 Node 源码编译中，已被编译成二进制代码，所以加载核心模块，加载过程中速度最快。</p><p><strong>路径形式的文件模块处理：</strong><br>已 ./ ，../ 和 / 开始的标识符，会被当作文件模块处理。require() 方法会将路径转换成真实路径，并以真实路径作为索引，将编译后的结果缓存起来，第二次加载的时候会更快。</p><p><strong>自定义模块处理：</strong><br>自定义模块，一般指的是非核心的模块，它可能是一个文件或者一个包，它的查找会遵循以下原则：</p><ul><li>在当前目录下的 node_modules 目录查找。</li><li>如果没有，在父级目录的 node_modules 查找，如果没有在父级目录的父级目录的 node_modules 中查找</li><li>沿着路径向上递归，直到根目录下的 node_modules 目录。</li><li>在查找过程中，会找 package.json 下 main 属性指向的文件，如果没有  package.json ，在 node 环境下会以此查找 index.js ，index.json ，index.node。</li></ul><h3 id="require-模块引入与处理"><a href="#require-模块引入与处理" class="headerlink" title="require 模块引入与处理"></a>require 模块引入与处理</h3><p>CommonJS 模块同步加载并执行模块文件，CommonJS 模块在执行阶段分析模块依赖，采用深度优先遍历（depth-first traversal），执行顺序是父 -&gt; 子 -&gt; 父；</p><h4 id="require-加载原理"><a href="#require-加载原理" class="headerlink" title="require 加载原理"></a>require 加载原理</h4><p>过程：</p><ul><li><p>require 会接收一个参数——文件标识符，然后分析定位文件，分析过程我们上述已经讲到了，加下来会从 Module 上查找有没有缓存，如果有缓存，那么直接返回缓存的内容。</p></li><li><p>如果没有缓存，会创建一个 module 对象，缓存到 Module 上，然后执行文件，加载完文件，将 loaded 属性设置为 true ，然后返回 module.exports 对象。借此完成模块加载流程。</p></li><li><p>模块导出就是 return 这个变量的其实跟 a = b 赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址。</p></li><li><p>exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对 exports 进行赋值会导致 exports 操作的不再是 module.exports 的引用。</p></li></ul><h4 id="require-避免重复加载"><a href="#require-避免重复加载" class="headerlink" title="require 避免重复加载"></a>require 避免重复加载</h4><p>加载之后的文件的 module 会被缓存到 Module 上，<br>如果其他模块再次引入，则会直接读取缓存中的，无需再次执行模块</p><h4 id="require-避免循环引用"><a href="#require-避免循环引用" class="headerlink" title="require 避免循环引用"></a>require 避免循环引用</h4>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript知识点</title>
    <link href="/myblog/2021/11/02/typescript%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/myblog/2021/11/02/typescript%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="TypeScript基础学习"><a href="#TypeScript基础学习" class="headerlink" title="TypeScript基础学习"></a>TypeScript基础学习</h3><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">let</span> age: <span class="hljs-built_in">number</span> = <span class="hljs-number">20</span><br><br><span class="hljs-keyword">let</span> binaryNumber: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b1111</span> <span class="hljs-comment">// 支持二进制或八进制</span><br><br><span class="hljs-keyword">let</span> fistName: <span class="hljs-built_in">string</span> = <span class="hljs-string">'YoLinDeng'</span><br><br><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><br><span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span> = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 说明undefined和null类型是所以类型的子类型</span><br></code></pre></td></tr></table></figure><p><strong>null和undefined的区别</strong><br>null表示“没有对象”，即该处不该有值</p><ul><li>1）作为函数的参数，表示该函数的参数不是对象</li><li>2）作为对象原型链的终点</li></ul><p>undefined表示缺少值，就是此处应该有值，但是还没有定义</p><ul><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ul><h4 id="any类型和联合类型"><a href="#any类型和联合类型" class="headerlink" title="any类型和联合类型"></a>any类型和联合类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> notSure: <span class="hljs-built_in">any</span> = <span class="hljs-number">1</span><span class="hljs-comment">// 有明确类型的时候避免使用any类型，没有代码提示以及校验</span><br><br><span class="hljs-keyword">let</span> numberOrString: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> = <span class="hljs-number">123</span><br>numberOrString = <span class="hljs-string">'abc'</span><br></code></pre></td></tr></table></figure><h4 id="Array-和-Tuple（元组）"><a href="#Array-和-Tuple（元组）" class="headerlink" title="Array 和 Tuple（元组）"></a>Array 和 Tuple（元组）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义数组</span><br><span class="hljs-keyword">let</span> arrOfNumbers: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arr2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 定义元组,限定了一定数据类型的数组</span><br><span class="hljs-keyword">let</span> user: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'YoLinDeng'</span>, <span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><h4 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface(接口)"></a>interface(接口)</h4><ul><li>对对象的形状进行描述</li><li>对类进行抽象</li><li>Duck Typing(鸭子类型)</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml">interface <span class="hljs-title">Person</span> &#123;<br>    readonly <span class="hljs-attribute">id:</span><span class="hljs-string"> number</span>; <span class="hljs-comment">// 只读</span><br>    <span class="hljs-attribute">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: number; <span class="hljs-comment">// 可选</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attribute">yoLin</span>: <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-attribute">id:</span><span class="hljs-string"> 1,</span><br><span class="hljs-string">    name</span>: <span class="hljs-string">'YoLinDeng'</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数和类型推断"><a href="#函数和类型推断" class="headerlink" title="函数和类型推断"></a>函数和类型推断</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> z === <span class="hljs-string">'number'</span>) &#123;<br>        <span class="hljs-keyword">return</span> x + y + z<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y  <br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> z === <span class="hljs-string">'number'</span>) &#123;<br>        <span class="hljs-keyword">return</span> x + y + z<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y  <br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> add2 = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = add<br><br>当我们没有指定类型的时候，ts的complier会给我推断出一个类型<br></code></pre></td></tr></table></figure><h4 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h4><p>类(Class)：定义了一切事物的抽象特点<br>对象（Object）:类的实例<br>面向对象（OOP）:三大特征：封装，继承，多态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  name: string;<br>  <span class="hljs-keyword">constructor</span>(name: string) &#123;<br>    <span class="hljs-keyword">this</span>.name = name<br>  &#125;<br>  run() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span> is running`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> snake = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">'liLy'</span>)<br><span class="hljs-built_in">console</span>.log(snake.run())<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  bark() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span> is barking`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> xiaobao = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">'xiaobao'</span>)<br><span class="hljs-built_in">console</span>.log(xiaobao.run())<br><span class="hljs-built_in">console</span>.log(xiaobao.bark())<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(name) &#123;<br>    <span class="hljs-keyword">super</span>(name)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>  &#125;<br>  run() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Meow,<span class="hljs-subst">$&#123;<span class="hljs-keyword">super</span>.run()&#125;</span>`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> maomao = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">'maomao'</span>)<br><span class="hljs-built_in">console</span>.log(maomao.run())<br></code></pre></td></tr></table></figure><p>修饰符：public（公有的）、private（私有的）、<br>protected(只有自己和子类可以访问)、readonly（只读）、static（静态，不需要实例化，可以在类上直接调用）</p><p><strong>类和接口</strong>：<br>使用interface和implements抽象和验证类的属性和方法，对类的一部分内容进行抽象。<br>将特性提取成接口，使用implements来实现,像一种契约，定义和约束object的样子。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Radio</span> &#123;<br>  switchRadio(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Battery</span> &#123;<br>  checkBatteryStatus(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">RadioWithBattery</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Radio</span> &#123;<br>  checkBatteryStatus(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Car</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">RadioWithBattery</span> &#123;<br>  switchRadio() &#123;<br><br>  &#125;<br>  checkBatteryStatus() &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">CellPhone</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">RadioWithBattery</span> &#123;<br>  switchRadio() &#123;<br><br>  &#125;<br>  checkBatteryStatus() &#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Enum枚举"><a href="#Enum枚举" class="headerlink" title="Enum枚举"></a>Enum枚举</h4><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nsis">// 常量枚举, 提升性能，不会编译成js代码，只有常量值才可以进行常量枚举，计算值不行。<br>const enum Direction1 &#123;<br>  <span class="hljs-literal">left</span>,<br>  <span class="hljs-literal">right</span>,<br>  <span class="hljs-literal">top</span>,<br>  <span class="hljs-literal">bottom</span><br>&#125;<br>enum Direction2 &#123;<br>  <span class="hljs-literal">left</span> = <span class="hljs-string">'LEFT'</span>,<br>  <span class="hljs-literal">right</span> = <span class="hljs-string">'RIGHT'</span>,<br>  <span class="hljs-literal">top</span> = <span class="hljs-string">'TOP'</span>,<br>  <span class="hljs-literal">bottom</span> = <span class="hljs-string">'BOTTOM'</span><br>&#125;<br>console.log(Direction1.<span class="hljs-literal">left</span>)<br>console.log(Direction1[<span class="hljs-number">0</span>])<br>console.log(Direction2.<span class="hljs-literal">left</span> === <span class="hljs-string">'LEFT'</span>)<br></code></pre></td></tr></table></figure><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>在定义函数接口或类的时候，先不指定具体类型，在使用的时候才指定。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> arg<br>&#125;<br><span class="hljs-keyword">const</span> result1: <span class="hljs-built_in">number</span> = echo(<span class="hljs-number">123</span>)<br><span class="hljs-keyword">const</span> result2: <span class="hljs-built_in">string</span> = echo(<span class="hljs-string">'string'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">tuple: [T, U]</span>): [<span class="hljs-title">T</span>, <span class="hljs-title">U</span>] </span>&#123;<br>  <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">0</span>], tuple[<span class="hljs-number">1</span>]]<br>&#125;<br><br><span class="hljs-keyword">const</span> result3 =  swap([<span class="hljs-string">'string'</span>, <span class="hljs-number">123</span>])<br></code></pre></td></tr></table></figure><p><strong>约束泛型</strong><br>使用extends继承接口进行约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IWithLength &#123;<br>  length: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echoWithLength</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">IWithLength</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(arg.length)<br>  <span class="hljs-keyword">return</span> arg<br>&#125;<br><span class="hljs-keyword">const</span> str = echoWithLength(<span class="hljs-string">'str'</span>)<br><span class="hljs-keyword">const</span> obj = echoWithLength(&#123; length: <span class="hljs-number">10</span> &#125;)<br><span class="hljs-keyword">const</span> arr = echoWithLength([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p><strong>泛型在类中的使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">data</span> = []<br>  push(item: T) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.push(item)<br>  &#125;<br>  pop(): T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.shift()<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> queue = new Queue&lt;number&gt;()<br>queue.push(<span class="hljs-number">1</span>)<br>console.log(queue.pop().toFixed())<br></code></pre></td></tr></table></figure><p><strong>接口interface中使用泛型</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">KeyPair</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt; &#123;</span><br><span class="hljs-symbol">  key:</span> T;<br><span class="hljs-symbol">  value:</span> U;<br>&#125;<br>let <span class="hljs-string">kp1:</span> KeyPair&lt;number, string&gt; = &#123; <span class="hljs-string">key:</span> <span class="hljs-number">123</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'123'</span>&#125;<br>let <span class="hljs-string">kp2:</span> KeyPair&lt;string, number&gt; = &#123; <span class="hljs-string">key:</span> <span class="hljs-string">'str'</span>, <span class="hljs-string">value:</span> <span class="hljs-number">123</span>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型定义数组</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">let arr: Array&lt;number&gt; = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>interface描述函数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IPlus&lt;T&gt; &#123;<br>    (a: T, b: T): <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plus</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-keyword">const</span> a: IPlus&lt;<span class="hljs-built_in">number</span>&gt; = plus<br><span class="hljs-keyword">const</span> b: IPlus&lt;<span class="hljs-built_in">string</span>&gt; = connect<br></code></pre></td></tr></table></figure><h4 id="类型别名和类型断言"><a href="#类型别名和类型断言" class="headerlink" title="类型别名和类型断言"></a>类型别名和类型断言</h4><p>type aliases</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> PlusType = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-keyword">const</span> sum2: PlusType = sum<br><br><span class="hljs-comment">// 联合类型中使用类型别名</span><br><span class="hljs-keyword">type</span> NameResolver = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span><br><span class="hljs-keyword">type</span> NameOrResolver = <span class="hljs-built_in">string</span> | NameResolver<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">n: NameOrResolver</span>): <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">'string'</span>) &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>type assertion 断言</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">input: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> str = input <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span><br>    <span class="hljs-comment">// or</span><br>    &lt;<span class="hljs-built_in">string</span>&gt;input<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><p>创建.d.ts文件，例如jQuery.d.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> Jquery: <span class="hljs-function">(<span class="hljs-params">selector: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">any</span><br></code></pre></td></tr></table></figure><p>再tsconfig.json中写配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">"include"</span>: [<span class="hljs-string">"**/*"</span>] <span class="hljs-comment">//编译当前文件夹下的所有文件</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>div局中</title>
    <link href="/myblog/2021/06/23/div%E5%B1%80%E4%B8%AD/"/>
    <url>/myblog/2021/06/23/div%E5%B1%80%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="div居中的几种方法"><a href="#div居中的几种方法" class="headerlink" title="div居中的几种方法"></a>div居中的几种方法</h3><h4 id="使div水平垂直居中"><a href="#使div水平垂直居中" class="headerlink" title="使div水平垂直居中"></a>使div水平垂直居中</h4><h5 id="1、flex布局实现（已知元素宽度）"><a href="#1、flex布局实现（已知元素宽度）" class="headerlink" title="1、flex布局实现（已知元素宽度）"></a>1、flex布局实现（已知元素宽度）</h5><p>给父盒子设置：<br>display: flex;<br>justify-content: center;<br>align-items: center;</p><h5 id="2、position（已知元素宽度）"><a href="#2、position（已知元素宽度）" class="headerlink" title="2、position（已知元素宽度）"></a>2、position（已知元素宽度）</h5><p>父元素设置为：position: relative;<br>子元素设置为：position: absolute;<br>距上50%，据左50%，然后减去元素自身宽度的一半距离就可以实现</p><h5 id="3、position-transform-（未知宽度）"><a href="#3、position-transform-（未知宽度）" class="headerlink" title="3、position + transform （未知宽度）"></a>3、position + transform （未知宽度）</h5><p>父元素设置为：position: relative;<br>子元素设置为：position: absolute;<br>距上50%，据左50%，然后使用transform: translate(-50%,-50%);</p><h5 id="4、position（元素已知宽度）"><a href="#4、position（元素已知宽度）" class="headerlink" title="4、position（元素已知宽度）"></a>4、position（元素已知宽度）</h5><p>父元素设置为：position: relative;<br>子元素设置为：position: absolute;<br>left、right、bottom、top都为0，margin: auto;</p><p>如果子元素不设置宽度和高度，将会铺满整个父级(模态框)</p><h5 id="5-table-cell-布局实现"><a href="#5-table-cell-布局实现" class="headerlink" title="5. table-cell 布局实现"></a>5. table-cell 布局实现</h5><p>table 实现垂直居中，子集元素可以是块元素，也可以不是块元素</p><h4 id="使内容（文字，图片）水平垂直居中（table-cell-布局）"><a href="#使内容（文字，图片）水平垂直居中（table-cell-布局）" class="headerlink" title="使内容（文字，图片）水平垂直居中（table-cell 布局）"></a>使内容（文字，图片）水平垂直居中（table-cell 布局）</h4><p>行元素 text-align ：center；</p><p>块元素 ：margin ：0 auto；<br>text-align : center  给元素的父级加，可以使文本或者行级元素(例如：图片)水平居中<br>line-height : 值为元素的高度，可以使元素的文本内容垂直居中<br>margin: 0 auto 使用条件：父级元素宽度可有可无，子级元素必须使块元素，而且要有宽度（否则继承父级）</p><p>display：table-cell 会使元素表现的类似一个表格中的单元格td，利用这个特性可以实现文字的垂直居中效果。同时它也会破坏一些 CSS 属性，使用 table-cell 时最好不要与 float 以及 position: absolute 一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对margin值无反应，可以响 padding 的设置，表现几乎类似一个 td 元素。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css性能优化</title>
    <link href="/myblog/2021/06/23/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/myblog/2021/06/23/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<ol><li>合并css文件，如果页面加载10个css文件,每个文件1k，那么也要比只加载一个100k的css文件慢。</li><li>减少css嵌套，最好不要嵌套三层以上。</li><li>不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。</li><li>建立公共样式类，把相同样式提取出来作为公共类使用。</li><li>减少通配符*或者类似[hidden=”true”]这类选择器的使用，挨个查找所有…这性能能好吗？</li><li>巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。</li><li>拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。</li><li>不用css表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。</li><li>少用css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。</li><li>cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。</li><li>善后工作，css压缩(在线压缩工具 YUI Compressor)</li><li>GZIP压缩，是一种流行的文件压缩算法</li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="避免使用-import，外部的css文件中使用-import会使得页面在加载时增加额外的延迟。"><a href="#避免使用-import，外部的css文件中使用-import会使得页面在加载时增加额外的延迟。" class="headerlink" title="避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。"></a>避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。</h4><h4 id="避免过分重排"><a href="#避免过分重排" class="headerlink" title="避免过分重排"></a>避免过分重排</h4><p>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow</p><p>导致reflow发生的情况</p><ol><li>改变窗口的大小  </li><li>改变文字的大小</li><li>添加 删除样式表</li><li>内容的改变 输入框输入内容也会</li><li>伪类的激活</li><li>操作class属性</li><li>脚本操作dom js改变css类</li><li>计算offsetWidth和offsetHeight</li><li>设置style属性</li><li>改变元素的内外边距 </li></ol><p>常见重排元素</p><ol><li>大小有关的 width,height,padding,margin,border-width,border,min-height</li><li>布局有关的 display,top,position,float,left,right,bottom</li><li>字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align</li><li>隐藏有关的 overflow,overflow-x,overflow-y<h4 id="repaint-重绘"><a href="#repaint-重绘" class="headerlink" title="repaint 重绘"></a>repaint 重绘</h4></li></ol><p>当一个元素的外观被改变，但是布局没有改变的情况<br>当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素<br>常见的重绘元素</p><ul><li>颜色 color,background</li><li>边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width</li><li>背景有关 background,backgound-image,background-position,background-repeat,background-size</li></ul><h4 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h4><p>性能优化时最容易想到的，也是最常见的方法，就是文件压缩，这一方案往往效果显著<br>文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具webpack，gulp/grunt，rollup，压缩之后能够明显减少，可以大大降低浏览器的加载时间。</p><h4 id="去除无用CSS"><a href="#去除无用CSS" class="headerlink" title="去除无用CSS"></a>去除无用CSS</h4><ul><li>不同元素或者其他情况下的重复代码，</li><li>整个页面内没有生效的CSS代码</li></ul><h4 id="有选择地使用选择器"><a href="#有选择地使用选择器" class="headerlink" title="有选择地使用选择器"></a>有选择地使用选择器</h4><ol><li>保持简单，不要使用嵌套过多过于复杂的选择器</li><li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</li><li>不要使用类选择器和ID选择器修饰元素标签，如：h3#markdown-content，这一多此一举，还会降低效率</li><li>不要为了追求速度而放弃可读性和可维护性</li></ol><h4 id="减少使用昂贵的属性"><a href="#减少使用昂贵的属性" class="headerlink" title="减少使用昂贵的属性"></a>减少使用昂贵的属性</h4><h4 id="硬件加速的好坏"><a href="#硬件加速的好坏" class="headerlink" title="硬件加速的好坏"></a>硬件加速的好坏</h4>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>圣杯布局和双飞翼布局</title>
    <link href="/myblog/2021/06/23/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <url>/myblog/2021/06/23/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>通俗的来说就是左右两栏固定宽度，中间部分自适应的三栏布局。</p><h3 id="两者本质"><a href="#两者本质" class="headerlink" title="两者本质"></a>两者本质</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><ul><li>首先把left、middle、right都放出来</li><li>给它们三个设置上float: left, 脱离文档流；</li><li>一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档</li><li>left、right设置上各自的宽度<br>middle设置width: 100%;</li></ul><p>接下来比较重要了：</p><ul><li>给left、middle、right设置position: relative;</li><li>left设置 left: -leftWidth, right设置 right: -rightWidth;</li><li>container设置padding: 0, rightWidth, 0, leftWidth;</li></ul><p>因为不这样设置 会遮挡middle的内容</p><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>双飞翼布局和圣杯布局很类似，不过是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。</p><ul><li>首先把left、middle、right都放出来, middle中增加inner</li><li>给它们三个设置上float: left, 脱离文档流；</li><li>一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档</li><li>left、right设置上各自的宽度</li><li>middle设置width: 100%;<br>接下来与圣杯布局不一样的地方：</li><li>left设置 margin-left: -100%, right设置 right: -rightWidth;</li><li>container设置padding: 0, rightWidth, 0, leftWidth;</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js时间循环机制</title>
    <link href="/myblog/2021/06/23/js%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/myblog/2021/06/23/js%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="浏览器环境下js引擎的事件循环机制"><a href="#浏览器环境下js引擎的事件循环机制" class="headerlink" title="浏览器环境下js引擎的事件循环机制"></a>浏览器环境下js引擎的事件循环机制</h4><h5 id="1-执行栈与事件队列"><a href="#1-执行栈与事件队列" class="headerlink" title="1.执行栈与事件队列"></a>1.执行栈与事件队列</h5><p>基本类型以及对象的指针存放在栈中，对象的值存放在堆内存中。<br><strong>执行栈</strong>：js引擎在解析一段代码的时候，将其中的同步代码按照执行顺序加入到执行栈中，然后从头开始执行。当执行完毕后，当前函数的执行上下文会从栈顶弹层出，随之函数及其执行上下文会被销毁，其中的变量会被浏览器回收。<br><strong>事件队列</strong>：<br>js引擎遇到异步事件后并不会一直等待其返回结果，而会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列中，被放入的事件不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于空闲时，主线程会取查找事件队列是否又任务，如果有，那么主线程会取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码。如此反复，这样就形成一个无限循环。这个过程被称为事件循环（event loop）</p><h4 id="2-macro-task与micro-task"><a href="#2-macro-task与micro-task" class="headerlink" title="2.macro task与micro task"></a>2.macro task与micro task</h4><p>不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p><p>以下事件属于宏任务：</p><ul><li>setInterval()</li><li>setTimeout()  </li></ul><p>以下事件属于微任务:  </p><ul><li>new Promise()</li><li>new MutaionObserver()</li></ul><p>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</p><h4 id="node环境下的事件循环机制"><a href="#node环境下的事件循环机制" class="headerlink" title="node环境下的事件循环机制"></a>node环境下的事件循环机制</h4><p>node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。</p><h5 id="事件循环各阶段详解"><a href="#事件循环各阶段详解" class="headerlink" title="事件循环各阶段详解"></a>事件循环各阶段详解</h5><p>node中的事件循环的顺序：<br>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p><ul><li>timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。</li><li>I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。</li><li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li><li>poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。</li><li>check: setImmediate()的回调会在这个阶段执行。</li><li>close callbacks: 例如socket.on(‘close’, …)这种close事件的回调。</li></ul><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。  </p><p>有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。</p><h5 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a>check阶段</h5><p>check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。</p><h5 id="close阶段"><a href="#close阶段" class="headerlink" title="close阶段"></a>close阶段</h5><p>当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。</p><h5 id="timer阶段"><a href="#timer阶段" class="headerlink" title="timer阶段"></a>timer阶段</h5><p>这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。</p><h5 id="I-O-callback阶段"><a href="#I-O-callback阶段" class="headerlink" title="I/O callback阶段"></a>I/O callback阶段</h5><p>这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。</p><h4 id="process-nextTick-setTimeout与setImmediate的区别与使用场景"><a href="#process-nextTick-setTimeout与setImmediate的区别与使用场景" class="headerlink" title="process.nextTick,setTimeout与setImmediate的区别与使用场景"></a>process.nextTick,setTimeout与setImmediate的区别与使用场景</h4><p>在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate</p><h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。</p><h5 id="setTimeout-和setImmediate"><a href="#setTimeout-和setImmediate" class="headerlink" title="setTimeout()和setImmediate()"></a>setTimeout()和setImmediate()</h5><p>setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。</p><p>setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v8垃圾回收机制</title>
    <link href="/myblog/2021/06/23/v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/myblog/2021/06/23/v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1、为何需要垃圾回收"><a href="#1、为何需要垃圾回收" class="headerlink" title="1、为何需要垃圾回收"></a>1、为何需要垃圾回收</h3><p>在v8引擎执行js代码的过程中，当遇到函数的情况时，会为其创建一个函数执行的上下文，并添加到调用堆栈的栈顶，函数的作用域中包含了该函数中声明的所以变量，当函数执行完毕后，对面的执行上下文会从栈顶弹出，函数的作用域随之销毁，其包括的所以变量也会统一释放并自动回收。如果不回收，必然导致内存暴增，引发内存泄漏。</p><h3 id="2、v8引擎的内存限制"><a href="#2、v8引擎的内存限制" class="headerlink" title="2、v8引擎的内存限制"></a>2、v8引擎的内存限制</h3><p>由于js的单线程机制和垃圾回收机制，<br>V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个G内存这样的场景</p><h3 id="3、v8的垃圾回收策略"><a href="#3、v8的垃圾回收策略" class="headerlink" title="3、v8的垃圾回收策略"></a>3、v8的垃圾回收策略</h3><p>V8的垃圾回收策略主要是基于<strong>分代式垃圾回收机制</strong>，其根据<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p><h4 id="v8的内存结构"><a href="#v8的内存结构" class="headerlink" title="v8的内存结构"></a>v8的内存结构</h4><p>主要了解新生代和老生代</p><ul><li>新生代(new_space)：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。（Scavenge算法）</li><li>老生代(old_space)：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。Mark-Sweep(标记清除)和Mark-Compact(标记整理)</li></ul><h3 id="4、如何避免内存泄漏"><a href="#4、如何避免内存泄漏" class="headerlink" title="4、如何避免内存泄漏"></a>4、如何避免内存泄漏</h3><ul><li>尽可能少地创建全局变量</li><li>手动清除定时器</li><li>少用闭包</li><li>清除DOM引用</li><li>弱引用<br>在ES6中为我们新增了两个有效的数据结构WeakMap和WeakSet，就是为了解决内存泄漏的问题而诞生的。其表示弱引用</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this、call、apply、bind</title>
    <link href="/myblog/2021/06/17/this%E3%80%81call%E3%80%81apply%E3%80%81bind/"/>
    <url>/myblog/2021/06/17/this%E3%80%81call%E3%80%81apply%E3%80%81bind/</url>
    
    <content type="html"><![CDATA[<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在JavaScript中，this的指向是调用时决定的，而不是创建时决定的，<strong>this永远指向最后调用它的那个对象。</strong></p><h4 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h4><p>在全局上下文中，this指全局对象</p><ul><li>this等价于window对象</li><li>var === this. === window.<br>在浏览器里面this等价于window对象，如果你声明一些全局变量，这些变量都会作为this的属性。</li></ul><h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><p>在函数内部，this的值取决于函数被调用的方式</p><ul><li><p>直接调用<br>this指向window，严格模式下是undefined</p></li><li><p>作为对象的一个方法<br>当this所在的函数被以obj.fn()形式调用时，指向obj</p></li><li><p>call()、apply，(不同点：前者传的是若干个参数列表，后者是包含多个参数的数组)<br>this指向绑定的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Person = &#123;<br>    name: <span class="hljs-string">'YoLin'</span>,<br>    age: <span class="hljs-number">25</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params">job</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>，今天&#123;this.age&#125;,职业是<span class="hljs-subst">$&#123;job&#125;</span>`</span>)<br>&#125;<br>say.call(Person, <span class="hljs-string">"FE"</span>)<br>say.apply(Person, [<span class="hljs-string">"FE"</span>])<br></code></pre></td></tr></table></figure></li><li><p>bind()<br>this将永久地被绑定到了bind的第一个参数。<br>与call、apply相似，接受若干个参数列表并返回一个新的函数，不同的是需要我们手动调用。</p></li><li><p>箭头函数<br>所有的箭头函数都没有自己的this，都指向外层。<br>箭头函数会捕获其所在上下文的this值，作为自己的this值。<br>箭头函数的 this 始终指向函数定义时的 this，而非执行时<br>箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p></li><li><p>作为一个构造函数（new实例化一个对象）<br>this被绑定到正在构造的新对象。<br>通过构造函数创建一个对象其实执行这样几个步骤：<br>1、创建新对象<br>2、将this指向这个对象<br>3、给对象赋值（属性、方法）<br>4、返回this  </p><h4 id="new的过程"><a href="#new的过程" class="headerlink" title="new的过程"></a>new的过程</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">myFunction</span>(<span class="hljs-string">"Li"</span>,<span class="hljs-string">"Cherry"</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-type">myFunction</span>&#123;<br>    <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>    obj.__proto__ = myFunction.prototype;<br>    <span class="hljs-keyword">var</span> result = myFunction.call(obj,<span class="hljs-string">"Li"</span>,<span class="hljs-string">"Cherry"</span>);<br>    <span class="hljs-keyword">return</span> typeof result === <span class="hljs-string">'obj'</span>? result : <span class="hljs-type">obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、创建一个空对象 obj;<br>2、将新创建的空对象的隐式原型指向其构造函数的显示原型。<br>3、使用 call 改变 this 的指向<br>4、如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果要判断一个函数的this绑定，就需要找到这个函数的直接调用位置。然后可以顺序按照下面四条规则来判断this的绑定对象：</p><ul><li>由new调用：绑定到新创建的对象</li><li>由call或apply、bind调用：绑定到指定的对象</li><li>由上下文对象调用：绑定到上下文对象</li><li>默认：全局对象<br>注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定this，继承外层函数调用的this绑定。</li></ul><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>手写call的思路：</p><ul><li>1、将函数设置为对象的一个属性</li><li>2、执行该函数</li><li>3、删除该函数<br>通过Arguments 对象中取值，然后放入一个数组里<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 以上个例子为例，此时的arguments为：</span><br><span class="hljs-comment">// arguments = &#123;</span><br><span class="hljs-comment">//      0: foo,</span><br><span class="hljs-comment">//      1: 'kevin',</span><br><span class="hljs-comment">//      2: 18,</span><br><span class="hljs-comment">//      length: 3</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 因为arguments是类数组对象，所以可以用for循环</span><br><span class="hljs-keyword">var</span> args = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span> = arguments.length; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;<br>    args.push(<span class="hljs-string">'arguments['</span> + i + <span class="hljs-string">']'</span>);<br>&#125;<br><br><span class="hljs-comment">// 执行后 args为 [foo, 'kevin', 18]</span><br></code></pre></td></tr></table></figure>把这个参数数组放到要执行的函数的参数里面去  </li></ul><p>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-string">'context.fn('</span> + args +<span class="hljs-string">')'</span>)</span></span><br></code></pre></td></tr></table></figure><p>这里 args 会自动调用 Array.toString() 这个方法。<br>最终代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.call2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span>;<br>    context.fn = <span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">var</span> args = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>        args.push(<span class="hljs-string">'arguments['</span> + i + <span class="hljs-string">']'</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">'context.fn('</span> + args +<span class="hljs-string">')'</span>);<br><br>    <span class="hljs-keyword">delete</span> context.fn<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>apply与call类似，只是传入的参数是一个数组</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Function.prototype.<span class="hljs-built_in">apply</span> = function (<span class="hljs-built_in">context</span>, arr) &#123;<br>    <span class="hljs-built_in">var</span> <span class="hljs-built_in">context</span> = Object(<span class="hljs-built_in">context</span>) || window;<br>    <span class="hljs-built_in">context</span>.fn = this;<br><br>    <span class="hljs-built_in">var</span> result;<br>    <span class="hljs-keyword">if</span> (!arr) &#123;<br>        result = <span class="hljs-built_in">context</span>.fn();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">var</span> <span class="hljs-built_in">args</span> = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> i = <span class="hljs-number">0</span>, len = arr.<span class="hljs-built_in">length</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-built_in">args</span>.<span class="hljs-built_in">push</span>('arr[' + i + ']');<br>        &#125;<br>        result = <span class="hljs-built_in">eval</span>('<span class="hljs-built_in">context</span>.fn(' + <span class="hljs-built_in">args</span> + ')')<br>    &#125;<br><br>    <span class="hljs-built_in">delete</span> <span class="hljs-built_in">context</span>.fn<br>    <span class="hljs-built_in">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><ul><li>返回一个函数</li><li>可以传入参数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Function.prototype.bind - what is trying to be bound is not callable'</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>,<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span><br>    <span class="hljs-keyword">var</span> fNOP = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> fBound = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> bingArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>    self.apply(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> fNOP.prototype ? <span class="hljs-keyword">this</span> : context, args.concat(bindArgs))<br>    &#125;<br>    fNOP.prototype = <span class="hljs-keyword">this</span>.prototype<br>    fBound.prototype = <span class="hljs-keyword">new</span> fNOP()<br>    <span class="hljs-keyword">return</span> fBound<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h4><p>具备与数组特征类似的对象  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">let <span class="hljs-built_in">array</span>Like = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,<br>    length: <span class="hljs-number">3</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>获取 DOM 节点的方法<br>方法中的 arguments 都是类数组<br>可以通过for循环进行遍历,类数组无法使用 forEach、splice、push 等数组原型链上的方法</p><p>call的使用场景：</p><ul><li>对象的继承<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent.call(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>借用方法<br>类数组想用使用数组的方法<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">let</span> domNodes = <span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.slice.call(arr)<br></code></pre></td></tr></table></figure>apply的一些妙用:<br>1、获取数组中数字最大最小值<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.max</span><span class="hljs-selector-class">.apply</span>(<span class="hljs-selector-tag">null</span>, <span class="hljs-selector-tag">arr</span>)<br><span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.min</span><span class="hljs-selector-class">.apply</span>(<span class="hljs-selector-tag">null</span>, <span class="hljs-selector-tag">arr</span>)<br></code></pre></td></tr></table></figure>2、合并两个数组<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Array</span><span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.push</span><span class="hljs-selector-class">.apply</span>(<span class="hljs-selector-tag">arr1</span>,<span class="hljs-selector-tag">arr2</span>)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>instanceof、typeof</title>
    <link href="/myblog/2021/06/17/instanceof%E3%80%81typeof/"/>
    <url>/myblog/2021/06/17/instanceof%E3%80%81typeof/</url>
    
    <content type="html"><![CDATA[<h3 id="typeof实现原理"><a href="#typeof实现原理" class="headerlink" title="typeof实现原理"></a>typeof实现原理</h3><p>typeof用于判断变量的类型，可以判断number、string、object、undefined、function、boolean、symbol 这7种类型，判断不是object类型的时候可以比较清楚的告诉我们具体是哪一类，但不能明确告诉我们object是哪一种。<br>由于js底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息。</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数  </li></ul><p>对于null和undefined比较特殊，<br>undefined： 用 −2^30 整数来表示<br>null：所以机器码都为0，因此通过typeof判断时候会被当作object<br>使用instanceof判断的话，null直接判断为不是object。<br>因此在使用typeof判断变量类型的时候，最好用来判断基本数据类型（包括symbol），避免对null的判断</p><p>还有一个不错的判断类型的方法，Object.prototype.toString,可以利用这个方法来对一个变量类型来进行比较准确的判断</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">1</span>) // "[object Number]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-string">'hi'</span>) // "[object String]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&#123;a:<span class="hljs-string">'hi'</span>&#125;) // "[object Object]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([<span class="hljs-number">1</span>,<span class="hljs-string">'a'</span>]) // "[object Array]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>) // "[object Boolean]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(() =&gt; &#123;&#125;) // "[object Function]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>) // "[object Null]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined) // "[object Undefined]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(Symbol(<span class="hljs-number">1</span>)) // "[object Symbol]"<br></code></pre></td></tr></table></figure><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>instanceof主要的作用是判断一个实例是否属于某种类型，也可以判断一个实例是否是其父类型或者祖先类型的实例。</p><p>instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。</p><p>因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p><p>总结：<br>简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型、继承</title>
    <link href="/myblog/2021/06/17/%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/"/>
    <url>/myblog/2021/06/17/%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在规范里，prototype 被定义为：给其它对象提供共享属性的对象。 </p><p>JS是通过函数来模拟类，当我们创建一个函数的时候，js会给这个函数自动添加prototype属性，值是一个包含constructor属性的对象，不是空对象。当我们把函数当成构造函数通过new关键词调用的时候，js会帮我们创建该构造函数的实例，实例继承构造函数prototype的所以属性和方法（实例通过设置自己的<code>__proto__</code>指向构造函数的prototype来实现继承）</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor属性也是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数。</p><h4 id="所有-object-对象都有一个隐式引用"><a href="#所有-object-对象都有一个隐式引用" class="headerlink" title="所有 object 对象都有一个隐式引用"></a>所有 object 对象都有一个隐式引用</h4><p>什么叫隐式引用？<br>所谓的隐式，是指不是由开发者(你和我)亲自创建/操作。<code>__proto__</code></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>原型链的概念，仅仅是在原型这个概念基础上所作的直接推论。<br>既然 prototype 只是恰好作为另一个对象的隐式引用的普通对象。那么，它也是对象，也符合一个对象的基本特征。<br>也就是说，prototype 对象也有自己的隐式引用，有自己的 prototype 对象。</p><p>如此，构成了对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>所谓的原型继承，就是指设置某个对象为另一个对象的原型（塞进该对象的隐式引用位置）。<br>在 JavaScript 中，有两类原型继承的方式：显式继承和隐式继承。</p><h4 id="显式原型继承"><a href="#显式原型继承" class="headerlink" title="显式原型继承"></a>显式原型继承</h4><p>所谓的显式原型继承，就是指我们亲自将某个对象设置为另一个对象的原型。<br>通过调用<strong>Object.setPrototypeOf</strong> 方法  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">obj1</span>, <span class="hljs-params">obj2</span>)</span> <span class="hljs-comment">//将obj2设置为obj1的原型对象</span><br></code></pre></td></tr></table></figure><p>还有另一种途径。即是通过 Object.create 方法，直接继承另一个对象。<br><strong>Object.setPropertyOf 和 Object.create 的差别在于：</strong>  </p><ul><li>1）Object.setPropertyOf，给我两个对象，我把其中一个设置为另一个的原型。  </li><li>2）Object.create，给我一个对象，它将作为我创建的新对象的原型。</li></ul><h4 id="隐式原型继承"><a href="#隐式原型继承" class="headerlink" title="隐式原型继承"></a>隐式原型继承</h4><p>通过 new 去创建 user 对象，可以通过 user.consturctor 访问到它的构造函数。</p><h4 id="函数对象和普通对象"><a href="#函数对象和普通对象" class="headerlink" title="函数对象和普通对象"></a>函数对象和普通对象</h4><p>通过字面量或构造函数new的方式来创建对象</p><p>将对象分为函数对象和普通对象，所谓的函数对象，其实就是 JavaScript 的用函数来模拟的类实现</p><h3 id="ES5-中的继承实现方法"><a href="#ES5-中的继承实现方法" class="headerlink" title="ES5 中的继承实现方法"></a>ES5 中的继承实现方法</h3><h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h4><h5 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = myFunction(<span class="hljs-string">'Deng'</span>, <span class="hljs-string">'yongling'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> obj = &#123;&#125;<br>    obj.__proto__ = myFunction.prototype<br>    <span class="hljs-keyword">var</span> result = myFunction.call(obj, ...arguments)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个空对象</li><li>将该对象的隐式原型指向构造函数的显式原型</li><li>使用call改变this指向</li><li>如果无返回值或者返回值是非对象，则返回这个新建的obj，否则直接返回该返回值对象。</li></ul><hr><h3 id="继承的多种方式和优缺点"><a href="#继承的多种方式和优缺点" class="headerlink" title="继承的多种方式和优缺点"></a>继承的多种方式和优缺点</h3><h4 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'YoLin'</span><br>&#125;<br>Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;<br><br>Child.prototype = <span class="hljs-keyword">new</span> Parent()<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child()<br>child.getName() <span class="hljs-comment">// YoLin</span><br></code></pre></td></tr></table></figure><p>存在问题：</p><ul><li>1、引用类型得属性被所有实例共享</li><li>2、在创建Child实例得时候，不能向Parent传参</li></ul><h4 id="2、借用构造函数（经典继承）"><a href="#2、借用构造函数（经典继承）" class="headerlink" title="2、借用构造函数（经典继承）"></a>2、借用构造函数（经典继承）</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">funtion Parent() &#123;<br>    <span class="hljs-built_in">this</span>.names = [<span class="hljs-string">'YoLin'</span>,<span class="hljs-string">'Deng'</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span></span>() &#123;<br>    Parent.call(<span class="hljs-built_in">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Child</span>()<br>child1.names.push(<span class="hljs-string">'123'</span>)<span class="hljs-comment">// ['YoLin', 'Deng', '123']</span><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Child</span>()<br>child2.names <span class="hljs-comment">// ['YoLin', 'Deng']</span><br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>1、避免了引用类型的属性被所有实例共享</li><li>2、可以在Child中向Parent传参<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span><span class="hljs-params">(name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span><span class="hljs-params">(name)</span> </span>&#123;<br>    Parent.call(<span class="hljs-keyword">this</span>, name)<br>&#125;<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'YoLin'</span>)<br>child.name <span class="hljs-comment">// YoLin</span><br></code></pre></td></tr></table></figure>缺点：<br>方法都在构造函数中定义，每次创建实例都会创建一遍方法</li></ul><h4 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h4><p>原型链继承和经典继承的结合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue, green'</span>]<br>&#125;<br>Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    Parent.call(<span class="hljs-keyword">this</span>, name)<br>    <span class="hljs-keyword">this</span>.age = age<br>&#125;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent()<br>Child.prototype.constructor = Child<br></code></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数继承的优点，是javascript中最常用的继承模式</p><p>组合继承最大的缺点是会调用两次父构造函数。</p><ul><li>一次是设置子类型实例的原型时</li><li>一次在创建子类型实例的时候</li></ul><h4 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Obj(<span class="hljs-params">o</span>)</span> &#123;<br>    funtion <span class="hljs-constructor">F()</span> &#123;&#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype = o<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。<br>缺点：包含引用类型的属性始终都会共享相应的值</p><h4 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span><span class="hljs-params">(o)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">clone</span> = Object.create(o)<br>    <span class="hljs-keyword">clone</span>.sayName = fucntion() &#123;<br>        console.log(<span class="hljs-string">'hi'</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">clone</span><br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h4 id="6、寄生组合式继承"><a href="#6、寄生组合式继承" class="headerlink" title="6、寄生组合式继承"></a>6、寄生组合式继承</h4><p>为了避免重复调用父构造函数</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>];<br>&#125;<br><br>Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>    Parent.call(<span class="hljs-keyword">this</span>, name);<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    F.prototype = o<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prototpe</span>(<span class="hljs-params">child, parent</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> prototype = object(<span class="hljs-built_in">parent</span>.prototype)<br>    prototype.constructor = child<br>    child.prototype = prototype<br>&#125;<br>prototype(Child, Parent)<br></code></pre></td></tr></table></figure><p>将组合式继承中的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Parent()</span><br></code></pre></td></tr></table></figure><p>变成调用object重新创建一个新的Parent的原型实例，并赋值给Child的prototype来实现</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">prototype</span><span class="hljs-params">(Child, Parent)</span></span><br></code></pre></td></tr></table></figure><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js执行上下文、作用域链、闭包</title>
    <link href="/myblog/2021/05/25/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/"/>
    <url>/myblog/2021/05/25/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>是评估和执行 JavaScript 代码的环境的抽象概念，每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。<br>执行上下文包括：</p><ul><li>1、全局执行上下文  </li><li>2、函数执行上下文  </li><li>3、Eval函数执行上下文  </li></ul><p>三个重要属性</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>用来存储代码运行时创建的所有上下文（先进后出）<br>但javascript引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文，并压入到当前的执行栈中，每当遇到函数调用会创建一个新的执行上下文并压入到栈顶，当函数执行结束时，执行上下文会从栈中弹出，控制流程到下一个执行上下文，直到所以代码执行完毕后从当前栈中移除全局执行上下文。<br><strong>创建执行上下文有两个阶段</strong></p><p>1) 创建阶段 </p><ul><li>This 绑定</li><li>创建词法环境组件<br>内部有两个组件：  (1) 环境记录器和 (2) 一个外部环境的引用。<br>两种类型：全局和函数（this不同，外部环境引用不同）<br>在全局环境中，环境记录器是对象环境记录器。<br>在函数环境中，环境记录器是声明式环境记录器。</li><li>创建变量环境组件<br>2) 执行阶段</li></ul><p>在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。</p><p>词法（静态）作用域与动态作用域区别<br>javascript采用的是词法作用域，函数的作用域在函数定义的时候就确定了<br>动态作用域的函数作用域取决于函数调用的时候。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>每一个执行上下文都会分配一个变量对象(variable object)，变量对象的属性由 变量(variable) 和 函数声明(function declaration) 构成。在函数上下文情况下，参数列表(parameter list)也会被加入到变量对象(variable object)中作为属性。变量对象与当前作用域息息相关。不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。<br>有一点特殊就是只有 函数声明(function declaration) 会被加入到变量对象中，而 <strong>函数表达式(function expression)</strong>则不会。看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">// function</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">// function</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> _a) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h3><p>当函数被激活，那么一个活动对象(activation object)就会被创建并且分配给执行上下文。活动对象由特殊对象 arguments 初始化而成。随后，他被当做变量对象(variable object)用于变量初始化</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>由多个执行上下文的变量对象构成的链表就叫做作用域链。<br>以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p><ul><li>函数创建<br>函数的作用域在函数定义的时候就决定了。</li></ul><p>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><ul><li>函数激活<br>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端<br>Scope = [AO].concat([[Scope]]);</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束<br>闭包的外部作用域是在其定义的时候已决定，而不是执行的时候（词法作用域）</p><p>当外部作用域执行完后，内部函数还存活时，闭包才真正发挥它的作用<br>譬如一下几种情况：</p><ul><li>异步任务（定时器，事件处理，ajax请求中的回调）</li><li>被外部函数作为返回结果，或者返回结果对象中引用该内部函数</li></ul><p><strong>闭包与封装性</strong><br>封装意味着信息隐藏<br>函数与私有状态：通过闭包，可以创建拥有私有状态的函数，闭包使得状态被封装起来。</p><p>工厂模式与私有原型对象<br>我们可以通过闭包，只用创建原型对象一次，也能够被所有 Todo 函数调用所公用，并且保证其私有性。示例如下：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">let</span> Todo = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTodoFactory</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> todoPrototype = &#123;<br>    <span class="hljs-attribute">toString</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.userName + <span class="hljs-string">": "</span> + <span class="hljs-keyword">this</span>.title;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">todo</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> newTodo = <span class="hljs-built_in">Object</span>.create(todoPrototype);<br>    <span class="hljs-built_in">Object</span>.assign(newTodo, todo);<br>    <span class="hljs-keyword">return</span> newTodo;<br>  &#125;<br>&#125;)();<br><span class="hljs-keyword">let</span> todo = Todo(&#123;<span class="hljs-attribute">id :</span><span class="hljs-string"> 1, title</span>: <span class="hljs-string">"This is a title"</span>, <span class="hljs-attribute">userName</span>: <span class="hljs-string">"Cristi"</span>, <span class="hljs-attribute">completed</span>: <span class="hljs-literal">false</span> &#125;);<br></code></pre></td></tr></table></figure><p>工厂模式与私有构造函数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let Todo = (<span class="hljs-keyword">function</span> createTodoFactory()&#123;<br> <span class="hljs-keyword">function</span> Todo(spec)&#123;<br>   <span class="hljs-keyword">Object</span>.assign(this, spec);<br> &#125;<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(spec)&#123;<br>   let todo = <span class="hljs-built_in">new</span> Todo(spec);<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">freeze</span>(todo);<br> &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>这里，Todo() 工厂函数就是一个闭包。通过它，不管是否使用 new ，我们都可以创建不可变对象，原型对象也只用创建一次，并且它是私有的。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>在 Javascript中，局部变量会随着函数的执行完毕而被销毁，除非还有指向他们的引用。当闭包本身也被垃圾回收之后，这些闭包中的私有状态随后也会被垃圾回收。通常我们可以通过切断闭包的引用来达到这一目的。<br>将闭包函数置为 null</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>闭包是一个可以访问外部作用域中变量的内部函数。</p><p>这些被引用的变量直到闭包被销毁时才会被销毁。</p><p>闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。</p><p>可以通过闭包来达到封装性。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的ES6优化升级内容</title>
    <link href="/myblog/2021/05/24/%E5%B8%B8%E7%94%A8%E7%9A%84ES6%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E5%86%85%E5%AE%B9/"/>
    <url>/myblog/2021/05/24/%E5%B8%B8%E7%94%A8%E7%9A%84ES6%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="一、let-和-const-命令"><a href="#一、let-和-const-命令" class="headerlink" title="一、let 和 const 命令"></a>一、let 和 const 命令</h4><p>let具有自己的块级作用域，且修复了var声明带来的变量提升问题。使用const声明常量，是不可更改的。  </p><h4 id="二、对String字符串类型做的常用升级优化"><a href="#二、对String字符串类型做的常用升级优化" class="headerlink" title="二、对String字符串类型做的常用升级优化"></a>二、对String字符串类型做的常用升级优化</h4><ul><li>模板字符串（``）</li><li>在String的原型上新增includes()方法，取代传统的indexof，语义更清晰</li><li>另外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法  </li><li><em>1、startsWith: str.startsWith(searchString[, position])*</em><br>以什么开头，接受两个参数，一个是要搜索的字符串，第二个是搜索开始的位置，默认为0，找到为true，否则为fasle。  </li><li><em>2、endsWith：str.endsWith(searchString[, length])*</em><br>以什么结尾，第一个参数也是搜索的字符串，第二个则是被搜索的字符串长度，默认是str.length  </li><li><em>3、padStart:str.padStart(targetLength [, padString])*</em><br>在原字符串开头填充字符串，直到达到目标长度<br>第一个参数是目标长度，第二个参数是填充字符串，如果字符串太长，则保留左侧  </li><li><em>4、padEnd：str.padEnd(targetLength [, padString])*</em><br>在原字符串末尾填充指定字符串，直到目标长度。与padStart参数相同  </li><li><em>5、str.repeat(count)*</em><br>repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。<br>count：重复的次数，表示新构造的字符串中重复了多少遍原字符串。<h4 id="三、对Array数组类型做的常用升级优化"><a href="#三、对Array数组类型做的常用升级优化" class="headerlink" title="三、对Array数组类型做的常用升级优化"></a>三、对Array数组类型做的常用升级优化</h4></li><li>数组解构赋值:<br><code>let [a,b,c] = [1,2,3]</code></li><li>扩展运算符:  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = [...a]<br></code></pre></td></tr></table></figure></li><li>find和findIndex方法<br>1、find：数组实例find方法，它可接收一个回调函数作为参数，该回调函数可传3个参数分别是当前值、当前位置、原数组。<br><code>[1,2,3].find((value, index, arr) =&gt; value &gt; 1)</code><br>执行结果会返回符合条件的首个成员，若没有符合的则返回undefined<br>2、findIndex：与find使用方法类似，不同的是返回符合条件成员位置，没有符合则返回-1</li></ul><p>这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-literal">NaN</span>].indexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br>[<span class="hljs-literal">NaN</span>].find(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, x)) <span class="hljs-comment">// NaN</span><br>[<span class="hljs-literal">NaN</span>].findIndex(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, x)) <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><ul><li><p>copyWithin<br>方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。<br><code>arr.copyWithin(target[, start[, end]])</code><br>可传如三个参数：<br>1、target表示目标位置，从这个位置开始复制并替换，如果是负数则从尾部开始算，如果target大于arr.length，则不拷贝，若target在start后面，那么复制序列会被修改以符合arr.length<br>2、start表示开始复制元素的起始位置，负数表示从末尾开始算,若不穿start，将从0开始复制<br>3、end表示开始复制元素的结束位置，会拷贝到这个位置，但不包括它，如果是负数，则是从末尾开始算。若不传将复制到数组结尾（默认是arr.length）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">例子</span><br><span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">].copyWithin(-2)</span><br><span class="hljs-string">//</span> <span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">2</span><span class="hljs-string">]</span><br><br><span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">].copyWithin(0,</span> <span class="hljs-number">3</span><span class="hljs-string">)</span><br><span class="hljs-string">//</span> <span class="hljs-string">[4,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">]</span><br><br><span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">].copyWithin(0,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><br><span class="hljs-string">//</span> <span class="hljs-string">[4,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">]</span><br><br><span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">].copyWithin(-2,</span> <span class="hljs-number">-3</span><span class="hljs-string">,</span> <span class="hljs-number">-1</span><span class="hljs-string">)</span><br><span class="hljs-string">//</span> <span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">]</span><br></code></pre></td></tr></table></figure></li><li><p>includes<br><code>arr.includes(valueToFind[, fromIndex])</code></p></li></ul><p>valueToFind: 需要查找的元素<br>fromIndex：从fromIndex索引开始查找，可以是负数，表示从末尾开始<br>若着找到对应元素，则返回true，否则返回false<br><code>[1,2,3].includes(1) // true</code></p><ul><li><p>fill<br>fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<br><code>arr.fill(value[, start[, end]])</code><br>value: 填充的值<br>start：起始位置索引，默认为0<br>end：结束位置所以，默认是数组长度<br><code>[1,2,3].fill(6,1) // [1, 6, 6]</code></p></li><li><p>flat<br>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回<br><code>var newArray = arr.flat([depth])</code><br>depth: 指定要提取嵌套数组的结构深度，默认值为 1 </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]].flat(<span class="hljs-number">2</span>) <span class="hljs-comment">// [1,2,3,4,5,6]</span><br></code></pre></td></tr></table></figure><h4 id="四、对Number数字类型做的常用升级优化"><a href="#四、对Number数字类型做的常用升级优化" class="headerlink" title="四、对Number数字类型做的常用升级优化"></a>四、对Number数字类型做的常用升级优化</h4></li><li><p>Number原型上新增isFinite(),isNaN()方法，用于优化传统的全局isFinite(), isNaN()，会把非数值类型转为Number类型再判断，而ES6中不会转化类型。分别用于检测数值是否有限、是否是NaN。</p></li><li><p>Math对象上新增Math.cbrt()，trunc()，hypot()等科学计数法运算方法</p></li></ul><h4 id="五、对Object类型做的常用升级优化"><a href="#五、对Object类型做的常用升级优化" class="headerlink" title="五、对Object类型做的常用升级优化"></a>五、对Object类型做的常用升级优化</h4><ul><li>对象属性变量式声明</li></ul><p>如果对象属性的值的一个变量，且键值相同，则可省略值的书写</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let &#123; <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,c &#125; = obj<br>let newObj = &#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>:b&#125; <span class="hljs-comment">//等价于下面的式子</span><br>let newObj = &#123;<span class="hljs-selector-tag">a</span>,b&#125;<br></code></pre></td></tr></table></figure><p>方法也可以简化为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span></span>() &#123;<br>        <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对象解构赋值<br><code>let { a,b } = { a:1, b:2 }</code>  </li><li>对象扩展运算符  </li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let &#123; <span class="hljs-selector-tag">a</span>,..<span class="hljs-selector-class">.rest</span> &#125; = &#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span>:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span> &#125; <span class="hljs-comment">// rest = &#123; b:2, c:3 &#125;</span><br>let obj1 = &#123; <span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span>:<span class="hljs-number">2</span> &#125;<br>let obj2 = &#123;..<span class="hljs-selector-class">.obj1</span>, c: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>super 关键字：ES6在Class类里新增了类似this的关键字super。同this总是指向当前函数所在的对象不同，super关键字总是指向当前函数所在对象的原型对象。</li><li>在Object原型上新增is()方法，修复了‘===’ 无法比较NaN</li><li>新增assign()方法，用于对象新增属性或者对象的合并。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">let obj1 = &#123;a: <span class="hljs-number">1</span>, b:<span class="hljs-number">2</span> &#125;<br>let obj2 = &#123;c: <span class="hljs-number">3</span>, d: <span class="hljs-number">4</span> &#125;<br>Object.assign(obj1, obj2) <span class="hljs-comment">/// &#123; a:1,b:2,c:3,d:4 &#125;</span><br></code></pre></td></tr></table></figure><code>Object.assign(target, ...sources)</code><br>将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。<br>target是目标对象，将sources源对象分配到该目标对象中。</li><li>在Object原型上新增了getPrototypeOf()和setPrototypeOf()方法，用来获取或设置当前对象的prototype对象。</li><li>在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组。</li></ul><h4 id="六、对Function函数类型做的常用升级优化"><a href="#六、对Function函数类型做的常用升级优化" class="headerlink" title="六、对Function函数类型做的常用升级优化"></a>六、对Function函数类型做的常用升级优化</h4><ul><li>箭头函数<br>改变了this的指向，为函数定义时所在的对象，而不是执行时。</li><li>函数默认赋值<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">(a = 1, b)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://mp.weixin.qq.com/s/EzDHz5_SVUmyD0YUIAC9cw" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Proxy实现简易的vue双向数据绑定</title>
    <link href="/myblog/2021/05/21/%E4%BD%BF%E7%94%A8Proxy%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/myblog/2021/05/21/%E4%BD%BF%E7%94%A8Proxy%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>在实现vue双向数据绑定之前，先了解Proxy相关的概念和用法</p><h3 id="proxy概念"><a href="#proxy概念" class="headerlink" title="proxy概念"></a>proxy概念</h3><p><code>Proxy</code> 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。</p><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul><li>handle<br>包含捕捉器（trap）的占位符对象，可译为处理器对象</li><li>traps<br>提供属性访问的方法。这类似于操作系统中捕获器的概念。</li><li>target<br>被 Proxy 代理虚拟化的对象。<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><code>const p = new Proxy(target, handler)</code></li><li>target<br>要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li>handle<br>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li></ul><h3 id="使用proxy实现数据劫持"><a href="#使用proxy实现数据劫持" class="headerlink" title="使用proxy实现数据劫持"></a>使用proxy实现数据劫持</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = &#123;<br>    name: YoLinDeng,<br>    height: <span class="hljs-string">'176cm'</span><br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, &#123;<br>    <span class="hljs-keyword">get</span>(target, prop) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments)<br>    &#125;,<br>    <span class="hljs-keyword">set</span>(target, prop, newValue) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(...arguments)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="关于vue中数据响应式的原理"><a href="#关于vue中数据响应式的原理" class="headerlink" title="关于vue中数据响应式的原理"></a>关于vue中数据响应式的原理</h3><h4 id="对数据进行侦测"><a href="#对数据进行侦测" class="headerlink" title="对数据进行侦测"></a>对数据进行侦测</h4><ul><li>在vue2.X中，实现一个<code>observe</code>类，对于对象数据，通过<code>Object.defineProperty</code>来劫持对象的属性，实现<code>getter</code>和<code>setter</code>方法，这样就可以在getter的时候知道谁（订阅者）读取了数据，即谁依赖了当前的数据，将它通过<code>Dep类</code>（订阅器）收集统一管理，在setter的时候调用Dep类中的<code>notify</code>方法通知所以相关的订阅者进行更新视图。如果对象的属性也是一个对象的话，则需要递归调用<code>observe</code>进行处理。</li><li>对于数组则需要另外处理，通过实现一个拦截器类，并将它挂载到数组数据的原型上，当调用<code>push/pop/shift/unshift/splice/sort/reverse</code>修改数组数据时候，相当于调用的是拦截器中重新定义的方法，这样在拦截器中就可以侦测到数据改变了，并通知订阅者更新视图。</li><li>vue3中使用Proxy替代了Object.defineProperty，优点在于可以直接监听对象而非属性、可以直接监听数组的变化、多达13种拦截方法。缺点是兼容性还不够好。Proxy作为新标准将受到浏览器厂商重点持续的性能优化。<h4 id="对模板字符串进行编译"><a href="#对模板字符串进行编译" class="headerlink" title="对模板字符串进行编译"></a>对模板字符串进行编译</h4></li><li>实现Compile解析器类，将<code>template</code>中的模板字符串通过正则等方式进行处理生成对应的ast（抽象语法树），通过调用定义的不同钩子函数进行处理，包括开始标签（<code>start</code>）并判断是否自闭和以及解析属性、结束标签（<code>end</code>）、文本（<code>chars</code>）、注释（<code>comment</code>）</li><li>将通过html解析与文本解析的ast进行优化处理，在静态节点上打标记，为后面<code>dom-diff</code>算法中性能优化使用，即在对比前后vnode的时候会跳过静态节点不作对比。</li><li>最后根据处理好的ast生产<code>render</code>函数，在组件挂载的时候调用<code>render</code>函数就可以得到虚拟dom。<h4 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h4></li><li>vnode的类型包括注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点，<code>VNode</code>可以描述的多种节点类型，它们本质上都是<code>VNode</code>类的实例，只是在实例化的时候传入的属性参数不同而已。</li><li>通过将模板字符串编译生成虚拟dom并缓存起来，当数据发生变化时，通过对比变化前后虚拟dom，以变化后的虚拟dom为基准，更新旧的虚拟dom，使它和新的一样。把dom-diff过程叫做<code>patch</code>的过程，其主要做了三件事，分别是创建/删除/更新节点。</li><li>对于子节点的更新策略，vue中为了避免双重循环数据量大时候造成时间复杂度高带来的性能问题，而选择先从子节点数组中4个特殊位置进行对比，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。如果四种情况都没有找到相同的节点，则再通过循环方式查找。<h3 id="实现简易的vue双向数据绑定"><a href="#实现简易的vue双向数据绑定" class="headerlink" title="实现简易的vue双向数据绑定"></a>实现简易的vue双向数据绑定</h3>vue的双向数据绑定主要是指，数据变化更新视图变化，视图变化更新数据。</li><li><em>实现代码如下*</em><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width= , initial-scale=1.0"</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"myVue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;name&#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"test"</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;test&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    let vm = new vue(&#123;</span><br><span class="xml">      el: '#app',</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        name: 'YoLinDeng',</span><br><span class="xml">        message: '打篮球',</span><br><span class="xml">        test: '双向绑定数据'</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;)</span><br><span class="xml">    // console.log(vm._data)</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">vue</span> <span class="hljs-title">extends</span> <span class="hljs-title">EventTarget</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(option) &#123;<br>    <span class="hljs-keyword">super</span>()<br>    <span class="hljs-keyword">this</span>.option = option<br>    <span class="hljs-keyword">this</span>._data = <span class="hljs-keyword">this</span>.option.<span class="hljs-keyword">data</span><br>    <span class="hljs-keyword">this</span>.el = document.querySelector(<span class="hljs-keyword">this</span>.option.el)<br>    <span class="hljs-keyword">this</span>.compileNode(<span class="hljs-keyword">this</span>.el)<br>    <span class="hljs-keyword">this</span>.observe(<span class="hljs-keyword">this</span>._data)<br>  &#125;<br>  <span class="hljs-comment">// 实现监听器方法</span><br>  observe(<span class="hljs-keyword">data</span>) &#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>    <span class="hljs-comment">// 使用proxy代理，劫持数据</span><br>    <span class="hljs-keyword">this</span>._data = new Proxy(<span class="hljs-keyword">data</span>, &#123;<br>      <span class="hljs-keyword">set</span>(target, prop, newValue) &#123;<br>        <span class="hljs-comment">// 自定义事件</span><br>        let event = new CustomEvent(prop, &#123;<br>          detail: newValue<br>        &#125;)<br>        <span class="hljs-comment">// 发布自定义事件</span><br>        context.dispatchEvent(event) <br>        <span class="hljs-keyword">return</span> Reflect.<span class="hljs-keyword">set</span>(...arguments)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 实现解析器方法，解析模板</span><br>  compileNode(el) &#123;<br>    let child = el.childNodes<br>    let childArr = [...child]<br>    childArr.forEach(node =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span>) &#123;<br>        let text = node.textContent<br>        let reg = /\&#123;\&#123;\s*([^\s\&#123;\&#125;]+)\s*\&#125;\&#125;/g<br>        <span class="hljs-keyword">if</span> (reg.test(text)) &#123;<br>          let $<span class="hljs-number">1</span> = RegExp.$<span class="hljs-number">1</span><br>          <span class="hljs-keyword">this</span>._data[$<span class="hljs-number">1</span>] &amp;&amp; (node.textContent = text.replace(reg, <span class="hljs-keyword">this</span>._data[$<span class="hljs-number">1</span>]))<br>          <span class="hljs-comment">// 监听数据更改事件</span><br>          <span class="hljs-keyword">this</span>.addEventListener($<span class="hljs-number">1</span>, e =&gt; &#123;<br>            node.textContent = text.replace(reg, e.detail)<br>          &#125;)<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果是元素节点</span><br>        let attr = node.attributes<br>        <span class="hljs-comment">// 判断属性中是否含有v-model</span><br>        <span class="hljs-keyword">if</span> (attr.hasOwnProperty(<span class="hljs-string">'v-model'</span>)) &#123;<br>          let keyName = attr[<span class="hljs-string">'v-model'</span>].nodeValue<br>          node.value = <span class="hljs-keyword">this</span>._data[keyName]<br>          node.addEventListener(<span class="hljs-string">'input'</span>, e =&gt; &#123;<br>            <span class="hljs-keyword">this</span>._data[keyName] = node.value<br>          &#125;)<br>        &#125;<br>        <span class="hljs-comment">// 递归调用解析器方法</span><br>        <span class="hljs-keyword">this</span>.compileNode(node)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写防抖与节流函数</title>
    <link href="/myblog/2021/05/21/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/"/>
    <url>/myblog/2021/05/21/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>我们经常会绑定一些持续触发的事件，比如resize、scroll、mousemove等等，如果事件调用无限制，会加重浏览器负担，导致用户体验差，我们可以使用debounce(防抖)和throttle(节流)的方式来减少频繁的调用，同时也不会影响实际的效果。</p><h3 id="防抖的概念"><a href="#防抖的概念" class="headerlink" title="防抖的概念"></a>防抖的概念</h3><p>触发事件后n秒后才执行函数，如果在n秒内触发了事件，则会重新计算函数执行时间<br>防抖函数可以分为立即执行，和非立即执行两个版本</p><ul><li><p>非立即执行版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        timer &amp;&amp; clearTimeout(timer)<br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            fn.apply(context, args)   <br>        &#125;, wait)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此函数一开始不会马上执行，而是等到用户操作结束之后等待wait秒后才执行，如果在wait之内用户又触发了事件，则会重新计算</p></li><li><p>立即执行版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">const</span> now = !timer<br>        timer &amp;&amp; clearTimeout(timer)<br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, wait)<br>        <span class="hljs-keyword">if</span> (now) &#123;<br>            fn.apply(<span class="hljs-keyword">this</span>, args)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>立即执行就是触发事件后马上先执行一次，直到用户停止执行事件等待wait秒后再执行一次</p></li></ul><p>我们可以将两种版本合并成一种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc </span>函数防抖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>wait 延迟执行毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>immediate true 表立即执行，false 表示非立即执行</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait, immediate</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        timer &amp;&amp; clearTimeout(timer)<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-keyword">const</span> now = !timer<br>            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                timer = <span class="hljs-literal">null</span><br>            &#125;, wait)<br>            now &amp;&amp; fn.apply(context, args)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                fn.apply(context, args)<br>            &#125;, wait)<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="节流的概念"><a href="#节流的概念" class="headerlink" title="节流的概念"></a>节流的概念</h3><p>连续触发事件但在n秒内只执行一次函数<br>对于节流有时间戳和定时器两种版本</p><ul><li>时间戳版本<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> prev = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now()<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>            fn.apply(context, args)<br>            prev = now<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在持续触发事件的过程中，函数会立即执行，用户在wait秒内不管执行多少次事件，都会等待wait秒后再执行。</li><li>定时器版本<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (!timer) &#123;<br>            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                timer = <span class="hljs-literal">null</span><br>                fn.apply(context, args)<br>            &#125;, wait)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在触发事件的过程中，不会立即执行，并且每wait秒执行一次，在停止触发事件后还会再执行一次。</li></ul><p>时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p><p>将两种方式合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc </span>函数节流</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>wait 延迟执行毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>type 1 表时间戳版，2 表定时器版</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait, type</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (type === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">var</span> prev = <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span><br>    &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>         <span class="hljs-keyword">if</span> (type === <span class="hljs-number">2</span>) &#123;<br>             <span class="hljs-keyword">if</span> (!timer) &#123;<br>                 timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                   timer = <span class="hljs-literal">null</span><br>                   fn.apply(context, args) <br>                 &#125;, wait)<br>             &#125;<br>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">const</span> now = <span class="hljs-built_in">Date</span>.now()<br>            <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>                fn.apply(context, args)<br>                prev = now<br>            &#125;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><a href="https://juejin.im/post/6844903651278848014" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react中实现导航栏状态与地址绑定</title>
    <link href="/myblog/2021/05/21/react%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%8A%B6%E6%80%81%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A/"/>
    <url>/myblog/2021/05/21/react%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%8A%B6%E6%80%81%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="一、项目初始化"><a href="#一、项目初始化" class="headerlink" title="一、项目初始化"></a>一、项目初始化</h3><h4 id="1-安装与运行"><a href="#1-安装与运行" class="headerlink" title="1. 安装与运行"></a>1. 安装与运行</h4><p>构建项目：<code>yarn create react-app my-app</code><br>启动：<code>yarn start</code><br>当然也可以使用npm：</p><ul><li>全局安装：<code>npm install -g create-react-app</code></li><li>构建项目：<code>npx create-react-app my-app</code></li><li>启动：<code>npm start</code></li></ul><h3 id="2-安装路由依赖"><a href="#2-安装路由依赖" class="headerlink" title="2.安装路由依赖"></a>2.安装路由依赖</h3><p>在项目中执行：<code>npm install react-router-dom --save</code></p><h3 id="3-在App-js中引入router"><a href="#3-在App-js中引入router" class="headerlink" title="3.在App.js中引入router"></a>3.在App.js中引入router</h3><p>由于简单演示，就不单独对router进行封装了。<br>安装完成后，我们在App.js中引入路由相关组件<code>BrowserRouter</code>、<code>Route</code>、<code>Switch</code>、<code>Redirect</code><br>在顶部引入：<code>import { BrowserRouter as Router, Route, Switch, Redirect } from &#39;react-router-dom&#39;</code><br>详细代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/home'</span><br><span class="hljs-keyword">import</span> Study <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/study'</span><br><span class="hljs-keyword">import</span> Type <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/type'</span><br><span class="hljs-keyword">import</span> Label <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/label'</span><br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/about'</span><br><span class="hljs-keyword">import</span> &#123; Layout &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span><br><span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Header'</span><br><span class="hljs-keyword">import</span> Persional <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Persional'</span><br><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Switch, Redirect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span><br><span class="hljs-keyword">const</span> &#123; Footer, Content, Sider&#125; = Layout;<br><span class="hljs-comment">// 导入子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">"App"</span> &gt;<br>        &lt;Layout&gt;<br>          &lt;Sider&gt;<br>            &lt;Persional /&gt;<br>          &lt;<span class="hljs-regexp">/Sider&gt;</span><br><span class="hljs-regexp">          &lt;Content&gt;</span><br><span class="hljs-regexp">            &lt;Router&gt;</span><br><span class="hljs-regexp">              &lt;Header /</span>&gt;<br>              &lt;Switch&gt;<br>                &lt;Route path=<span class="hljs-string">"/home"</span> exact component=&#123;Home&#125;&gt;&lt;<span class="hljs-regexp">/Route&gt;</span><br><span class="hljs-regexp">                &lt;Route path="/</span>study<span class="hljs-string">" component=&#123;Study&#125;&gt;&lt;/Route&gt;</span><br><span class="hljs-string">                &lt;Route path="</span>/type<span class="hljs-string">" component=&#123;Type&#125;&gt;&lt;/Route&gt;</span><br><span class="hljs-string">                &lt;Route path="</span>/label<span class="hljs-string">" component=&#123;Label&#125;&gt;&lt;/Route&gt;</span><br><span class="hljs-string">                &lt;Route path="</span>/about<span class="hljs-string">" component=&#123;About&#125;&gt;&lt;/Route&gt;</span><br><span class="hljs-string">                &lt;Redirect from="</span><span class="hljs-comment">/*" to="/home"&gt;&lt;/Redirect&gt;</span><br><span class="hljs-comment">              &lt;/Switch&gt;</span><br><span class="hljs-comment">              &lt;Footer&gt;Footer&lt;/Footer&gt;</span><br><span class="hljs-comment">            &lt;/Router&gt;</span><br><span class="hljs-comment">          &lt;/Content&gt; </span><br><span class="hljs-comment">        &lt;/Layout&gt;</span><br><span class="hljs-comment">      &lt;/div&gt;</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">export default App;</span><br></code></pre></td></tr></table></figure><p>这里用到了antd的<code>Layout</code>布局组件进行布局<br>首先我们将我们的视图组件引入进来（<code>import Home from &#39;@/views/home&#39;</code>），并在Route标签中配置：（以home为例）<code>&lt;Route path=&quot;/home&quot; exact component={Home}&gt;&lt;/Route&gt;</code></p><h3 id="4-编写Header头部导航组件"><a href="#4-编写Header头部导航组件" class="headerlink" title="4.编写Header头部导航组件"></a>4.编写Header头部导航组件</h3><p>在components目录下新建Header目录，并在其目录下新建index.js及index.scss文件，这里使用scss进行编写。<br>安装命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> --save-dev <br>npm install sass-loader --save-dev<br></code></pre></td></tr></table></figure><p>为了实现导航栏状态与地址联动，关键是要实现组件初始化时的处理逻辑，也就是组件挂载的时候，即在生命周期函数<code>componentDidMount</code>中实现。<br>要实现以下两点：</p><ul><li>修改当前地址对应导航栏状态</li><li>监听浏览器前进后退，即监听history对象<br>关键代码如下：<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mel">componentDidMount = () =&gt; &#123;<br>    let moren = this.props.location.pathname<br>    let <span class="hljs-keyword">text</span> = moren.<span class="hljs-keyword">substring</span>(moren.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>, moren.length)<br>    <span class="hljs-comment">// 当访问的目录不在这个数组里时候，当前状态是home，即重定向到home页面</span><br>    ![<span class="hljs-string">'home'</span>, <span class="hljs-string">'study'</span>, <span class="hljs-string">'type'</span>, <span class="hljs-string">'label'</span>, <span class="hljs-string">'about'</span>, <span class="hljs-string">'search'</span>].includes(<span class="hljs-keyword">text</span>) &amp;&amp; (<span class="hljs-keyword">text</span> = <span class="hljs-string">'home'</span>)<br>    this.<span class="hljs-keyword">setState</span>(&#123;<br>      current: <span class="hljs-keyword">text</span><br>    &#125;)<br>    <span class="hljs-comment">// 监听history变化</span><br>    history.listen((<span class="hljs-keyword">event</span>) =&gt; &#123;<br>      let test = <span class="hljs-keyword">event</span>.pathname<br>      let <span class="hljs-keyword">text</span> = test.<span class="hljs-keyword">substring</span>(test.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>, test.length)<br>      this.<span class="hljs-keyword">setState</span>(&#123;<br>        current: <span class="hljs-keyword">text</span><br>      &#125;)<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure>组件完整代码如下：<br>index.js:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125;  <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<br><span class="hljs-keyword">import</span> &#123; Row, Col, Menu  &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span>;<br><span class="hljs-keyword">import</span> &#123; Link, withRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span><br><span class="hljs-keyword">import</span> &#123; HomeOutlined, FolderOpenOutlined, AppstoreOutlined, PushpinOutlined, UserOutlined, SearchOutlined &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@ant-design/icons'</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">'./index.scss'</span><br><span class="hljs-keyword">import</span> &#123; createBrowserHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'history'</span>;<br><span class="hljs-keyword">const</span> history = createBrowserHistory() <span class="hljs-comment">// history模式</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      logo: <span class="hljs-string">''</span>,<br>      current: <span class="hljs-string">'home'</span><br>    &#125;<br>  &#125;<br>  handleClick = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">this</span>.setState(&#123; <span class="hljs-attr">current</span>: e.key &#125;);<br>  &#125;<br>  componentDidMount = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> moren = <span class="hljs-keyword">this</span>.props.location.pathname<br>    <span class="hljs-keyword">let</span> text = moren.substring(moren.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>, moren.length)<br>    ![<span class="hljs-string">'home'</span>, <span class="hljs-string">'study'</span>, <span class="hljs-string">'type'</span>, <span class="hljs-string">'label'</span>, <span class="hljs-string">'about'</span>, <span class="hljs-string">'search'</span>].includes(text) &amp;&amp; (text = <span class="hljs-string">'home'</span>)<br>    <span class="hljs-keyword">this</span>.setState(&#123;<br>      current: text<br>    &#125;)<br>    history.listen(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> test = event.pathname<br>      <span class="hljs-keyword">let</span> text = test.substring(test.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>, test.length)<br>      <span class="hljs-keyword">this</span>.setState(&#123;<br>        current: text<br>      &#125;)<br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">const</span> &#123; current &#125; = <span class="hljs-keyword">this</span>.state;<br>    <span class="hljs-keyword">return</span>(<br>      &lt;div className=<span class="hljs-string">"header-wrapper"</span>&gt;<br>         &lt;Row&gt;<br>          &lt;Col span=&#123;<span class="hljs-number">18</span>&#125; push=&#123;<span class="hljs-number">6</span>&#125; className=<span class="hljs-string">"right-box"</span>&gt;<br>            &lt;Menu onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125; selectedKeys=&#123;[current]&#125; mode=<span class="hljs-string">"horizontal"</span>&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"home"</span> icon=&#123;&lt;HomeOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/home"</span>&gt;首页&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"study"</span> icon=&#123;&lt;FolderOpenOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/study"</span>&gt;学习&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"type"</span> icon=&#123;&lt;AppstoreOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/type"</span>&gt;分类&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"label"</span> icon=&#123;&lt;PushpinOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/label"</span>&gt;标签&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"about"</span> icon=&#123;&lt;UserOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/about"</span>&gt;关于&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"search"</span> icon=&#123;&lt;SearchOutlined /&gt;&#125;&gt;<br>                搜索<br>              &lt;<span class="hljs-regexp">/Menu.Item&gt;</span><br><span class="hljs-regexp">            &lt;/</span>Menu&gt;<br>          &lt;<span class="hljs-regexp">/Col&gt;</span><br><span class="hljs-regexp">          &lt;Col span=&#123;6&#125; pull=&#123;18&#125; className="left-box"&gt;</span><br><span class="hljs-regexp">            &lt;strong className="logo-name"&gt;Deng&lt;/</span>strong&gt;<br>          &lt;<span class="hljs-regexp">/Col&gt;</span><br><span class="hljs-regexp">        &lt;/</span>Row&gt;<br>      &lt;<span class="hljs-regexp">/div&gt;</span><br><span class="hljs-regexp">    )</span><br><span class="hljs-regexp">  &#125;</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp">export default withRouter(Header)</span><br></code></pre></td></tr></table></figure>注意：为了能够拿到<code>this.props.location.pathname</code>,需要使用<code>withRouter</code>处理组件，并把Header组件放在<code>BrowserRouter</code>标签中。<br>这样就能够实现导航栏状态与地址绑定了</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sass常用方法</title>
    <link href="/myblog/2021/05/21/sass%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/myblog/2021/05/21/sass%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是sass"><a href="#一、什么是sass" class="headerlink" title="一、什么是sass"></a>一、什么是sass</h3><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，提供了许多便利的写法，大大提高的开发效率。下面总结了SASS的主要用法，想要了解更多可以查阅<a href="https://www.sass.hk/docs/" target="_blank" rel="noopener">文档</a></p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><p>1、由于sass依赖于Ruby，因此需要先<a href="http://www.ruby-lang.org/zh_cn/downloads/" target="_blank" rel="noopener">安装Ruby</a>，然后执行<code>gem install sass</code><br>2、若在vue-cli或react-create-app中使用，在项目中安装依赖：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> --save-dev<br>npm install sass-loader --save-dev<br></code></pre></td></tr></table></figure><h3 id="三、基础用法"><a href="#三、基础用法" class="headerlink" title="三、基础用法"></a>三、基础用法</h3><h4 id="3-1-变量"><a href="#3-1-变量" class="headerlink" title="3.1 变量"></a>3.1 变量</h4><p>SASS允许使用变量，所有变量以$开头</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$color</span>: <span class="hljs-number">#ccc</span>;<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果变量需要镶嵌在属性中之中，就必须需要写在#{}之中</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$side</span>: right;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$side</span>&#125;-radius: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-计算能力"><a href="#3-2-计算能力" class="headerlink" title="3.2 计算能力"></a>3.2 计算能力</h4><p>SASS允许在代码中使用算式</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$var: <span class="hljs-number">10</span>px;<br>div &#123;<br>  width：(<span class="hljs-number">20</span>px/<span class="hljs-number">2</span>);<br>  top: <span class="hljs-number">10</span>px + <span class="hljs-number">20</span>px;<br>  left: $var * <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-嵌套能力"><a href="#3-3-嵌套能力" class="headerlink" title="3.3 嵌套能力"></a>3.3 嵌套能力</h4><p>一般我们写多个选择器时，一般这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span> &#123;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用sass可以写成：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-class">div </span>&#123;<br>  <span class="hljs-class">h2 </span>&#123;<br><span class="hljs-symbol">    border:</span><span class="hljs-number">1</span>px solid <span class="hljs-meta">#ccc;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性也可以嵌套,比如font-size属性，可以写成</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">div</span> &#123;<br>  font：&#123;<br>    <span class="hljs-keyword">size</span>：<span class="hljs-number">18</span>px;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用&amp;引用父元素</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">div</span> &#123;<br> &amp;::<span class="hljs-keyword">after</span> &#123;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、代码重用"><a href="#四、代码重用" class="headerlink" title="四、代码重用"></a>四、代码重用</h3><h4 id="4-1-继承"><a href="#4-1-继承" class="headerlink" title="4.1 继承"></a>4.1 继承</h4><p>SASS允许一个选择器，继承另一个选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class1</span> &#123;<br>   <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要继承class1，需要使用@extend命令</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.class2</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .class1;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-Mixin-混合"><a href="#4-2-Mixin-混合" class="headerlink" title="4.2 Mixin(混合)"></a>4.2 Mixin(混合)</h4><p>使用@mixin声明代码块，达到重用代码块的作用，在需要用的地方使用@include调用</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">mixin</span> right &#123;<br> margin-right: <span class="hljs-number">20</span>px;<br>&#125;<br>div &#123;<br>  @include right;<br>&#125;<br></code></pre></td></tr></table></figure><p>@minxin可以设置参数以及参数默认值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">mixin</span> left($value: <span class="hljs-number">20</span>px) &#123;<br>  margin-left: $value;<br>&#125;<br>div &#123;<br>  @include left(<span class="hljs-number">10</span>px)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-颜色函数"><a href="#4-3-颜色函数" class="headerlink" title="4.3 颜色函数"></a>4.3 颜色函数</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lighten</span><span class="hljs-params">(<span class="hljs-number">#cc3</span>, <span class="hljs-number">10%</span>)</span></span> <span class="hljs-comment">// #d6d65c  </span><br><span class="hljs-function"><span class="hljs-title">darken</span><span class="hljs-params">(<span class="hljs-number">#cc3</span>, <span class="hljs-number">10%</span>)</span></span> <span class="hljs-comment">// #a3a329  </span><br><span class="hljs-function"><span class="hljs-title">grayscale</span><span class="hljs-params">(<span class="hljs-number">#cc3</span>)</span></span> <span class="hljs-comment">// #808080  </span><br><span class="hljs-function"><span class="hljs-title">complement</span><span class="hljs-params">(<span class="hljs-number">#cc3</span>)</span></span> <span class="hljs-comment">// #33c</span><br></code></pre></td></tr></table></figure><h4 id="4-4-引入文件"><a href="#4-4-引入文件" class="headerlink" title="4.4 引入文件"></a>4.4 引入文件</h4><p>使用@import命令，用来引入外部文件<br>@import 文件路径</p><h3 id="五、进阶用法"><a href="#五、进阶用法" class="headerlink" title="五、进阶用法"></a>五、进阶用法</h3><h4 id="5-1-条件语句"><a href="#5-1-条件语句" class="headerlink" title="5.1 条件语句"></a>5.1 条件语句</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-variable">@if</span> computed($width) &gt; <span class="hljs-number">10</span> &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span> &#125;<br>  <span class="hljs-variable">@if</span> computed($height) &gt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;<br>  &#125; <span class="hljs-variable">@else</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-循环语句"><a href="#5-2-循环语句" class="headerlink" title="5.2 循环语句"></a>5.2 循环语句</h4><p>for循环:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> to <span class="hljs-number">10</span> &#123;  <br> <span class="hljs-selector-class">.content-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123;  <br>    <span class="hljs-attribute">width</span>: #&#123;<span class="hljs-variable">$i</span>&#125;px;  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>while循环:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">　<span class="hljs-variable">$x</span>: <span class="hljs-number">6</span>;<br>　　<span class="hljs-keyword">@while</span> <span class="hljs-variable">$x</span> &gt; <span class="hljs-number">0</span> &#123;  <br>　　　　<span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$x</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-variable">$x</span> + <span class="hljs-number">10px</span>; &#125;  <br>　　　　<span class="hljs-variable">$x</span>: <span class="hljs-variable">$x</span> - <span class="hljs-number">1</span>;  <br>　　&#125;z<br></code></pre></td></tr></table></figure><p>each:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$member</span> in a, b, c, d &#123;  <br> .#&#123;<span class="hljs-variable">$member</span>&#125; &#123;  <br>    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">"/image/#&#123;$member&#125;.jpg"</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">　<span class="hljs-keyword">@function</span> count($n) &#123;  <br>　　　　<span class="hljs-keyword">@return</span> $n + <span class="hljs-number">1</span>;  <br>　　&#125;<br><br>　　<span class="hljs-selector-tag">div</span> &#123;  <br>　　　　<span class="hljs-attribute">width</span>: <span class="hljs-built_in">count</span>(<span class="hljs-number">5px</span>);  <br>　　&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-cli中使用svgIcon</title>
    <link href="/myblog/2021/05/21/vue-cli%E4%B8%AD%E4%BD%BF%E7%94%A8svgIcon/"/>
    <url>/myblog/2021/05/21/vue-cli%E4%B8%AD%E4%BD%BF%E7%94%A8svgIcon/</url>
    
    <content type="html"><![CDATA[<h3 id="一、安装依赖包"><a href="#一、安装依赖包" class="headerlink" title="一、安装依赖包"></a>一、安装依赖包</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npm install svg-sprite-loader -D<br>或者<br>yarn <span class="hljs-keyword">add</span><span class="bash"> svg-sprite-loader -D</span><br></code></pre></td></tr></table></figure><h3 id="二、配置vue-config-js文件"><a href="#二、配置vue-config-js文件" class="headerlink" title="二、配置vue.config.js文件"></a>二、配置vue.config.js文件</h3><p>在顶部写入</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span> <span class="hljs-params">(dir)</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">path</span>.join(__dirname, dir)<br>&#125;<br></code></pre></td></tr></table></figure><p>在chainWebpack中增加下列配置</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">chainWebpack</span> (config) &#123;<br>    <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.rule</span>(<span class="hljs-string">'svg'</span>)<br>      <span class="hljs-selector-class">.exclude</span><span class="hljs-selector-class">.add</span>(resolve(<span class="hljs-string">'src/icons'</span>))<br>    <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.rule</span>(<span class="hljs-string">'icons'</span>)<br>      <span class="hljs-selector-class">.test</span>(/\.svg$/)<br>      <span class="hljs-selector-class">.include</span><span class="hljs-selector-class">.add</span>(resolve(<span class="hljs-string">'./src/icons'</span>))<span class="hljs-selector-class">.end</span>()<br>      <span class="hljs-selector-class">.use</span>(<span class="hljs-string">'svg-sprite-loader'</span>)<br>      <span class="hljs-selector-class">.loader</span>(<span class="hljs-string">'svg-sprite-loader'</span>)<br>      <span class="hljs-selector-class">.options</span>(&#123; <span class="hljs-attribute">symbolId</span>: <span class="hljs-string">'icon-[name]'</span> &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="三、实现SvgIcon组件"><a href="#三、实现SvgIcon组件" class="headerlink" title="三、实现SvgIcon组件"></a>三、实现SvgIcon组件</h3><p>组件结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"svgClass"</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">"$listeners"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">:xlink:href</span>=<span class="hljs-string">"iconName"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br>    iconClass: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="actionscript">      required: <span class="hljs-literal">true</span></span><br>    &#125;,<br>    className: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="actionscript">      <span class="hljs-keyword">default</span>: <span class="hljs-string">''</span></span><br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    iconName () &#123;<br><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-string">`#icon-<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.iconClass&#125;</span>`</span></span><br>    &#125;,<br>    svgClass () &#123;<br><span class="actionscript">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.className) &#123;</span><br><span class="actionscript">        <span class="hljs-keyword">return</span> <span class="hljs-string">'svg-icon '</span> + <span class="hljs-keyword">this</span>.className</span><br><span class="actionscript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="actionscript">        <span class="hljs-keyword">return</span> <span class="hljs-string">'svg-icon'</span></span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.svg-icon</span> &#123;</span><br>  width: 1em;<br>  height: 1em;<br><span class="css">  <span class="hljs-selector-tag">vertical-align</span>: <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.15em</span>;</span><br>  fill: currentColor;<br>  overflow: hidden;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="四、根目录下创建icons-svg目录"><a href="#四、根目录下创建icons-svg目录" class="headerlink" title="四、根目录下创建icons/svg目录"></a>四、根目录下创建icons/svg目录</h3><p> 用于存放我们所需要用的svg文件</p><h3 id="五、新建plugins目录及index-js文件"><a href="#五、新建plugins目录及index-js文件" class="headerlink" title="五、新建plugins目录及index.js文件"></a>五、新建plugins目录及index.js文件</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> SvgIcon <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/SvgIcon'</span><br><br><span class="hljs-keyword">const</span> req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">'@/icons/svg'</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.svg$/</span>)<br>req.keys().<span class="hljs-keyword">map</span>(req)<br><br>Vue.component(<span class="hljs-string">'svg-icon'</span>, SvgIcon)<br></code></pre></td></tr></table></figure><p>其作用是在Vue实例上创建SvgIcon组件，其中require.context的作用是获取一个特定的上下文,遍历文件夹中的指定文件，主要用来实现自动化导入模块</p><ul><li>最后在main.js中引入plugins, <code>import &#39;@/plugins&#39;</code></li></ul><h3 id="六、SvgIcon-组件的使用"><a href="#六、SvgIcon-组件的使用" class="headerlink" title="六、SvgIcon 组件的使用"></a>六、SvgIcon 组件的使用</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cs">&lt;svg-icon icon-<span class="hljs-keyword">class</span>=<span class="hljs-string">"icon-name"</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">"down"</span>&gt;&lt;/svg-icon&gt;<br></code></pre></td></tr></table></figure><p>其中icon-class为svg文件名， class为类名</p>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
      <tag>vue</tag>
      
      <tag>组件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中组件通信之findComponents</title>
    <link href="/myblog/2021/05/21/vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8BfindComponents/"/>
    <url>/myblog/2021/05/21/vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8BfindComponents/</url>
    
    <content type="html"><![CDATA[<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 向上查找组件 context为当前组件上下文对象，componentName为组件名</span><br><span class="hljs-keyword">const</span> findUpwardComponent = (context, componentName) =&gt; &#123;<br>    let <span class="hljs-keyword">parent</span> = context.$parent<br>    let name = <span class="hljs-keyword">parent</span>.$options.name<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">parent</span> &amp;&amp; (!name || !name.includes(componentName))) &#123;<br>        <span class="hljs-keyword">parent</span> = <span class="hljs-keyword">parent</span>.$parent<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">parent</span>) name = <span class="hljs-keyword">parent</span>.$options.name<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">parent</span><br>&#125;<br><br><span class="hljs-comment">// 查找兄弟组件</span><br><span class="hljs-keyword">const</span> findBrotherComponents = (ctx, componentName, exceptMe = <span class="hljs-keyword">true</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> $brothers = ctx.$parent.$children.filter(item =&gt; &#123;<br>        <span class="hljs-keyword">return</span> item.$options.name &amp;&amp; item.$options.name.includes(componentName)<br>    &#125;)<br>    <span class="hljs-keyword">const</span> index = $brothers.findIndex(item =&gt; item._uid === ctx._uid)<br>    <span class="hljs-keyword">if</span> (exceptMe &amp;&amp; index &gt; <span class="hljs-number">-1</span>) $brothers.splice(index, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> $brothers<br>&#125;<br><br><span class="hljs-comment">// 向下查找</span><br><span class="hljs-keyword">const</span> findDownwardComponent = (context, componentName) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> $children = context.$children<br>    let bean = <span class="hljs-keyword">null</span><br>    <span class="hljs-keyword">if</span> ($children.length) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child of $children) &#123;<br>            <span class="hljs-keyword">const</span> name = child.$options.name<br>            <span class="hljs-keyword">if</span> (name &amp;&amp; name.includes(componentName)) &#123;<br>                bean = child<br>                <span class="hljs-keyword">break</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                bean = findDownwardComponent(child, componentName)<br>                <span class="hljs-keyword">if</span> (bean) <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scss实现retina屏1px边框</title>
    <link href="/myblog/2021/05/21/scss%E5%AE%9E%E7%8E%B0retina%E5%B1%8F1px%E8%BE%B9%E6%A1%86/"/>
    <url>/myblog/2021/05/21/scss%E5%AE%9E%E7%8E%B0retina%E5%B1%8F1px%E8%BE%B9%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br><span class="hljs-comment">// =======================</span><br><span class="hljs-comment">//  用法：  </span><br><span class="hljs-comment">//  @include retina-border(1,1,1,1);</span><br><span class="hljs-comment">//  数值 代表 各 边框的宽度  上右下左</span><br><span class="hljs-comment">// =======================</span><br><br><br><span class="hljs-keyword">@mixin</span> _border-scale(<span class="hljs-variable">$dpr</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span> * <span class="hljs-variable">$dpr</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span> * <span class="hljs-variable">$dpr</span>;<br><br>  -webkit-<span class="hljs-attribute">transform</span>: scale(<span class="hljs-number">1</span> / <span class="hljs-variable">$dpr</span>);<br>  -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">transform</span>: scale(<span class="hljs-number">1</span> / <span class="hljs-variable">$dpr</span>);<br>  <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> _border-base() &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">pointer-events</span>: none;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> retina-border(<span class="hljs-variable">$top</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">$right</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">$bottom</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">$left</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">$cor</span>: <span class="hljs-number">#000000</span>) &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br><br>  &amp;<span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">border-top</span>: #&#123;<span class="hljs-variable">$top</span>&#125;px solid <span class="hljs-variable">$cor</span>;<br>    <span class="hljs-attribute">border-right</span>: #&#123;<span class="hljs-variable">$right</span>&#125;px solid <span class="hljs-variable">$cor</span>;<br>    <span class="hljs-attribute">border-bottom</span>: #&#123;<span class="hljs-variable">$bottom</span>&#125;px solid <span class="hljs-variable">$cor</span>;<br>    <span class="hljs-attribute">border-left</span>: #&#123;<span class="hljs-variable">$left</span>&#125;px solid <span class="hljs-variable">$cor</span>;<br><br>    <span class="hljs-keyword">@include</span> _border-base();<br><br>    <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">@include</span> _border-scale(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">1.5</span>) &#123;<br>      <span class="hljs-keyword">@include</span> _border-scale(<span class="hljs-number">1.5</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">@include</span> _border-scale(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-keyword">@include</span> _border-scale(<span class="hljs-number">3</span>);<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的git命令操作</title>
    <link href="/myblog/2021/05/21/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/myblog/2021/05/21/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用git之前需要先安装它<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载git</a></p><p>以windows系统为例子，安装完成后，鼠标右键点击桌面，出现Git Bash Here和 Git GUI Here 说明安装成功。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">""</span>  <br>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">""</span><br></code></pre></td></tr></table></figure><h4 id="克隆远程仓库与代码提交"><a href="#克隆远程仓库与代码提交" class="headerlink" title="克隆远程仓库与代码提交"></a>克隆远程仓库与代码提交</h4><p>1、在github上新建项目new repositories后，复制https地址或ssh<br>2、在相应的目录，右键选择 git bash here 进入 git操作界面<br>3、输入 git clone “复制的仓库地址”<br>4、对仓库内存进行修改<br>5、cd 文件夹名称（进入文件夹）<br>6、git add .（或git add –all）<br>7、git commit -m “需要写的提交说明”<br>8、git push</p><p>其中git add . 与git add –all的区别是:<br>（1）.git add –all可以提交未跟踪、修改和删除文件。<br>（2）.git add .可以提交未跟踪和修改文件，但是不处理删除文件。</p><h4 id="创建新的分支"><a href="#创建新的分支" class="headerlink" title="创建新的分支"></a>创建新的分支</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b </span>分支名称 （创建并切换至该分支）<br></code></pre></td></tr></table></figure><p>注：新建的分支第一次push： git push -u origin 分支名</p><h4 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git branch<span class="hljs-comment"> // 本地分支</span><br>git branch -<span class="hljs-keyword">a</span><span class="hljs-comment"> // 所以分支,包括线上</span><br></code></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">git branch -D 分支名 <span class="hljs-comment">// 删除本地分支</span><br>git <span class="hljs-keyword">push</span> origin --<span class="hljs-keyword">delete</span> 分支名 <span class="hljs-comment">// 删除远程分支</span><br></code></pre></td></tr></table></figure><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> checkout 分支名<br></code></pre></td></tr></table></figure><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>、先切换到<span class="hljs-literal">master</span>分支 git checkout <span class="hljs-literal">master</span><br><br><span class="hljs-number">2</span>、拉取最新代码 git pull<br><br><span class="hljs-number">3</span>、切换到自己的分支 并将<span class="hljs-literal">master</span>分支与自己的分支合并，然后解决冲突<br><br>git merge <span class="hljs-keyword">master</span> <span class="hljs-title">解决完冲突后，git</span> add --all git commit -m<span class="hljs-string">""</span><br><br>git fetch origin <span class="hljs-literal">master</span>// 虚拟的更新远程的<span class="hljs-literal">master</span><br><br>git merge origin/<span class="hljs-keyword">master</span> <span class="hljs-title">//合并远程master</span><br><br>git push 推到自己的远程分支<br><br><span class="hljs-number">4</span>、切换到 <span class="hljs-keyword">master</span> <span class="hljs-title">分支</span><br><span class="hljs-title"></span><br><span class="hljs-title">5</span>、将自己的分子合并到<span class="hljs-keyword">master</span> <span class="hljs-title">分支</span><br><span class="hljs-title"></span><br><span class="hljs-title">git</span> merge 分支名<br></code></pre></td></tr></table></figure><h4 id="跟踪到远程名字相同的分支"><a href="#跟踪到远程名字相同的分支" class="headerlink" title="跟踪到远程名字相同的分支"></a>跟踪到远程名字相同的分支</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/分支名 分支名<br></code></pre></td></tr></table></figure><h4 id="将更改加入暂存区"><a href="#将更改加入暂存区" class="headerlink" title="将更改加入暂存区"></a>将更改加入暂存区</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git stash <span class="hljs-built_in">save</span> <span class="hljs-string">"描述信息"</span><br><br>git stash list : 显示保存列表。<br><br>git stash <span class="hljs-built_in">pop</span>  恢复最近保存的记录并把恢复的记录从保存列表中删除<br></code></pre></td></tr></table></figure><h4 id="查看与生成公钥"><a href="#查看与生成公钥" class="headerlink" title="查看与生成公钥"></a>查看与生成公钥</h4><p>进入该目录并列出其中内容：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br><br><span class="hljs-keyword">ls</span><br><br>cat id_rsa.pub <span class="hljs-string">//</span> 查看公钥<br></code></pre></td></tr></table></figure><p>设置邮箱与用户名</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">""</span><br><br>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">""</span><br></code></pre></td></tr></table></figure><p>清理之前的公钥</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mkdir</span> <span class="hljs-string">key_backup</span><br><br><span class="hljs-attr">cp</span> <span class="hljs-string">id_rsa* key_backup</span><br><br><span class="hljs-attr">rm</span> <span class="hljs-string">id_rsa*</span><br></code></pre></td></tr></table></figure><p>生成</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ssh-keygen -t rsa -C <span class="hljs-string">"邮箱号"</span> <span class="hljs-comment">// C是大写</span><br></code></pre></td></tr></table></figure><p>查看</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">cat</span> <span class="hljs-selector-tag">id_rsa</span><span class="hljs-selector-class">.pub</span><br></code></pre></td></tr></table></figure><h4 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h4><p>查看版本</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">log</span> -<span class="hljs-built_in">num</span><span class="hljs-comment"> // num: 版本数量</span><br></code></pre></td></tr></table></figure><p>回滚到指定的版本</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">git reset --hard<span class="hljs-built_in"> id</span> //<span class="hljs-built_in"> id</span>: 版<span class="hljs-built_in">本id</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中实现倒计时组件与毫秒效果</title>
    <link href="/myblog/2021/05/21/vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%AF%AB%E7%A7%92%E6%95%88%E6%9E%9C/"/>
    <url>/myblog/2021/05/21/vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%AF%AB%E7%A7%92%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="时分秒倒计时组件"><a href="#时分秒倒计时组件" class="headerlink" title="时分秒倒计时组件"></a>时分秒倒计时组件</h3><h4 id="template"><a href="#template" class="headerlink" title="template"></a>template</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 倒计时组件 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"downTime-wrapper"</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 这里是显示还未结束时的内容，这里只是我这得布局，你可以随意。 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"time"</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"!isShow"</span>&gt;</span></span><br><span class="xml">      <span class="hljs-comment">&lt;!-- &lt;span class="hour"&gt;</span></span><span class="hljs-template-variable">&#123;&#123;myDay&#125;&#125;</span><span class="xml"><span class="hljs-comment">&lt;/span&gt; : --&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"hour"</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getHours1 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getHours2 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dian"</span>&gt;</span>:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"minute"</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getMinutes1 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getMinutes2 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dian"</span>&gt;</span>:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"second"</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getSeconds1 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getSeconds2 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 这里是显示结束后的内容 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"second"</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"isShow"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;clocker&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;script&gt;<br>export <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">'downTime'</span>,<br><br>  props: &#123; <span class="hljs-comment">// 接收父组件传递过来的参数,这里传了  结束时间 - 开始时间 - 结束后显示的内容</span><br>    endTime: &#123;<br>      type: Number<br>    &#125;,<br>    startTime: &#123;<br>      type: Number<br>    &#125;,<br>    endMsg: &#123;<br>      type: String<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-keyword">data</span> () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      isShow: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 控制显示结束或还未结束显示的内容</span><br>      clocker: <span class="hljs-string">''</span>, <span class="hljs-comment">// 结束后显示的内容</span><br>      timeObj: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 时间对象,下方会用到</span><br>      myDay: <span class="hljs-number">0</span>, <span class="hljs-comment">// 我定义来接收计算出来的 天 的</span><br>      myHours: <span class="hljs-number">0</span>, <span class="hljs-comment">// 我定义来接收计算出来的 小时 的</span><br>      myMinutes: <span class="hljs-number">0</span>, <span class="hljs-comment">// 我定义来接收计算出来的 分钟 的</span><br>      mySeconds: <span class="hljs-number">0</span><span class="hljs-comment">// 我定义来接收计算出来的 秒钟 的</span><br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    getHours1 () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myHours &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> : parseInt((<span class="hljs-keyword">this</span>.myHours % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<br>    &#125;,<br>    getHours2 () &#123;<br>      <span class="hljs-keyword">return</span> parseInt(<span class="hljs-keyword">this</span>.myHours % <span class="hljs-number">10</span>)<br>    &#125;,<br>    getMinutes1 () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myMinutes &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> : parseInt((<span class="hljs-keyword">this</span>.myMinutes % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<br>    &#125;,<br>    getMinutes2 () &#123;<br>      <span class="hljs-keyword">return</span> parseInt(<span class="hljs-keyword">this</span>.myMinutes % <span class="hljs-number">10</span>)<br>    &#125;,<br>    getSeconds1 () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mySeconds &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> : parseInt((<span class="hljs-keyword">this</span>.mySeconds % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<br>    &#125;,<br>    getSeconds2 () &#123;<br>      <span class="hljs-keyword">return</span> parseInt(<span class="hljs-keyword">this</span>.mySeconds % <span class="hljs-number">10</span>)<br>    &#125;<br>  &#125;,<br>  mounted () &#123;<br>  &#125;,<br>  methods: &#123;<br>    option () &#123;<br>      <span class="hljs-comment">// 计算时间差</span><br>      let timeLag = (<span class="hljs-keyword">this</span>.endTime - <span class="hljs-keyword">this</span>.startTime) / <span class="hljs-number">1000</span><br>      <span class="hljs-comment">// 判断当前是否时分秒的值是否大于10</span><br>      <span class="hljs-keyword">const</span> add = num =&gt; &#123;<br>        <span class="hljs-keyword">return</span> num &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">'0'</span> + num : num<br>      &#125;<br>      <span class="hljs-comment">// 时间倒计时运算的方法</span><br>      <span class="hljs-keyword">const</span> timeFunction = () =&gt; &#123;<br>        <span class="hljs-keyword">const</span> time = timeLag--<br>        <span class="hljs-keyword">this</span>.timeObj = &#123; <span class="hljs-comment">// 时间对象</span><br>          seconds: Math.floor(time % <span class="hljs-number">60</span>),<br>          minutes: Math.floor(time / <span class="hljs-number">60</span>) % <span class="hljs-number">60</span>,<br>          hours: Math.floor(time / <span class="hljs-number">60</span> / <span class="hljs-number">60</span>) % <span class="hljs-number">24</span>,<br>          days: Math.floor(time / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>)<br>        &#125;<br>        <span class="hljs-comment">// 计算出时分秒</span><br>        <span class="hljs-keyword">this</span>.myDay = `$&#123;add(<span class="hljs-keyword">this</span>.timeObj.days)&#125;`<br>        <span class="hljs-keyword">this</span>.myHours = `$&#123;add(<span class="hljs-keyword">this</span>.timeObj.hours)&#125;`<br>        <span class="hljs-keyword">this</span>.myMinutes = `$&#123;add(<span class="hljs-keyword">this</span>.timeObj.minutes)&#125;`<br>        <span class="hljs-keyword">this</span>.mySeconds = `$&#123;add(<span class="hljs-keyword">this</span>.timeObj.seconds)&#125;`<br>        <span class="hljs-comment">// 当时间差小于等于0时,停止倒计时</span><br>        <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">this</span>.isShow = <span class="hljs-literal">true</span><br>          <span class="hljs-keyword">this</span>.clocker = <span class="hljs-keyword">this</span>.endMsg<br>          clearInterval(go)<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 开始执行倒计时</span><br>      timeFunction()<br>      <span class="hljs-comment">// 每一秒执行一次</span><br>      <span class="hljs-keyword">const</span> go = setInterval(() =&gt; &#123;<br>        timeFunction()<br>      &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>  &#125;,<br>    watch: &#123;<br>        endTime: &#123;<br>          handler (newName, oldName) &#123;<br>            <span class="hljs-keyword">this</span>.option()<br>          &#125;,<br>          immediate: <span class="hljs-literal">true</span>,<br>          deep: <span class="hljs-literal">true</span><br>        &#125;<br>     &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>备注：我将时分秒使用计算属性分成了个位和十位两部分展示，在watch中深度监听endTime属性的变化并重新调用定时器</p><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;style lang=<span class="hljs-string">"scss"</span> scoped&gt;<br>.downTime-wrapper&#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-selector-class">.dian</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">top</span>: -<span class="hljs-number">5px</span>;<br>  &#125;<br>  .hour&#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>;<br>    <span class="hljs-selector-tag">span</span> &#123;<br>      <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">6px</span>;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;<br>      <span class="hljs-attribute">background</span>:rgba(<span class="hljs-number">27</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">1</span>);<br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">1px</span> <span class="hljs-number">10px</span>;<br>      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span>;<br>    &#125;<br>  &#125;<br>  .minute&#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>;<br>    <span class="hljs-selector-tag">span</span> &#123;<br>      <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">6px</span>;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;<br>      <span class="hljs-attribute">background</span>:rgba(<span class="hljs-number">27</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">1</span>);<br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">1px</span> <span class="hljs-number">10px</span>;<br>      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-selector-class">.second</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">5px</span>;<br>    <span class="hljs-selector-tag">span</span> &#123;<br>      <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">6px</span>;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;<br>      <span class="hljs-attribute">background</span>:rgba(<span class="hljs-number">27</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">1</span>);<br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">1px</span> <span class="hljs-number">10px</span>;<br>      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span>;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在页面中引入并注册后即可使用</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;timer<br>  <span class="hljs-symbol">:endTime=<span class="hljs-string">"item.endTime"</span></span><br>  <span class="hljs-symbol">:startTime=<span class="hljs-string">"new Date().getTime()"</span></span><br>  <span class="hljs-symbol">:endMsg=<span class="hljs-string">"item.endMsg"</span>&gt;</span><br>&lt;<span class="hljs-regexp">/timer&gt;</span><br></code></pre></td></tr></table></figure><h3 id="毫秒倒计时效果"><a href="#毫秒倒计时效果" class="headerlink" title="毫秒倒计时效果"></a>毫秒倒计时效果</h3><p>在template中加入<br><code>&lt;b id=&quot;timehs&quot;&gt;:00&lt;/b&gt;</code></p><p>声明timeDt方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">methods: &#123;<br>    timeDt () &#123;<br>      <span class="hljs-keyword">this</span>.timer1 = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> haomiao = <span class="hljs-number">99</span><br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'timehs'</span>).innerHTML = <span class="hljs-string">':'</span> + haomiao<br>        <span class="hljs-keyword">this</span>.timer2 = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">const</span> timehs = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'timehs'</span>)<br>          <span class="hljs-keyword">if</span> (timehs) &#123;<br>            timehs.innerHTML = <span class="hljs-string">`:<span class="hljs-subst">$&#123;haomiao &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">`0<span class="hljs-subst">$&#123;haomiao&#125;</span>`</span> : haomiao&#125;</span>`</span><br>          &#125;<br>          haomiao--<br>          <span class="hljs-keyword">if</span> (haomiao &lt; <span class="hljs-number">0</span>) &#123;<br>            haomiao = <span class="hljs-number">99</span><br>          &#125;<br>        &#125;, <span class="hljs-number">10</span>)<br>      &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>在create生命周期函数中调用timeDt方法</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">created () &#123;<br>    <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">this</span>.timeDt()<br>    &#125;)<br>  &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>组件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mongoose在egg中的运用</title>
    <link href="/myblog/2021/05/21/Mongoose%E5%9C%A8egg%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <url>/myblog/2021/05/21/Mongoose%E5%9C%A8egg%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Mongoose是什么？"><a href="#Mongoose是什么？" class="headerlink" title="Mongoose是什么？"></a>Mongoose是什么？</h3><p>Mongoose是MongoDB的一个对象模型工具，封装了许多MongoDB对文档的的增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。<br>###在egg项目中如何使用？</p><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><p><code>npm i egg-mongoose --save</code></p><h4 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h4><p>在根目录下的/config/plugin.js中配置插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">exports</span>.mongoose = &#123;<br>  enable: <span class="hljs-keyword">true</span>,<br>  <span class="hljs-keyword">package</span>: <span class="hljs-string">'egg-mongoose'</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3、连接数据库"><a href="#3、连接数据库" class="headerlink" title="3、连接数据库"></a>3、连接数据库</h4><p>在根目录下的/config/config.default.js增加配置，其中url为我们的数据库地址，可通过环境变量来区分开发环境还是生产环境，并且确定是否使用用户名密码的数据库<br><code>const prod = process.env.npm_config_server_prod;</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">mongoose</span>: &#123;<br>      <span class="hljs-attribute">client</span>: &#123;<br>        <span class="hljs-attribute">url</span>: prod ? <span class="hljs-string">'mongodb:eggadmin:123456@localhost:27017/DbName'</span> : <span class="hljs-string">'mongodb://127.0.0.1:27017/DbName'</span>,<br>        <span class="hljs-attribute">options</span>: &#123;<br>          <span class="hljs-attribute">useUnifiedTopology</span>: true,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br></code></pre></td></tr></table></figure><h4 id="4、配置与使用"><a href="#4、配置与使用" class="headerlink" title="4、配置与使用"></a>4、配置与使用</h4><h5 id="（1）数据表配置"><a href="#（1）数据表配置" class="headerlink" title="（1）数据表配置"></a>（1）数据表配置</h5><p>在app目录下新建model文件夹，在model文件夹下新建JS文件作为数据表的配置内容，下面以书籍表的配置为例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: Mongoose book Schema,</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> mongoose = app.mongoose;<br>  <span class="hljs-keyword">const</span> Schema = mongoose.Schema;<br>  <span class="hljs-keyword">const</span> BookSchema = <span class="hljs-keyword">new</span> Schema(&#123;<br>    desc: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 书籍描述 */</span><br>    name: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 书籍名称 */</span><br>    press: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 出版社 */</span><br>    author: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 作者 */</span><br>    image: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">Array</span> &#125;, <span class="hljs-comment">/* 书籍图片列表*/</span><br>    price: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 价格 */</span><br>    book_type: &#123; <span class="hljs-comment">/* 书籍分类id */</span><br>      <span class="hljs-keyword">type</span>: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'BookClassify'</span>,<br>    &#125;,<br>    user: &#123; <span class="hljs-comment">/* 书籍发布者id */</span><br>      <span class="hljs-keyword">type</span>: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'User'</span>,<br>    &#125;,<br>    create_time: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 创建时间 */</span><br>    status: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 状态，1：待购买，2：已购买*/</span><br>    look: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">Number</span> &#125; <span class="hljs-comment">/* 浏览数量 */</span><br>  &#125;);<br>  <span class="hljs-keyword">return</span> mongoose.model(<span class="hljs-string">'Book'</span>, BookSchema);<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到我们可以通过Schema来定义表结构，可以指定字段的类型及关联，设置完字段后就可以生成model了，这里算是非常简单的配置，更多配置方法可参考<a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">文档</a></p><h5 id="2-、使用mongoose方法"><a href="#2-、使用mongoose方法" class="headerlink" title="(2)、使用mongoose方法"></a>(2)、使用mongoose方法</h5><p>配置完数据表结构后，我们就可以再service层中调用mongoose的方法对文档进行增删查改了，已书籍列表的处理逻辑为例子</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs stata">async findbookList(data) &#123;<br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">type</span>, page, pageSize, <span class="hljs-keyword">desc</span>, status, userId &#125; = data;<br>  <span class="hljs-keyword">const</span> searchVal = &#123;&#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span>) &#123;<br>    searchVal.book_type = mongoose.Types.ObjectId(<span class="hljs-keyword">type</span>)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (status) &#123;<br>    searchVal.status = status<br>  &#125;<br>  <span class="hljs-keyword">if</span> (userId) &#123;<br>    searchVal.user = mongoose.Types.ObjectId(userId)<br>  &#125;<br>  <span class="hljs-keyword">const</span> search_term = &#123;<br>    <span class="hljs-variable">$or</span>: [<br>      &#123; <span class="hljs-keyword">desc</span>: &#123; <span class="hljs-variable">$regex</span>: <span class="hljs-keyword">desc</span> ? <span class="hljs-keyword">desc</span> : '', <span class="hljs-variable">$options</span>: '<span class="hljs-variable">$i</span>' &#125; &#125;,<br>      &#123; name: &#123; <span class="hljs-variable">$regex</span>: <span class="hljs-keyword">desc</span> ? <span class="hljs-keyword">desc</span> : '', <span class="hljs-variable">$options</span>: '<span class="hljs-variable">$i</span>' &#125; &#125;,<br>      &#123; author: &#123; <span class="hljs-variable">$regex</span>: <span class="hljs-keyword">desc</span> ? <span class="hljs-keyword">desc</span> : '', <span class="hljs-variable">$options</span>: '<span class="hljs-variable">$i</span>' &#125; &#125;,<br>      &#123; press: &#123; <span class="hljs-variable">$regex</span>: <span class="hljs-keyword">desc</span> ? <span class="hljs-keyword">desc</span> : '', <span class="hljs-variable">$options</span>: '<span class="hljs-variable">$i</span>' &#125; &#125;,<br>    ],<br>  &#125;;<br>  <span class="hljs-keyword">const</span> totalNum = await this.ctx.model.Book.find(searchVal).and(search_term).countDocuments();<br>  <span class="hljs-keyword">const</span> result = await this.ctx.model.Book.find(searchVal)<br>    .populate(&#123;<br>      path: 'user',<br>      select: &#123; name: 1, image: 1 &#125;<br>    &#125;)<br>    .populate(&#123;<br>      path: 'book_type'<br>    &#125;)<br>    .and(search_term)<br>    .<span class="hljs-keyword">sort</span>(&#123; create_time: -1 &#125;)<br>    .skip((parseInt(page) - 1) * parseInt(pageSize))<br>    .limit(parseInt(pageSize));<br>    <span class="hljs-keyword">return</span> result ? &#123; bean: &#123;<br>      records: result,<br>      current: page,<br>      size: result.length,<br>      <span class="hljs-keyword">total</span>: totalNum,<br>    &#125;, ...<span class="hljs-keyword">app</span>.config.msg.GET_SUCCESS &#125; : <span class="hljs-keyword">app</span>.config.msg.GET_ERR;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，通过this.ctx.model.Book就可以获取到Book的model并且可以调用mongoose需要的方法，例如populate、find、and、sort、skip、limit 等等。</p><h4 id="5、egg-Mongoose常用的方法"><a href="#5、egg-Mongoose常用的方法" class="headerlink" title="5、egg-Mongoose常用的方法"></a>5、egg-Mongoose常用的方法</h4><h5 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.create</span>(<span class="hljs-selector-tag">data</span>,<span class="hljs-selector-tag">callback</span>);<br></code></pre></td></tr></table></figure><p>其中data为json数据结构，callback为操作后的回调函数</p><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><h6 id="获取所有数据，返回是一个数组"><a href="#获取所有数据，返回是一个数组" class="headerlink" title="获取所有数据，返回是一个数组"></a>获取所有数据，返回是一个数组</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.find</span>()<br></code></pre></td></tr></table></figure><h6 id="获取一个数据，返回是一个对象"><a href="#获取一个数据，返回是一个对象" class="headerlink" title="获取一个数据，返回是一个对象"></a>获取一个数据，返回是一个对象</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.findOne</span>()<br></code></pre></td></tr></table></figure><h6 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Article</span><span class="hljs-selector-class">.find</span>(<span class="hljs-selector-tag">conditions</span>,<span class="hljs-selector-tag">callback</span>);<br></code></pre></td></tr></table></figure><p>其中conditions为查询的条件，callback为回调函数<br>conditions有一下几种情况：</p><p> 具体数据：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">this.ctx.model.Book.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-variable">_id</span>：<span class="hljs-number">5</span>c4a19fb87ba4002a47ac4d, <span class="hljs-built_in">name</span>: <span class="hljs-string">"射雕英雄传"</span> &#125;, callback);<br></code></pre></td></tr></table></figure><p>条件查询：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-string">"<span class="hljs-variable">$lt</span>"</span>小于<br><span class="hljs-string">"<span class="hljs-variable">$lte</span>"</span>小于等于<br><span class="hljs-string">"<span class="hljs-variable">$gt</span>"</span>大于<br><span class="hljs-string">"<span class="hljs-variable">$gte</span>"</span>大于等于<br><span class="hljs-string">"<span class="hljs-variable">$ne</span>"</span>不等于<br><span class="hljs-comment">// 查询价格大于100小于200的书籍数组</span><br><span class="hljs-keyword">this</span>.ctx.model.Book.find(&#123; <span class="hljs-string">"price"</span>: &#123; $<span class="hljs-keyword">get</span>:<span class="hljs-number">100</span> , $lte:<span class="hljs-number">200</span> &#125;);<br></code></pre></td></tr></table></figure><p>或查询 OR</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">"<span class="hljs-variable">$in</span>"</span> 一个键对应多个值<br><span class="hljs-string">"<span class="hljs-variable">$nin</span>"</span> 同上取反, 一个键不对应指定值<br><span class="hljs-string">"<span class="hljs-variable">$or</span>"</span> 多个条件匹配, 可以嵌套 <span class="hljs-variable">$in</span> 使用<br><span class="hljs-string">"<span class="hljs-variable">$not</span>"</span>同上取反, 查询与特定模式不匹配的文档<br><br>this.ctx.model.Book.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">"name"</span>:&#123; <span class="hljs-variable">$in</span>: [<span class="hljs-string">"射雕"</span>,<span class="hljs-string">"倚天"</span>]&#125; );<br></code></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.remove</span>(<span class="hljs-selector-tag">conditions</span>,<span class="hljs-selector-tag">callback</span>);<br></code></pre></td></tr></table></figure><h5 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.update</span>(<span class="hljs-selector-tag">conditions</span>, <span class="hljs-selector-tag">update</span>, <span class="hljs-selector-tag">callback</span>)<br></code></pre></td></tr></table></figure><p>conditions为条件，update是更新的值对象</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.sort</span>(&#123; <span class="hljs-attribute">create_time</span>: -<span class="hljs-number">1</span> &#125;);<br></code></pre></td></tr></table></figure><p>其中-1表示降序返回。 1表示升序返回</p><h5 id="限制数量"><a href="#限制数量" class="headerlink" title="限制数量"></a>限制数量</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.limit</span>(<span class="hljs-selector-tag">number</span>);<br></code></pre></td></tr></table></figure><p>number表示限制的个数</p><h5 id="跳过文档返回"><a href="#跳过文档返回" class="headerlink" title="跳过文档返回"></a>跳过文档返回</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.skip</span>(<span class="hljs-selector-tag">number</span>);<br></code></pre></td></tr></table></figure><p>number表示跳过的个数,skip经常搭配limit实现分页的功能</p><h5 id="条件数组and"><a href="#条件数组and" class="headerlink" title="条件数组and"></a>条件数组and</h5><p>在find后面可使用and对查询结果进行进一步条件筛选，相当于并且的意思。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">const search_term = &#123;<br><span class="hljs-symbol">        $or:</span> [<br>          &#123; <span class="hljs-string">desc:</span> &#123; <span class="hljs-string">$regex:</span> desc ? desc : <span class="hljs-string">''</span>, <span class="hljs-string">$options:</span> <span class="hljs-string">'$i'</span> &#125; &#125;,<br>          &#123; <span class="hljs-string">name:</span> &#123; <span class="hljs-string">$regex:</span> desc ? desc : <span class="hljs-string">''</span>, <span class="hljs-string">$options:</span> <span class="hljs-string">'$i'</span> &#125; &#125;,<br>          &#123; <span class="hljs-string">author:</span> &#123; <span class="hljs-string">$regex:</span> desc ? desc : <span class="hljs-string">''</span>, <span class="hljs-string">$options:</span> <span class="hljs-string">'$i'</span> &#125; &#125;,<br>          &#123; <span class="hljs-string">press:</span> &#123; <span class="hljs-string">$regex:</span> desc ? desc : <span class="hljs-string">''</span>, <span class="hljs-string">$options:</span> <span class="hljs-string">'$i'</span> &#125; &#125;,<br>        ],<br>      &#125;;<br>   <span class="hljs-keyword">this</span>.ctx.model.Book.find().and(search_term)<br></code></pre></td></tr></table></figure><h5 id="关联查询populate"><a href="#关联查询populate" class="headerlink" title="关联查询populate"></a>关联查询populate</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 在model中配置字段时候指定关联的表名，就可以通过populate来进行表的关联查询</span><br><span class="hljs-attribute">user</span>: &#123; <span class="hljs-comment">/* 书籍发布者id */</span><br>      <span class="hljs-attribute">type</span>: Schema.Types.ObjectId,<br>      <span class="hljs-attribute">ref</span>: <span class="hljs-string">'User'</span>,<br>    &#125;,<br>  <br>  <br><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.find</span>()<br>        <span class="hljs-selector-class">.populate</span>(&#123;<br>          <span class="hljs-attribute">path</span>: <span class="hljs-string">'user'</span>,<br>          <span class="hljs-attribute">select</span>: &#123; <span class="hljs-attribute">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attribute">image</span>: <span class="hljs-number">1</span> &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><h5 id="聚合管道Aggregate"><a href="#聚合管道Aggregate" class="headerlink" title="聚合管道Aggregate"></a>聚合管道Aggregate</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">this</span>.ctx.model.Template.aggregate([<br>        &#123; <span class="hljs-string">$match:</span> &#123; name &#125; &#125;,<br>        &#123; <span class="hljs-string">$sort:</span> &#123; <span class="hljs-string">create_time:</span> <span class="hljs-number">-1</span> &#125; &#125;,<br>        &#123; <span class="hljs-string">$group:</span> &#123; <span class="hljs-string">_id:</span> <span class="hljs-string">'$name'</span>, <span class="hljs-string">user_id:</span> &#123; <span class="hljs-string">$first:</span> <span class="hljs-string">'$modifier'</span> &#125; &#125; &#125;,<br>      ]);<br></code></pre></td></tr></table></figure><p>Mongoose聚合管道aggregate常用的操作有$project 、$match 、$group、$sort、$limit、$skip、$lookup 表关联</p><h4 id="批量操作bulkWrite"><a href="#批量操作bulkWrite" class="headerlink" title="批量操作bulkWrite"></a>批量操作bulkWrite</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">const template_list = await ctx.model.Template.aggregate([<br>     &#123; <span class="hljs-string">$sort:</span> &#123; <span class="hljs-string">create_time:</span> <span class="hljs-number">-1</span> &#125; &#125;,<br>     &#123; <span class="hljs-string">$group:</span> &#123; <span class="hljs-string">_id:</span> <span class="hljs-string">'$name'</span>, <span class="hljs-string">template_id:</span> &#123; <span class="hljs-string">$first:</span> <span class="hljs-string">'$_id'</span> &#125;, <span class="hljs-string">label:</span> &#123; <span class="hljs-string">$first:</span> <span class="hljs-string">'$label'</span> &#125; &#125; &#125;,<br>   ]);<br>   const update_value = [];<br>   template_list.forEach(item =&gt; &#123;<br>     <span class="hljs-keyword">if</span> (!item.label) &#123;<br>       update_value.push(&#123;<br><span class="hljs-symbol">         updateOne:</span> &#123;<br><span class="hljs-symbol">           filter:</span> &#123; <span class="hljs-string">_id:</span> item.template_id &#125;,<br><span class="hljs-symbol">           update:</span> &#123; <span class="hljs-string">label:</span> <span class="hljs-string">''</span> &#125;,<br>         &#125;,<br>       &#125;);<br>     &#125;<br>   &#125;);<br>   await ctx.model.Template.bulkWrite(update_value);<br></code></pre></td></tr></table></figure><p>可以进行一系列批量增加、删除、更新等操作。</p><p>mongoose还有非常多的方法可以提供给我的灵活使用，我们在使用的时候可以结合业务逻辑选择合适的方法来提高我们操作数据库的效率。在我们使用它之前可以认真的阅读<a href="https://mongoosejs.com/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>egg.js+mongoose实现二级评论</title>
    <link href="/myblog/2021/05/21/egg-js-mongoose%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA/"/>
    <url>/myblog/2021/05/21/egg-js-mongoose%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>1、首先我们先在model目录下新建comment.js文件，这里使用<strong>egg-mongoose</strong>进行配置表以及字段，这里关键需要parent_id作为父级字段，若默认为0则是第一级评论，如果为id，则是二级评论。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: Mongoose comment Schema,</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> mongoose = app.mongoose;<br>  <span class="hljs-keyword">const</span> Schema = mongoose.Schema;<br>  <span class="hljs-keyword">const</span> CommentSchema = <span class="hljs-keyword">new</span> Schema(&#123;<br>    <span class="hljs-keyword">from</span>: &#123; <span class="hljs-comment">/* 评论人id */</span><br>      type: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'User'</span>,<br>    &#125;,<br>    to: &#123; <span class="hljs-comment">/* 被评论人id */</span><br>      type: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'User'</span>,<br>    &#125;,<br>    content: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 内容 */</span><br>    create_time: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 评论时间 */</span><br>    book: &#123; <span class="hljs-comment">/* 书籍id */</span><br>      type: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'Book'</span>,<br>    &#125;,<br>    parent_id: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">0</span> &#125; <span class="hljs-comment">/* 父级 */</span><br>  &#125;);<br>  <span class="hljs-keyword">return</span> mongoose.model(<span class="hljs-string">'Comment'</span>, CommentSchema);<br>&#125;;<br></code></pre></td></tr></table></figure><p>2、在controller 目录下新建comment.js 用于编写 评论相关的控制器方法，这里我定义了新增评论和查询评论，使用<strong>egg-validate</strong>进行请求参数验证如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">'egg'</span>).Controller;<br><span class="hljs-comment">// 定义新增评论请求参数规则</span><br><span class="hljs-keyword">const</span> createCommentRule = &#123;<br>  <span class="hljs-keyword">from</span>: <span class="hljs-string">'string'</span>,<br>  to: &#123;<br>    type: <span class="hljs-string">'string'</span>,<br>    required: <span class="hljs-literal">false</span>,<br>  &#125;,<br>  content: <span class="hljs-string">'string'</span>,<br>  book: <span class="hljs-string">'string'</span>,<br>  parentId: &#123;<br>    type: <span class="hljs-string">'string'</span>,<br>    required: <span class="hljs-literal">false</span>,<br>  &#125;,<br>&#125;<br><span class="hljs-comment">// 定义查询评论请求参数规则</span><br><span class="hljs-keyword">const</span> findCommentRule = &#123;<br>  book: <span class="hljs-string">'string'</span>,<br>  page: <span class="hljs-string">'string'</span>,<br>  pageSize: <span class="hljs-string">'string'</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  <span class="hljs-keyword">async</span> create() &#123;<br>    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-keyword">this</span>;<br>    ctx.validate(createCommentRule, ctx.request.body);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.service.comment.createComment(ctx.request.body);<br>    ctx.body = result;<br>  &#125;<br>  <span class="hljs-keyword">async</span> find() &#123;<br>    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-keyword">this</span>;<br>    ctx.validate(findCommentRule, ctx.query);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.service.comment.findComment(ctx.query);<br>    ctx.body = result;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = CommentController;<br></code></pre></td></tr></table></figure><p>在对应的控制器方法调用service层里面的方法，在service的方法进行数据库操作与逻辑处理。</p><p>3、在service目录下新建comment.js用于编写评论相关service方法。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 评论相关Service</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> Service = <span class="hljs-built_in">require</span>(<span class="hljs-string">'egg'</span>).Service;<br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);<br><span class="hljs-keyword">const</span> dayjs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dayjs'</span>);<br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增评论</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Object&#125;</span> </span>data 包括评论人id，被评论人id，书籍id， 评论父级id，评论内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">async</span> createComment(data) &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">from</span>, to, content, book, parentId &#125; = data;<br>      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.model.Comment.create(&#123;<br>        <span class="hljs-keyword">from</span>,<br>        to,<br>        content,<br>        book,<br>        parent_id: parentId ? mongoose.Types.ObjectId(parentId) : <span class="hljs-number">0</span>,<br>        create_time: dayjs().unix(),<br>      &#125;);<br>      <span class="hljs-keyword">return</span> result ? app.config.msg.CREARE_SUCCESS : app.config.msg.CREARE_ERR;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询评论</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Object&#125;</span> </span>data 包括书籍id，页码，页数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">async</span> findComment(data) &#123;<br>      <span class="hljs-keyword">const</span> &#123; book, page, pageSize &#125; = data<br>      <span class="hljs-keyword">const</span> totalNum = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.model.Comment.find(&#123; <span class="hljs-attr">book</span>: mongoose.Types.ObjectId(book), <span class="hljs-attr">parent_id</span>: <span class="hljs-number">0</span> &#125;).countDocuments();<br>      <span class="hljs-keyword">const</span> oneList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.model.Comment.find(&#123; <span class="hljs-attr">book</span>: mongoose.Types.ObjectId(book), <span class="hljs-attr">parent_id</span>: <span class="hljs-number">0</span> &#125;)<br>        .populate(&#123;<br>          path: <span class="hljs-string">'from'</span>,<br>          select: &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">image</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;<br>        &#125;)<br>        .populate(&#123;<br>          path: <span class="hljs-string">'to'</span>,<br>          select: &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">image</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;<br>        &#125;)<br>        .sort(&#123; <span class="hljs-attr">create_time</span>: <span class="hljs-number">1</span>&#125;)<br>        .skip((<span class="hljs-built_in">parseInt</span>(page) - <span class="hljs-number">1</span>) * <span class="hljs-built_in">parseInt</span>(pageSize))<br>        .limit(<span class="hljs-built_in">parseInt</span>(pageSize)).lean();<br>        <span class="hljs-keyword">const</span> Comment = <span class="hljs-keyword">this</span>.ctx.model.Comment<br>        <span class="hljs-keyword">var</span> promises = oneList.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> Comment.find(&#123;<br>              book: mongoose.Types.ObjectId(book),<br>              parent_id: item._id<br>          &#125;)<br>          .populate(&#123;<br>            path: <span class="hljs-string">'from'</span>,<br>            select: &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">image</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;<br>          &#125;)<br>          .populate(&#123;<br>            path: <span class="hljs-string">'to'</span>,<br>            select: &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">image</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;<br>          &#125;)<br>          .sort(&#123; <span class="hljs-attr">create_time</span>: <span class="hljs-number">1</span>&#125;)<br>          .select(<span class="hljs-string">'-__v'</span>).lean()<br>      &#125;);<br>      <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises)<br>      oneList.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        item.items = []<br>        list.forEach(<span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (code.length &gt; <span class="hljs-number">0</span> &amp;&amp; item._id == code[<span class="hljs-number">0</span>].parent_id) &#123;<br>              item.items = code<br>          &#125;<br>        &#125;)<br>      &#125;)<br>      <span class="hljs-keyword">return</span> oneList ? &#123; <span class="hljs-attr">bean</span>: &#123;<br>        records: oneList,<br>        current: page,<br>        size: oneList.length,<br>        total: totalNum,<br>      &#125;, ...app.config.msg.GET_SUCCESS &#125; : app.config.msg.GET_ERR;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> CommentService;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注：首先我们需要查询一级评论的分页数据，然后用map遍历一级评论列表，返回一个promises数组，数组的每一项是查询该一级评论下的所有二级评论，我这里没有进行分页，也可以加上分页。使用Promise.all异步执行所有的查询函数，完成后的结果赋值为list，最后遍历一级评论列表与二级评论列表，当一级评论id 等于 二级评论列表中parent_id时候 给当前一级评论列表增加 items属性用于存放它的二级评论。</p><p>最后在router.js中定义接口路径与请求类型，如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// 新建评论</span><br>router.post(<span class="hljs-string">'/api/comment/create'</span>, controller.<span class="hljs-built_in">comment</span>.create);<br><span class="hljs-comment">// 查询评论</span><br>router.get(<span class="hljs-string">'/api/comment/find'</span>, controller.<span class="hljs-built_in">comment</span>.<span class="hljs-built_in">find</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目使用axios拦截器封装api</title>
    <link href="/myblog/2021/05/21/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B0%81%E8%A3%85api/"/>
    <url>/myblog/2021/05/21/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B0%81%E8%A3%85api/</url>
    
    <content type="html"><![CDATA[<p>在api目录下新建一个http.js，实现代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> Qs <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store'</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils'</span> <span class="hljs-comment">//工具类</span><br><span class="hljs-keyword">import</span> &#123; Toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'mand-mobile'</span><br><br><span class="hljs-keyword">const</span> instance = axios.create(&#123;<br>  baseURL: <span class="hljs-string">''</span>, <span class="hljs-comment">// 后端接口根目录</span><br>  message: <span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-comment">// 错误控制</span><br><span class="hljs-keyword">const</span> errorHandle = <span class="hljs-function">(<span class="hljs-params">status, message</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (status) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:<br>      <span class="hljs-comment">// store.dispatch('logout')</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>      Toast.failed(message)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// axios请求拦截器</span><br><span class="hljs-comment">/* 拦截器一般做什么？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">　　　　1. 修改请求头的一些配置项</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">　　　　2. 给请求的过程添加一些请求的图标</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">　　　　3. 给请求添加参数 */</span><br>instance<br>  .interceptors<br>  .request<br>  .use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = utils.env !== <span class="hljs-string">'dev'</span> ? store.state.auth.token : <span class="hljs-string">''</span><br>    token &amp;&amp; (config.headers.common.token = token)<br>    <span class="hljs-keyword">if</span> (config.method === <span class="hljs-string">'post'</span> &amp;&amp; config.data) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(config.data) !== <span class="hljs-string">'[object FormData]'</span>) &#123;<br>        config.data = Qs.stringify(config.data)<br>      &#125;<br>      config.headers.common[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'multipart/form-data'</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> config<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>  &#125;)<br><span class="hljs-comment">// 响应拦截器，接受响应接口后的统一处理</span><br>instance<br>  .interceptors<br>  .response<br>  .use(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    response.success = response.data.success<br>    <span class="hljs-keyword">if</span> (response.config.message) &#123;<br>      <span class="hljs-keyword">if</span> (!response.success) &#123;<br>        response.data.message &amp;&amp; Toast.failed(response.data.message)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        response.config.method === <span class="hljs-string">'post'</span> &amp;&amp; Toast.succeed(response.data.message || <span class="hljs-string">'操作成功'</span>)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> response<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; response &#125; = error<br>    response<br>      ? errorHandle(response.status, response.data.message || <span class="hljs-string">'网络连接失败，请稍后重试！'</span>)<br>      : Toast.info(<span class="hljs-string">'网络连接失败，请稍后重试！'</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>  &#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createAPI = <span class="hljs-function">(<span class="hljs-params">url, method, params, config = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (method === <span class="hljs-string">'get'</span>) &#123;<br>    config.params = params<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    config.data = params<br>  &#125;<br>  <span class="hljs-keyword">return</span> instance(&#123;<br>    url,<br>    method,<br>    ...config<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance<br></code></pre></td></tr></table></figure><p>配置接口方式：<br>在api目录下新建个index.js<br><code>import { createAPI } from &#39;./http&#39;</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>&#123;<br>  wxOuth: params =&gt; createAPI(<span class="hljs-string">'/wechat/getOauthUrl'</span>, <span class="hljs-string">'get'</span>, params)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在我们的vue组件中引入即可 <code>import * as api from &#39;@/api&#39;</code><br>调用方式为： api.wxOuth(params).then(res=&gt; {}).catch(err =&gt; {})</p>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web端的微信支付可分为JSAPI与H5</title>
    <link href="/myblog/2021/05/21/web%E7%AB%AF%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%AF%E5%88%86%E4%B8%BAJSAPI%E4%B8%8EH5/"/>
    <url>/myblog/2021/05/21/web%E7%AB%AF%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%AF%E5%88%86%E4%B8%BAJSAPI%E4%B8%8EH5/</url>
    
    <content type="html"><![CDATA[<h3 id="web端的微信支付可分为JSAPI与H5"><a href="#web端的微信支付可分为JSAPI与H5" class="headerlink" title="web端的微信支付可分为JSAPI与H5"></a>web端的微信支付可分为JSAPI与H5</h3><p>JSAPI使用场景为微信内部，而H5支付则是使用在非微信下的外部浏览器。</p><h4 id="1-JSAPI"><a href="#1-JSAPI" class="headerlink" title="1.JSAPI"></a>1.JSAPI</h4><p>在微信内部可以直接唤起微信浏览器的内置对象<code>WeixinJSBridge</code><br>废话不多说直接上代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 调用后端接口拿到JSAPI支付所需参数，我在beforeRouteEnter的时候调用。</span><br>api.apply.jsApiPay(obj).then(res =&gt; &#123;<br>          <span class="hljs-keyword">if</span> (res.data.code === <span class="hljs-string">'0000'</span>) &#123;<br>            vm.<span class="hljs-keyword">params</span> = res.data.bean<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            alert(<span class="hljs-string">'微信支付调起失败！'</span>)<br>          &#125;<br>        &#125;).<span class="hljs-keyword">catch</span>(err =&gt; &#123;<br>          alert(err)<br>        &#125;)<br><br><span class="hljs-comment">// 点击支付时候调用</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> WeixinJSBridge === <span class="hljs-string">'undefined'</span>) &#123;<br>        <span class="hljs-keyword">if</span> (document.addEventListener) &#123;<br>          document.addEventListener(<span class="hljs-string">'WeixinJSBridgeReady'</span>, <span class="hljs-keyword">this</span>.onBridgeReady(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">params</span>), <span class="hljs-literal">false</span>)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (document.attachEvent) &#123;<br>          document.attachEvent(<span class="hljs-string">'WeixinJSBridgeReady'</span>, <span class="hljs-keyword">this</span>.onBridgeReady(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">params</span>))<br>          document.attachEvent(<span class="hljs-string">'onWeixinJSBridgeReady'</span>, <span class="hljs-keyword">this</span>.onBridgeReady(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">params</span>))<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.onBridgeReady(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">params</span>)<br>      &#125;<br><br><br>onBridgeReady (<span class="hljs-keyword">params</span>) &#123;<br>      <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span><br>      WeixinJSBridge.invoke(<br>        <span class="hljs-string">'getBrandWCPayRequest'</span>,<br>        &#123;<br>          appId: <span class="hljs-keyword">params</span>.appId, <span class="hljs-comment">// 公众号名称，由商户传入</span><br>          timeStamp: <span class="hljs-keyword">params</span>.timeStamp, <span class="hljs-comment">// 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符</span><br>          nonceStr: <span class="hljs-keyword">params</span>.nonceStr, <span class="hljs-comment">// 支付签名随机串，不长于 32 位</span><br>          package: <span class="hljs-keyword">params</span>.prepay_id, <span class="hljs-comment">// 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*）</span><br>          signType: <span class="hljs-keyword">params</span>.signType, <span class="hljs-comment">// 签名方式，默认为'SHA1'，使用新版支付需传入'MD5'</span><br>          paySign: <span class="hljs-keyword">params</span>.paySign <span class="hljs-comment">// 支付签名</span><br>        &#125;,<br>        function (res) &#123;<br>          <span class="hljs-keyword">if</span> (res.err_msg === <span class="hljs-string">'get_brand_wcpay_request:ok'</span>) &#123;<br>            that.queryOrder() <span class="hljs-comment">// 这里是查询订单是否支付完成，然后执行成功和失败的业务逻辑</span><br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.err_msg === <span class="hljs-string">'get_brand_wcpay_request:fail'</span>) &#123;<br>            alert(<span class="hljs-string">'支付失败！'</span>)<br>          &#125;<br>        &#125;<br>      )<br>    &#125;,<br></code></pre></td></tr></table></figure><p>在微信支付的回调函数中，当res.err_msg 为<br>get_brand_wcpay_request:ok 时，支付状态不一定准确，因此需要调用后端的查询订单接口，查询是否支付完成，然后再执行相应的逻辑。</p><h4 id="2、H5支付"><a href="#2、H5支付" class="headerlink" title="2、H5支付"></a>2、H5支付</h4><p>h5相对简单，前端只需要跳转到后端返回的链接即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">api.apply.h5Pay(&#123;<br>            title: <span class="hljs-string">''</span><br>            orderNum: <span class="hljs-string">''</span>,<br>            expireMinute: <span class="hljs-number">10</span>,<br>            redirectUrl: <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">window</span>.location.origin&#125;</span>/pay/card?orderId=<span class="hljs-subst">$&#123;vm.orderId&#125;</span>`</span><br>          &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>            vm.h5PayUrl = res.data.bean<br>            <span class="hljs-comment">// 查询订单</span><br>          &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>            alert(err)<br>          &#125;)<br></code></pre></td></tr></table></figure><p>第一步，请求后端接口，需要传支付的标题，订单号，支付时间，重定向链接。</p><p>第二部，们只需要点击支付按钮时候跳转至后端返回链接即可。<br><code>window.location.href = this.h5PayUrl</code><br>需要注意的是H5支付查询订单需要用户去手动触发，因此需要增加一个确定订单的弹层。如图：<br><img src="https://i.ibb.co/PYzh0ZC/confirm-pay-layer.png" alt="image.png"><br>查询订单是否支付成功与JSAPI一致~</p>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>微信体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端日常开发常用技巧与方法</title>
    <link href="/myblog/2020/06/09/%E5%89%8D%E7%AB%AF%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/myblog/2020/06/09/%E5%89%8D%E7%AB%AF%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h4 id="盒子边倾斜"><a href="#盒子边倾斜" class="headerlink" title="盒子边倾斜"></a>盒子边倾斜</h4><p>clip-path: polygon(12% 0, 100% 0, 100% 100%, 0 100%);</p><h4 id="禁止点击事件-鼠标事件“穿透”"><a href="#禁止点击事件-鼠标事件“穿透”" class="headerlink" title="禁止点击事件/鼠标事件“穿透”"></a>禁止点击事件/鼠标事件“穿透”</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> * &#123;<br>    <span class="hljs-attribute">pointer-events</span>: none;   <span class="hljs-comment">/*链接啊，点击事件啊，都没有效果了*/</span> <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用来控制元素在移动设备上使用滚动回弹效果"><a href="#用来控制元素在移动设备上使用滚动回弹效果" class="headerlink" title="用来控制元素在移动设备上使用滚动回弹效果"></a>用来控制元素在移动设备上使用滚动回弹效果</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.main</span>&#123;<br>    <span class="hljs-attribute">-webkit-overflow-scrolling</span>: touch;<br>&#125;<br></code></pre></td></tr></table></figure><p>可解决在IOS中使用overflow:auto 形成的滚动条，滚动不流畅的情况</p><h4 id="文字渐变效果"><a href="#文字渐变效果" class="headerlink" title="文字渐变效果"></a>文字渐变效果</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text-gradient</span>&#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">135deg</span>, deeppink, deepskyblue);<br>    <span class="hljs-attribute">-webkit-background-clip</span>: text;<br>    <span class="hljs-attribute">color</span>: transparent;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="css三角形"><a href="#css三角形" class="headerlink" title="css三角形"></a>css三角形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#triangle-up</span> &#123;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br><br> <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br><br> <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br><br> <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><h4 id="JavaScript中检测数组的方法"><a href="#JavaScript中检测数组的方法" class="headerlink" title="JavaScript中检测数组的方法"></a>JavaScript中检测数组的方法</h4><p>(1)、typeof操作符</p><p>这种方法对一些常用的类型检查没有问题，但对array和null 都判断为object<br>(2)、instanceof操作符</p><p>这个操作符是检测对象的原型链是否指向构造函数的prototype对象的<br>(3)、对象的constructor属性</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> arr = []<br><br>console.log(arr<span class="hljs-function">.<span class="hljs-keyword">constructor</span> === <span class="hljs-title">Array</span>) <span class="hljs-comment">// true</span></span><br></code></pre></td></tr></table></figure><p>(4)、Object.prototype.toString</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> arr = []<br><br>console.<span class="hljs-built_in">log</span>(Object.prototype.toString.<span class="hljs-built_in">call</span>(arr) === <span class="hljs-string">'[object Array]'</span>) // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>(5)、Array.isArray()</p><h4 id="常用的字符串操作"><a href="#常用的字符串操作" class="headerlink" title="常用的字符串操作"></a>常用的字符串操作</h4><ol><li>字符串转化toString()</li><li>字符串分隔split()</li><li>字符串替换replace()</li><li>获取长度length</li><li>查询子字符串 indexOf</li><li>返回指定位置的字符串或字符串编码 charAt charCodeAt</li><li>字符串匹配 match</li><li>字符串拼接concat</li><li>字符串的切割或提取slice() substring() substr()</li><li>字符串大小写转化 toLowerCase toUpperCase</li><li>字符串去空格 trim() 用来删除字符串前后的空格</li></ol><p>其中第9中三者的区别如下：<br>（1）slice(), 参数可以是负数，负数表示从字符串最后一个位置开始切割到对应结束位置<br>（2）substring()，参数不可为负数，切割第一个位置到第二个位置的字符串<br>（3）substr()， 参数不可为负数，第一个参数是开始位置，第二个参数为切割的长度<br>字符串去重<br>const str = ‘11122223333’<br>const arr = str.split(‘’)<br>const uniqueStr = […new Set(arr)].join(‘’)</p><h4 id="常用的数组操作"><a href="#常用的数组操作" class="headerlink" title="常用的数组操作"></a>常用的数组操作</h4><p>1、Array.map()<br>此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组<br>2、Array.forEach()<br>此方法是将数组中的每个元素执行传进提供的函数，没有返回值，注意和map方法区分<br>3、Array.filter()<br>此方法是将满足条件的元素作为一个新数组返回<br>4、Array.every()<br>此方法将数组所有元素进行判断返回一个布尔值，如果所有元素都符合判断条件，则返回true，否则返回false<br>5、Array.some()<br>此方法将数组所有元素进行判断返回一个布尔值,如果有一个元素满足判断条件，则返回true，所有元素都不满足则返回false<br>6、Array.reduce()<br>此方法为所有元素调用返回函数<br>7、Array.push()<br>在数组最后面添加新元素<br>8、Array.shift()<br>删除数组第一个元素<br>9、Array.pop()<br>删除数组最后一个元素<br>10、Array.unshift()<br>在数组最前面增加元素<br>11、Array.isArray()<br>判断是否为一个数组<br>12、Array.concat()<br>数组拼接<br>13、Array.toString()<br>数组转化为字符串<br>14、Array.join()<br>数组转化为字符串，并用第一个参数作为连接符<br>15、Array.splice(开始位置，删除个数，元素)<br>####常用对象方法<br>1、Object.assign()<br>用于克隆，两个参数，将第二个对象分配到第一个中<br>2、Object.is()<br>用于判断两个值是否相同<br>//注意，该函数与==运算符不同，不会强制转换任何类型， 应该更加类似于===，但值得注意的是它会将+0和-0视作不同值<br>3、Object.keys()<br>用于返回对象可枚举的属性和方法的名称，返回一个属性或方法名称的字符串数组。<br>4、Object.defineProperty()<br>劫持变量的set和get方法,将属性添加到对象，或修改现有属性的特性</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">var</span> a = &#123;&#125;;<br>Object.defineProperty(a, <span class="hljs-string">'name'</span>, &#123;<br>    <span class="hljs-keyword">value</span> : <span class="hljs-string">'kong'</span>,<br>    enumerable : <span class="hljs-literal">true</span> <span class="hljs-comment">//该属性是否可枚举</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>5、Object.defineProperties()<br>可添加多个属性,与Object.defineProperty()对应,<br>6、isPrototypeOf</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> a();<br><span class="hljs-built_in">console</span>.log(a.prototype.isPrototypeOf(b));<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="安卓监听可视区域变化，让输入框移动至可视区域"><a href="#安卓监听可视区域变化，让输入框移动至可视区域" class="headerlink" title="安卓监听可视区域变化，让输入框移动至可视区域"></a>安卓监听可视区域变化，让输入框移动至可视区域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Android/gi</span>.test(navigator.userAgent)) &#123;<br>          <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.activeElement.tagName === <span class="hljs-string">'INPUT'</span> || <span class="hljs-built_in">document</span>.activeElement.tagName === <span class="hljs-string">'TEXTAREA'</span>) &#123;<br>              <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-built_in">document</span>.activeElement.scrollIntoViewIfNeeded();<br>              &#125;, <span class="hljs-number">0</span>);<br>            &#125;<br>          &#125;);<br>        &#125;;<br></code></pre></td></tr></table></figure><h4 id="vue中平滑滚动到某个位置"><a href="#vue中平滑滚动到某个位置" class="headerlink" title="vue中平滑滚动到某个位置"></a>vue中平滑滚动到某个位置</h4><p>this.$refs.rule.scrollIntoView({ block: ‘start’, behavior: ‘smooth’ })</p><h4 id="好用的JavaSrcipt库与模块（包）"><a href="#好用的JavaSrcipt库与模块（包）" class="headerlink" title="好用的JavaSrcipt库与模块（包）"></a>好用的JavaSrcipt库与模块（包）</h4><h5 id="日期时间处理库"><a href="#日期时间处理库" class="headerlink" title="日期时间处理库"></a>日期时间处理库</h5><p>1、<a href="http://momentjs.cn/" target="_blank" rel="noopener">monent.js</a><br>2、<a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener">day.js</a><br>day相对于monent要轻量许多</p><h5 id="高精度数学运算"><a href="#高精度数学运算" class="headerlink" title="高精度数学运算"></a>高精度数学运算</h5><p><a href="https://developer.aliyun.com/mirror/npm/package/number-precision" target="_blank" rel="noopener">number-precision</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>strip(num)         <span class="hljs-comment">// strip a number to nearest right number</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>plus(num1, num2, num3, ...)   <span class="hljs-comment">// addition, num + num2 + num3, two numbers is required at least.</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>minus(num1, num2, num3, ...)  <span class="hljs-comment">// subtraction, num1 - num2 - num3</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>times(num1, num2, num3, ...)  <span class="hljs-comment">// multiplication, num1 * num2 * num3</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>divide(num1, num2, num3, ...) <span class="hljs-comment">// division, num1 / num2 / num3</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>round(num, ratio)  <span class="hljs-comment">// round a number based on ratio</span><br></code></pre></td></tr></table></figure><h5 id="实用工具库"><a href="#实用工具库" class="headerlink" title="实用工具库"></a>实用工具库</h5><p><a href="https://www.lodashjs.com/" target="_blank" rel="noopener">Lodash</a><br>lodash 是一个 JavaScript 实用工具库，提供一致性，及模块化、性能和配件等功能。<br>Lodash 消除了处理数组的麻烦，从而简化了 JavaScript、 数字、对象、字符串等</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>javaScript</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的数据类型及深浅拷贝介绍</title>
    <link href="/myblog/2020/06/09/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BB%8B%E7%BB%8D/"/>
    <url>/myblog/2020/06/09/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><p>JS分为两种数据类型：<br><strong>基本数组类型</strong>： Number、String、Boolean、Null、Undefined、Symbol<br><strong>引用数组类型</strong>：Object(JS中除了基本数据类型，其他都是对象。例如数组、函数、正则表达式等)</p><h5 id="（1）基本数据类型（存放在栈中）"><a href="#（1）基本数据类型（存放在栈中）" class="headerlink" title="（1）基本数据类型（存放在栈中）"></a>（1）基本数据类型（存放在栈中）</h5><p>基本数据类型是指直接存放在栈中的简单数据段，数据大小确定，内存k空间可分配，按值存放和访问<br><strong>注：栈(stack)和堆（heap）</strong><br>stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放</p><h5 id="（2）引用数据类型（存放在堆内存中的对象）"><a href="#（2）引用数据类型（存放在堆内存中的对象）" class="headerlink" title="（2）引用数据类型（存放在堆内存中的对象）"></a>（2）引用数据类型（存放在堆内存中的对象）</h5><p>引用数据类型是存放在堆内存里的对象，而指向堆内存值的引用也就是指针是存在栈内存中的。</p><h3 id="2、浅拷贝"><a href="#2、浅拷贝" class="headerlink" title="2、浅拷贝"></a>2、浅拷贝</h3><p>当我们使用对象拷贝时，如果属性是对象或者数组时，我们只是拷贝的数组或对象的引用地址，因此两者的属性值会指向同一个内存空间。实现数组的片浅拷贝使用concat、slice<br>这个两个是技巧类，如何实现一个浅拷贝呢？简单的思路是遍历对象，把属性和属性值都放在一个新的对象中<br>如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> shallowCopy = <span class="hljs-function"><span class="hljs-keyword">function</span></span>(obj) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (typeof obj !== <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 根据obj的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span> = obj instanceof <span class="hljs-keyword">Array</span> ? [] : <span class="hljs-type"></span>&#123;&#125;;<br>  <span class="hljs-comment">// 遍历obj，并且判断是obj的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>      <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>          <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[key] = obj[key];<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let a = &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'456'</span> &#125;&#125;<br>const b = shallowCopy(a)<br>b.obj.name = <span class="hljs-string">'666'</span><br>console.log(b) // &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'666'</span> &#125; &#125;<br>console.log(a) // &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'666'</span> &#125; &#125;<br></code></pre></td></tr></table></figure><p>这样如果改变b中的对象，a中的对象也会同时改变。</p><h3 id="3、深拷贝"><a href="#3、深拷贝" class="headerlink" title="3、深拷贝"></a>3、深拷贝</h3><p>实现数组或对象的深拷贝，可以使用JSON.parse(JSON.stringify(obj))<br>如何手写一个深度拷贝呢？思路是通过递归调用拷贝函数</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> deepCopy = <span class="hljs-function"><span class="hljs-keyword">function</span></span>(obj) &#123;<br>  <span class="hljs-keyword">if</span> (typeof obj !== <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span> = obj instanceof <span class="hljs-keyword">Array</span> ? [] : <span class="hljs-type"></span>&#123;&#125;<br>  <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>      <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[key] = typeof obj[key] === <span class="hljs-string">'object'</span> ? deepCopy(obj[key]) : <span class="hljs-type">obj</span>[key]<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span><br><span class="hljs-type"></span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let a = &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'456'</span> &#125;&#125;<br>const b = deepCopy(a)<br>b.obj.name = <span class="hljs-string">'666'</span><br>console.log(b) // &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'666'</span> &#125; &#125;<br>console.log(a) // &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'456'</span> &#125; &#125;<br></code></pre></td></tr></table></figure><p>这样就实现了深度拷贝，当改变b中对象值时，a没有发生变化。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
