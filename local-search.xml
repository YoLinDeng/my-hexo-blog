<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微信小程序内嵌H5页面，完成微信支付闭环</title>
    <link href="/my-hexo-blog/2022/09/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%86%85%E5%B5%8CH5%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%AE%8C%E6%88%90%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%97%AD%E7%8E%AF/"/>
    <url>/my-hexo-blog/2022/09/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%86%85%E5%B5%8CH5%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%AE%8C%E6%88%90%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%97%AD%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文介绍如何在小程序中内嵌H5，并完成微信支付的整个流程闭环。我们知道微信H5支付是通过生成特定的支付链接，并跳转到这个链接去完成支付操作的。但在微信小程序中对于内嵌的页面域名具有白名单限制，如果支付链接是第三方的无法做加白处理。</p><p>这个时候我们就得换个思路了，该怎么解决呢？咱们往下看。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="小程序入口"><a href="#小程序入口" class="headerlink" title="小程序入口"></a>小程序入口</h4><p>在微信小程序中新建一个页面，使用web-view组件作为内嵌H5的入口，由于后续支付需要用到<strong>appId</strong>以及<strong>openId</strong>信息，因此需要对url做带参做处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// page.wxml<br><span class="hljs-tag">&lt;<span class="hljs-name">web-view</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"&#123;&#123;url&#125;&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>url处理逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">Page(&#123;<br>data: &#123;<br>    url: <span class="hljs-string">''</span><br>  &#125;,<br>  onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>    wx.showLoading()<br>    wx.login(&#123;<br>      success: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> code = res.code<br>        api.getUserOpenId(&#123;<br>          code<br>        &#125;, data =&gt; &#123;<br>          <span class="hljs-keyword">const</span> openId = data.bean<br>          <span class="hljs-keyword">const</span> params = &#123;<br>            wxAppletId: <span class="hljs-string">'your appId'</span>,<br>            wxAppletOpenId: openId,<br>            ...options <span class="hljs-comment">// 小程序启动路径的参数</span><br>          &#125;<br>          <span class="hljs-keyword">this</span>.setData(&#123;<br>            url: <span class="hljs-keyword">this</span>.stringifyUrlArgs(<span class="hljs-string">'your h5 url'</span>, params)<br>          &#125;)<br>          wx.hideLoading()<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;,<br>  stringifyUrlArgs(url, params) =&gt; &#123;<br>    url += (<span class="hljs-regexp">/\?/</span>).test(url) ? <span class="hljs-string">'&amp;'</span> : <span class="hljs-string">'?'</span><br>    url += <span class="hljs-built_in">Object</span>.keys(params).map(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>`</span>).join(<span class="hljs-string">'&amp;'</span>)<br>    <span class="hljs-keyword">return</span> url<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在页面onload的时候，调用API<strong>wx.login</strong>获取code，传递给后端换取该用户的<strong>openId</strong>，然后将appId、openId、以及启动路径参数拼接到你的H5 url 后面。这个url可以是个短链，方便后续修改不需要重新提交小程序代码审核，缩短发版的时间。只需要去修改该短链对应的H5链接即可。</p><h4 id="H5-页面处理"><a href="#H5-页面处理" class="headerlink" title="H5 页面处理"></a>H5 页面处理</h4><p>当我们在小程序入口处理好url后，会通过web-view组件进行访问H5链接，这个时候链接上携带了支付所必需的参数，我们上面提到如果这时候H5页面仍然还是调用生成H5支付链接的方式的话，会有页面白名单限制，导致第三方支付链接页面无法访问的情况。</p><p>这个时候我们可以绕开这个点，竟然是在小程序内部，我们可不可以使用<strong>小程序支付</strong>呢？答案当然是可以！</p><p><strong>处理的过程：</strong></p><p>H5页面请求后端支付接口获取微信小程序支付所必须的参数，这个时候appId和openId都是必要的，其他的信息则根据具体需求而定。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 微信小程序支付参数</span><br><span class="hljs-keyword">interface</span> appletPayParams &#123;<br>  timeStamp: <span class="hljs-string">'string'</span>, <span class="hljs-comment">// 时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间</span><br>    nonceStr: <span class="hljs-string">'string'</span>, <span class="hljs-comment">// 随机字符串，长度为32个字符以下</span><br>    package: <span class="hljs-string">'string'</span>, <span class="hljs-comment">// 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=***</span><br>    signType?: <span class="hljs-string">'string'</span>, <span class="hljs-comment">// 签名算法，应与后台下单时的值一致</span><br>    paySign: <span class="hljs-string">'string'</span> <span class="hljs-comment">// 签名，具体见微信支付文档</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于H5是内嵌在小程序的web-view里面，当成功从后端获取到支付所需的参数后，需要通过web-view 跳到内部小程序的方式，跳转到对应的小程序支付页面进行支付操作，这个时候得使用wx.miniProgram.redirectTo进行处理，将获取到的支付参数encodeURIComponent一下再拼接到链接上。注意url是一个相对路径，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">wx.miniProgram.redirectTo(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">`../insure-pay/insure-pay?payData=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-built_in">JSON</span>.stringify(bean.applet))&#125;</span>`</span> &#125;)<br></code></pre></td></tr></table></figure><h4 id="小程序支付页"><a href="#小程序支付页" class="headerlink" title="小程序支付页"></a>小程序支付页</h4><p>新建一个支付页面，当从web-view内嵌H5页面跳转到支付页的时候，处理支付的逻辑处理，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">Page(&#123;<br>  onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> payData = <span class="hljs-built_in">decodeURIComponent</span>(options.payData) <span class="hljs-comment">// 支付参数</span><br>    <span class="hljs-keyword">let</span> pageSuccessUrl = <span class="hljs-string">'../pay-success/pay-success'</span> <span class="hljs-comment">// 成功页</span><br>    <span class="hljs-keyword">let</span> pageFailUrl = <span class="hljs-string">'./insure-repay/insure-repay'</span> <span class="hljs-comment">// 失败页，重新支付</span><br>    wx.requestPayment(&#123;<br>      ...JSON.parse(payData),<br>      success(res) &#123;<br>        wx.redirectTo(&#123;<br>          url: pageSuccessUrl,<br>        &#125;)<br>      &#125;,<br>      fail(err) &#123;<br>        <span class="hljs-built_in">console</span>.log(err)<br>        wx.redirectTo(&#123;<br>          url: <span class="hljs-string">`<span class="hljs-subst">$&#123;pageFailUrl&#125;</span>?payData=<span class="hljs-subst">$&#123;options.payData&#125;</span>`</span>,<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>进入到支付页，会通过<strong>wx.requestPayment</strong>调起支付，将链接上的参数decodeURIComponent出来，传入API中，可通过回调函数success和fail监听成功和失败，并跳转到不同的处理页面。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大致的流程可以总结为一下几点：</p><ul><li>在微信小程序建立一个入口页面，通过web-view内嵌H5，在这个页面onload的时候获取用户的openId以及appId并携带到H5链接上</li><li>在H5中获取链接携带的appId和openId，请求后端获取小程序支付所需的参数，并通过wx.miniProgram.redirectTo，从web-view重定向到小程序支付页。</li><li>在小程序支付页获取链接上携带的支付参数，通过wx.requestPaymen唤起支付，并处理成功和失败的逻辑。</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长列表优化之虚拟列表</title>
    <link href="/my-hexo-blog/2022/09/01/%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/"/>
    <url>/my-hexo-blog/2022/09/01/%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虚拟列表是前端长列表优化的一个解决方案，就是将一个需要渲染所以列表项的长列表，改为只渲染可视区域内的列表项，但滚动效果还是要和渲染所有列表项的长列表一样。</p><p>使用场景： 在移动端使用下拉加载数据的时候，随着不断从服务端拉取数据，数据列表内容越来越多，导致创建了很多的节点，这个时候vue的diff就需要对比很多次，造成性能消耗和内存占用。</p><p>长列表渲染大量节点导致的问题：</p><ul><li>占用大量 GPU 资源，导致卡顿</li><li>节点越多，就越耗费性能</li></ul><p>虚拟列表的实现分两种：</p><ul><li>列表项高度固定</li><li>列表项高度动态</li></ul><p>下面以列表项高度固定为例子</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>在编码之前需要了解的信息：</p><ul><li>容器高度（可视区高度）：viewport</li><li>列表项高度：itemSize</li><li>可视区域展示列表个数： viewCount</li><li>列表长度：phantomHeight （itemSize * 列表个数）</li><li>第一个元素顶部的距离：startOffset</li><li>开始元素的下标： startIndex</li><li>结尾元素的下标： endIndex</li></ul><p>关键点就是确定需要渲染个列表个数，然后根据滚动时动态改变startIndex、endIndex、startOffset值，然后对列表项数据进行过滤切割，获取需要渲染的数据列表。</p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang&#x3D;&#39;ts&#39;&gt;<br>import &#123; PropType, ref, computed &#125; from &#39;vue&#39;<br>interface listItem &#123;<br>  index: number,<br>  num: number<br>&#125;<br>const props &#x3D; defineProps(&#123;<br>  data: &#123;<br>    type: Array as PropType&lt;listItem[]&gt;,<br>    default: () &#x3D;&gt; &#123;&#125;<br>  &#125;<br>&#125;)<br>const viewport &#x3D; ref&lt;HTMLElement&gt;()<br>let startIndex &#x3D; ref&lt;number&gt;(0)<br>let itemSize &#x3D; 100<br>let viewCount &#x3D; 10<br>let phantomHeight &#x3D; itemSize * props.data.length<br><br>let startOffset &#x3D; computed(() &#x3D;&gt; &#123;<br>  return startIndex.value * itemSize<br>&#125;)<br><br>let endIndex &#x3D; computed(() &#x3D;&gt; &#123;<br>  return startIndex.value + viewCount<br>&#125;)<br>let filterData &#x3D; computed(() &#x3D;&gt; &#123;<br>  return props.data.slice(startIndex.value, endIndex.value)<br>&#125;)<br>const scrollListBox &#x3D; () &#x3D;&gt; &#123;<br>  startIndex.value &#x3D; Math.floor((viewport.value?.scrollTop || 0) &#x2F; itemSize)<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>&#123;&#123;startIndex&#125;&#125;<br>&#123;&#123;endIndex&#125;&#125;<br>  &lt;div class&#x3D;&quot;viewport&quot; @scroll&#x3D;&quot;scrollListBox&quot; ref&#x3D;&quot;viewport&quot;&gt;<br>    &lt;div class&#x3D;&quot;v-list&quot; :style&#x3D;&quot;&#123; height: phantomHeight + &#39;px&#39;, paddingTop: startOffset + &#39;px&#39;&#125;&quot;&gt;<br>      &lt;div class&#x3D;&quot;v-list-item&quot; v-for&#x3D;&quot;item in filterData&quot; :key&#x3D;&quot;item.num&quot;&gt;<br>        &#123;&#123;item.num&#125;&#125;<br>      &lt;&#x2F;div&gt;<br>    &lt;&#x2F;div&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;style scoped&gt;<br>.viewport &#123;<br>  width: 500px;<br>  height: 500px;<br>  overflow: scroll;<br>&#125;<br>.v-list-item &#123;<br>  height: 100px;<br>  width: 100%;<br>  background: #fff;<br>  color: #000;<br>  line-height: 100px;<br>  border-bottom: 1px solid #ccc;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解pinia，它vuex相比有什么不同？</title>
    <link href="/my-hexo-blog/2022/08/26/%E4%BA%86%E8%A7%A3pinia%EF%BC%8C%E5%AE%83vuex%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <url>/my-hexo-blog/2022/08/26/%E4%BA%86%E8%A7%A3pinia%EF%BC%8C%E5%AE%83vuex%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>Pinia 与vuex都是vue的全局状态管理器，可以说pinia就是vuex5，接下来本文通过vue3的形式来对比一下这两个全局状态管理器有何不同点。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// vuex</span><br>npm <span class="hljs-selector-tag">i</span> vuex -S<br><br><span class="hljs-comment">// pinia </span><br>npm <span class="hljs-selector-tag">i</span> pinia -S<br></code></pre></td></tr></table></figure><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>两个状态管理器都需要在main.js中挂载到vue实例上</p><h4 id="vuex的挂载过程"><a href="#vuex的挂载过程" class="headerlink" title="vuex的挂载过程"></a>vuex的挂载过程</h4><p>在src下新建store/index.js目录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createStore(&#123;<br>    state() &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        name: <span class="hljs-string">'YoLin'</span><br>      &#125;;<br>    &#125;,<br>    mutations: &#123;<br>    &#125;,<br>    actions: &#123;<br>    &#125;,<br>    getters: &#123;<br>    &#125;,<br>    modules: &#123;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>state：全局state，类似于vue种的data，用于声明全局的状态变量。</li><li>mutations：通过commit 触发mutation来修改state，即修改state的函数，可记录追踪数据state变化。</li><li>actions：用于执行一些异步操作，并提交mutation更新state。</li><li>getters：可以看作和vue中的计算属性一样的能力。</li><li>modules： 将store分割成模块，当应用较大时使用。</li></ul><p>在main.js上进行挂载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store'</span><br>createApp(App).use(store).mount(<span class="hljs-string">'#app'</span>)<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><br><span class="hljs-keyword">let</span> store = useStore()<br><span class="hljs-built_in">console</span>.log(store.state.name)<br>&lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure><h4 id="pinia的挂载过程"><a href="#pinia的挂载过程" class="headerlink" title="pinia的挂载过程"></a>pinia的挂载过程</h4><p>mian.js中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./App.vue"</span><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span><br><span class="hljs-keyword">const</span> pinia = createPinia()<br>createApp(App).use(pinia).mount(<span class="hljs-string">"#app"</span>)<br></code></pre></td></tr></table></figure><p>创建store目录，目录一下每一个文件相当于一个模块，无需嵌套（通过modules引入）的方式引入模块。</p><p>store/storeA.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"pinia"</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> storeA = defineStore(<span class="hljs-string">"storeA"</span>, &#123;<br>  state: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      name: <span class="hljs-string">"YoLin"</span>,<br>    &#125;;<br>  &#125;,<br>  getters: &#123;&#125;,<br>  actions: &#123;&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; storeA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store/storeA'</span><br><span class="hljs-keyword">let</span> storeA = storeA()<br><span class="hljs-built_in">console</span>.log(storeA.name)<br>&lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure><p>可以对比看出pinia中没有mutations和mudules，在vuex中修改state需要调用mutations里的函数，才能达到追踪数据变化的目的，而pinia不需要，同步和异步都定义在actions中进行操作。pinia不需要嵌套的方式引入，一个store文件就是一个模块。</p><h3 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h3><ul><li><p>vuex</p><p>非严格模式下，可以直接修改,但这样vuex不能够记录每一次state的变化记录，影响我们的调试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><br><span class="hljs-keyword">let</span> store = useStore()<br>vuexStore.state.name = <span class="hljs-string">'hello YoLin'</span><br><span class="hljs-built_in">console</span>.log(store.state.name)<br>&lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure><p>严格模式下，则必须通过mutations进行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/index.js</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"vuex"</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createStore(&#123;<br>  strict: <span class="hljs-literal">true</span>,<br>  state: &#123;<br>    name: <span class="hljs-string">"YoLin"</span>,<br>  &#125;,<br>  mutations: &#123;<br>    setName(state, data) &#123;<br>      state.name = data;<br>    &#125;,<br>  &#125;,<br>...<br>&#125;);<br>  <br><span class="hljs-comment">// App.vue</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><br><span class="hljs-keyword">let</span> store = useStore()<br>store.commit(<span class="hljs-string">'setName'</span>, <span class="hljs-string">'hello YoLin'</span>)<br>&lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure><p>或者在组件中通过dispatch调用actions来提交mutations进而修改state,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/index.js</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"vuex"</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createStore(&#123;<br>  strict: <span class="hljs-literal">true</span>,<br>  state: &#123;<br>    name: <span class="hljs-string">"YoLin"</span>,<br>  &#125;,<br>  mutations: &#123;<br>    setName(state, data) &#123;<br>      state.name = data;<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    changeName(&#123; commit &#125;, value) &#123;<br>      commit(<span class="hljs-string">'setName'</span>, value)<br>    &#125;<br>  &#125;<br>...<br>&#125;);<br><br><span class="hljs-comment">// App.vue</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><br><span class="hljs-keyword">let</span> store = useStore()<br>store.dispatch(<span class="hljs-string">'changeName'</span>, <span class="hljs-string">'hello YoLin'</span>)<br>&lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure><p>在vuex的使用中，actions中一般是先执行异步请求，当获取到后端返回的内容后，通过提交mutation的形式更新数据。</p></li></ul><ul><li><p>pinia</p><p>相比vuex，pinia是可以直接修改状态的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; storeA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store/storeA'</span><br><span class="hljs-keyword">let</span> storeA = storeA()<br>storeA.piniaMsg = <span class="hljs-string">'hello YoLin'</span><br>&lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure><p>也可以通过$patch更新一个或多个数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">storeA.$patch(&#123;<br>name: <span class="hljs-string">'hello YoLin'</span>,<br>...<br>&#125;)<br> <span class="hljs-comment">// or function</span><br>storeA.$patch(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;<br>  state.name = <span class="hljs-string">'hello YoLin'</span><br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>或者通过actions进行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"pinia"</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> storeA = defineStore(<span class="hljs-string">"storeA"</span>, &#123;<br>  state: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      name: <span class="hljs-string">"YoLin"</span>,<br>    &#125;;<br>  &#125;,<br>  actions: &#123;<br>    setName(data) &#123;<br>      <span class="hljs-keyword">this</span>.name = data<br>    &#125;<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// App.vue</span><br><span class="hljs-keyword">import</span> &#123; storeA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store/storeA'</span><br><span class="hljs-keyword">let</span> storeA = storeA()<br>storeA.setName(<span class="hljs-string">'YoLinDeng'</span>)<br></code></pre></td></tr></table></figure><p>重置state可以通过$reset </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">storeA.$reset()<br></code></pre></td></tr></table></figure></li></ul><h3 id="pinia解构"><a href="#pinia解构" class="headerlink" title="pinia解构"></a>pinia解构</h3><p>当使用es6的解构赋值对state进行解构的时候，state会失去响应式，这个时候可以使用<code>storeToRefs</code>来避免state失去响应式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; storeA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store/storeA'</span><br><span class="hljs-keyword">import</span> &#123; storeToRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span><br><span class="hljs-keyword">let</span> storeA = storeA()<br><span class="hljs-keyword">let</span> &#123; name &#125; = storeToRefs(storeA)<br></code></pre></td></tr></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>对于getters来说vuex和pinia是一致的，它可以监听对应state的变化，动态计算返回值，getters的值也具有缓存特性，也就是只有在首次和依赖方式改变的时候才会触发getters函数执行。</p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>如果项目比较大的情况，如果只使用单一模块，会显得十分的臃肿难维护，vuex允许将其分割成模块（modules），每个模块单独维护自己的state、getters、mutations、actions，而pinia每个状态库本身就是一个模块。</p>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>vuex</tag>
      
      <tag>pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端项目代码提交规范化实践</title>
    <link href="/my-hexo-blog/2022/08/19/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <url>/my-hexo-blog/2022/08/19/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="commitizen规范提交信"><a href="#commitizen规范提交信" class="headerlink" title="commitizen规范提交信"></a>commitizen规范提交信</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 全局安装commitizen</span><br>yarn <span class="hljs-keyword">global</span> <span class="hljs-keyword">add</span> commitizen<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">// 初始化</span><br>commitizen init cz-conventional-changelog --<span class="hljs-keyword">save</span> --<span class="hljs-keyword">save</span>-exact<br></code></pre></td></tr></table></figure><p>执行后在package.json下会生成以下配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>...<br>"config": &#123;<br>    "commitizen": &#123;<br>      "path": "./node_modules/cz-conventional-changelog"<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>另外还可以安装中文包</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">yarn <span class="hljs-keyword">add</span> cz-conventional-changelog-<span class="hljs-built_in">zh</span> -D<br></code></pre></td></tr></table></figure><p>并修改配置,可自定义:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs json">"config": &#123;<br>    "commitizen": &#123;<br>       "path": "./node_modules/cz-conventional-changelog-zh",<br>      "defaultType":"[新增功能]",<br>   "types": &#123;<br>    "[新增功能]": &#123;<br>          "description": "新增功能点、新增需求",<br>          "title": "Features"<br>        &#125;,<br>        "[Bug修复]": &#123;<br>          "description": "修复Bug,线上，测试，验收阶段的bug",<br>          "title": "Bug Fixes"<br>        &#125;,<br>        "[文档修改]": &#123;<br>          "description": "文档增删改",<br>          "title": "Documentation"<br>        &#125;,<br>        "[样式修改]": &#123;<br>          "description": "样式修改(空白、格式、缺少分号等)",<br>          "title": "Styles"<br>        &#125;,<br>        "[代码重构]": &#123;<br>          "description": "既不修复bug也不添加新功能的更改",<br>          "title": "Code Refactoring"<br>        &#125;,<br>        "[性能优化]": &#123;<br>          "description": "性能优化",<br>          "title": "Performance Improvements"<br>        &#125;,<br>        "[测试代码]": &#123;<br>          "description": "增加测试",<br>          "title": "Tests"<br>        &#125;,<br>        "[编译代码]": &#123;<br>          "description": "影响构建系统或外部依赖项的更改(示例范围:gulp、broccoli、npm)",<br>          "title": "Builds"<br>        &#125;,<br>        "[持续集成]": &#123;<br>          "description": "对CI配置文件和脚本的更改(示例范围:Travis, Circle, BrowserStack, SauceLabs)",<br>          "title": "Continuous Integrations"<br>        &#125;,<br>        "[其他提交]": &#123;<br>          "description": "除src目录或测试文件以外的修改",<br>          "title": "Chores"<br>        &#125;,<br>        "[回退更改]": &#123;<br>          "description": "回退历史版本",<br>          "title": "Reverts"<br>        &#125;,<br>        "[修改冲突]": &#123;<br>          "description": "修改冲突",<br>          "title": "Conflict"<br>        &#125;,<br>        "[字体修改]": &#123;<br>          "description": "字体文件更新",<br>          "title": "Fonts"<br>        &#125;,<br>        "[删除文件]": &#123;<br>          "description": "删除文件",<br>          "title": "Delete Files"<br>        &#125;,<br>        "[暂存文件]": &#123;<br>          "description": "暂存文件",<br>          "title": "Stash Files"<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>为了方便提交，添加package.json中scripts的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">"scripts"</span>: &#123;<br>    ...<br>"commit": "git add -A &amp;&amp; git cz &amp;&amp; git push",<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="standard-version自动化版本控制"><a href="#standard-version自动化版本控制" class="headerlink" title="standard-version自动化版本控制"></a>standard-version自动化版本控制</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 安装</span><br>yarn <span class="hljs-keyword">add</span> standard-version -D<br></code></pre></td></tr></table></figure><p>添加scripts配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"scripts"</span>: &#123;<br>    ...<br>    "standard": "standard-version"<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写自定义脚本，进行版本号升级控制:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  scripts/version.js</span><br><span class="hljs-comment">/* eslint-disable */</span><br><span class="hljs-keyword">const</span> exec = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).exec<br><span class="hljs-keyword">const</span> inquirer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'inquirer'</span>)<br><br><span class="hljs-keyword">const</span> states = &#123;<br>  major: <span class="hljs-string">'版本升级（新功能不兼容旧版本时）'</span>,<br>  minor: <span class="hljs-string">'特性更新（添加新功能或功能增强时）'</span>,<br>  patch: <span class="hljs-string">'修复补丁（修复常规错误时）'</span>,<br>  skip: <span class="hljs-string">'跳过（谨慎！请仅在未完成时选择此项）'</span><br>&#125;<br><br>inquirer.prompt([<br>  &#123;<br>    type: <span class="hljs-string">'list'</span>,<br>    name: <span class="hljs-string">'version'</span>,<br>    message: <span class="hljs-string">'请选择您要升级的版本号类型:'</span>,<br>    choices: <span class="hljs-built_in">Object</span>.keys(states).map(<span class="hljs-function"><span class="hljs-params">k</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;k&#125;</span>: <span class="hljs-subst">$&#123;states[k]&#125;</span>`</span>)<br>  &#125;<br>]).then(<span class="hljs-function">(<span class="hljs-params">&#123; version &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> type = version.split(<span class="hljs-string">':'</span>)[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">if</span> (type !== <span class="hljs-string">'skip'</span>) &#123;<br>    exec(<span class="hljs-string">`npm run standard -- --release-as <span class="hljs-subst">$&#123;type&#125;</span>`</span>)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'正在更新版本号.....'</span>)<br>  &#125;<br>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.error(err)<br>  process.exit(<span class="hljs-number">1</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>修改package.json 的scripts 中的commit配置并添加update:version命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">"scripts"</span>: &#123;<br>    ...<br>"commit": "git add -A &amp;&amp; git cz &amp;&amp; npm run update:version &amp;&amp; git push",<br>    "update:version": "node ./scripts/version.js"<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在运行commitizen提交后，将会执行脚本文件version.js进行版本更新，若不选择skip，则运行standard命令，会在根目录下生成CHANGELOG.md（版本更新日志文件）。</p><h3 id="集成Husky和lint-staged"><a href="#集成Husky和lint-staged" class="headerlink" title="集成Husky和lint-staged"></a>集成Husky和lint-staged</h3><ul><li><p>Husky可以在 git 提交代码的前后，执行一系列的 git hooks，以对代码、文件等进行预设的检查，一旦检查不通过，就可以阻止当前的代码提交，避免了不规范的代码和 git 提交出现在项目中。</p></li><li><p><code>lint-staged</code> 是一个专门用于在通过 <code>git</code> 提交代码之前，对暂存区的代码执行一系列的格式化。当 <code>lint-staged</code> 配合 git hooks 使用时，可以在 git 提交前的 hook 中加入 <code>lint-staged</code> 命令，这样就能在提交代码之前，对即将提交的代码进行格式化，成功之后就会提交代码。</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 安装</span><br>yarn add husky -D<br><br>yarn add lint-staged -D<br><br><span class="hljs-comment">// 同时集成</span><br>npx <span class="hljs-symbol">mrm@</span><span class="hljs-number">2</span> lint-staged<br></code></pre></td></tr></table></figure><p>执行命令后，你就会看到你的 <code>package.json</code> 里多了一个 <code>lint-staged</code> 配置项，且根目录下多了一个 <code>.husky</code> 目录，里面就包含了 <em>pre-commit</em> 文件，里面包含了一个最基础的命令：<code>npx lint-staged</code>。</p><p>我们可以修改lint-staged的配置项已达到我们校验代码的目的，比如eslint、stylelint等等</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>...<br> "lint-staged": &#123;<br>    "*.&#123;js,jsx,ts,tsx,vue&#125;": [<br>      "eslint --cache --fix",<br>      <span class="hljs-string">"vue-cli-service lint"</span><br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可创建其他钩子<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">git hooks</a>，并在文件里面编写shell脚本</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 新增其他hook</span><br>npx husky <span class="hljs-keyword">add</span> [fileName]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常手写代码练习</title>
    <link href="/my-hexo-blog/2022/08/19/%E6%97%A5%E5%B8%B8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    <url>/my-hexo-blog/2022/08/19/%E6%97%A5%E5%B8%B8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、setTimeout模拟实现setInterval"><a href="#1、setTimeout模拟实现setInterval" class="headerlink" title="1、setTimeout模拟实现setInterval"></a>1、setTimeout模拟实现setInterval</h3><p>题目：使用setInterval 用来实现循环定时调用 可能会存在一定的问题 能用 setTimeout 解决吗?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mySetInterval</span>(<span class="hljs-params">fn, time</span>) </span>&#123;<br><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interval</span>(<span class="hljs-params"></span>) </span>&#123;<br>    fn()<br>timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      interval()<br>    &#125;, time)<br>&#125;<br>  interval()<br>  <span class="hljs-keyword">return</span> &#123;<br>    clear: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      clearTimeout(timer)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：使用 setInterval 模拟实现 setTimeout 吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mySetTimeout</span>(<span class="hljs-params">fn, time</span>) </span>&#123;<br><span class="hljs-keyword">let</span> timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    fn()<br>    clearInterval(time)<br>  &#125;, time)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拓展思考：setinterval 的缺陷是什么？</strong></p><ul><li>1、即使调用的代码报错了，setInterval仍然会继续调用</li><li>2、无视网络延迟，在使用ajax轮询服务器数据时，它会去一遍又一遍的发送请求，如果网络不好，会导致请求堆积。</li><li>setInterval不定时。如果它调用的代码执行的时间小于定时的时间，它会跳过调用，这就导致无法按照你需要的执行次数或无法得到你想要的结果</li></ul><h3 id="2、-发布订阅模式"><a href="#2、-发布订阅模式" class="headerlink" title="2、 发布订阅模式"></a>2、 发布订阅模式</h3><p>题目： 实现一个发布订阅模式拥有 on emit once off 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">this</span>.events = &#123;&#125;<br>  &#125;<br>  on(type, cb) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.events[type]) &#123;<br>      <span class="hljs-keyword">this</span>.events[type].push(cb)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">this</span>.events[type] = [cb]<br>    &#125;<br>  &#125;<br>  off(type, cb) &#123;<br>    <span class="hljs-keyword">this</span>.events[type] = <span class="hljs-keyword">this</span>.events[type].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x !== cb)<br>  &#125;<br>  once(type, cb) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>      cb()<br>      <span class="hljs-keyword">this</span>.off(type, fn)<br>    &#125;<br>    <span class="hljs-keyword">this</span>.on(type, fn)<br>  &#125;<br>  emit(type, ...rest) &#123;<br>    <span class="hljs-keyword">this</span>.events[type]?.forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> &#123;<br>    x.apply(<span class="hljs-keyword">this</span>, rest)<br>  &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、-数组扁平化"><a href="#3、-数组扁平化" class="headerlink" title="3、 数组扁平化"></a>3、 数组扁平化</h3><p>题目：实现一个方法使多维数组变成一维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatter</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!arr.length) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">prev, curr</span>) =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(curr) ? [...prev, ...flatter(curr)] : [...prev, curr], [])<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 迭代</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatter</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!arr.length) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">while</span> (arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(item))) &#123;<br>    arr = [].concat(...arr)<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、寄生组合继承"><a href="#4、寄生组合继承" class="headerlink" title="4、寄生组合继承"></a>4、寄生组合继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name<br>  <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'say'</span>)<br>  &#125;<br>&#125;<br>Parent.prototype.play = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'basketball'</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  Parent.call(<span class="hljs-keyword">this</span>)<br>  <span class="hljs-keyword">this</span>.name = name<br>&#125;<br><br>Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype)<br>Child.prototype.constructor = Child<br></code></pre></td></tr></table></figure><h3 id="5、-实现有并行限制的-Promise-调度器"><a href="#5、-实现有并行限制的-Promise-调度器" class="headerlink" title="5、 实现有并行限制的 Promise 调度器"></a>5、 实现有并行限制的 Promise 调度器</h3><p>题目: JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(limit) &#123;<br>    <span class="hljs-keyword">this</span>.queue = []<br>    <span class="hljs-keyword">this</span>.maxCount = limit<br>    <span class="hljs-keyword">this</span>.runCount = <span class="hljs-number">0</span><br>  &#125;<br>  add(promise) &#123;<br>    <span class="hljs-keyword">this</span>.queue.push(promise)<br>  &#125;<br>  taskStart() &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-keyword">this</span>.maxCount; i++) &#123;<br>      <span class="hljs-keyword">this</span>.request()<br>    &#125;<br>  &#125;<br>  request() &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.queue || !<span class="hljs-keyword">this</span>.queue.length || <span class="hljs-keyword">this</span>.runCount &gt;= <span class="hljs-keyword">this</span>.maxCount) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">this</span>.runCount++<br>    <span class="hljs-keyword">this</span>.queue.shift()().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><span class="hljs-keyword">this</span>.runCount--<br>      <span class="hljs-keyword">this</span>.request()<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、new操作符"><a href="#6、new操作符" class="headerlink" title="6、new操作符"></a>6、new操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">const</span> obj = &#123;&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">constructor</span> = [].shift.call(arguments)<br>obj.__proto__ = <span class="hljs-keyword">constructor</span>.prototype<br>const res = <span class="hljs-keyword">constructor</span>.apply(obj, arguments)<br>return typeof res === 'object' ? res : obj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、call、apply、bind"><a href="#7、call、apply、bind" class="headerlink" title="7、call、apply、bind"></a>7、call、apply、bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!context || content === <span class="hljs-literal">null</span>) &#123;<br>    context = <span class="hljs-built_in">window</span><br>  &#125;<br>  <span class="hljs-comment">// 创造唯一的key值  作为构造的context内部方法名</span><br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Symbol</span>()<br>  context[fn] = <span class="hljs-keyword">this</span> <span class="hljs-comment">// 指向调用myCall的那个函数</span><br>  <span class="hljs-keyword">return</span> context[fn](...args)<br>&#125; <br><br><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!context || context === <span class="hljs-literal">null</span>) &#123;<br>    context = windw<br>  &#125;<br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Symbol</span>()<br>  context[fn] = <span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">return</span> context[fn](...args)<br>&#125;<br><br><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!context || context === <span class="hljs-literal">null</span>) &#123;<br>    context = <span class="hljs-built_in">window</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Symbol</span>()<br>  context[fn] = <span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">let</span> _this = <span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...innerArgs</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> _this) &#123;<br>      <span class="hljs-keyword">this</span>[fn] = _this<br>      <span class="hljs-keyword">this</span>[fn](...[args, ...innerArgs])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      context[fn](...[...args, ...innerArgs])<br>    &#125;<br>  &#125;<br>  result.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">this</span>.prototype)<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、深拷贝"><a href="#8、深拷贝" class="headerlink" title="8、深拷贝"></a>8、深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'obj'</span> &amp;&amp; val !== <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj, hash = new weakMap(</span>)) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!isObject(obj)) <span class="hljs-keyword">return</span> obj<br>  <span class="hljs-keyword">if</span> (hash.has(obj)) &#123;<br>    <span class="hljs-keyword">return</span> hash.get(obj)<br>  &#125;<br>  <span class="hljs-keyword">let</span> target = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;<br>  hash.set(obj, target)<br>  <span class="hljs-built_in">Reflect</span>.ownKeys(obj).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (isObject(obj[item])) &#123;<br>      target[item] = deepClone(obj[item], hash)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      target[item] = obj[item]<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9、instanceof"><a href="#9、instanceof" class="headerlink" title="9、instanceof"></a>9、instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (left === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (left.__proto__ === right.prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    left = left.__proto__<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10、柯里化"><a href="#10、柯里化" class="headerlink" title="10、柯里化"></a>10、柯里化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currying</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> length = fn.length<br>  <span class="hljs-keyword">let</span> allArgs = [...args]<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-function">(<span class="hljs-params">...newArgs</span>) =&gt;</span> &#123;<br>    allArgs = [...allArgs, ...newArgs]<br>    <span class="hljs-keyword">if</span> (allArgs.length === length) &#123;<br>      <span class="hljs-keyword">return</span> fn(...allArgs)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11、冒泡排序-时间复杂度n-2"><a href="#11、冒泡排序-时间复杂度n-2" class="headerlink" title="11、冒泡排序(时间复杂度n^2)"></a>11、冒泡排序(时间复杂度n^2)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">let</span> flag = arr[j]<br>        arr[j] = arr[j+<span class="hljs-number">1</span>]<br>        arr[j+<span class="hljs-number">1</span>] = flag<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12、选择排序"><a href="#12、选择排序" class="headerlink" title="12、选择排序"></a>12、选择排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> len = arr.length<br>  <span class="hljs-keyword">let</span> minIndex<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; len; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>        minIndex = j<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (minIndex !== i) &#123;<br>      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13、插入排序"><a href="#13、插入排序" class="headerlink" title="13、插入排序 **"></a>13、插入排序 **</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br><span class="hljs-keyword">let</span> j = i<br><span class="hljs-keyword">let</span> target = arr[j]<br><span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j - <span class="hljs-number">1</span>] &gt; target) &#123;<br>arr[j] = arr[j - <span class="hljs-number">1</span>]<br>j--<br>&#125;<br>arr[j] = target<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14、快速排序-nlogn-n-2"><a href="#14、快速排序-nlogn-n-2" class="headerlink" title="14、快速排序(nlogn~ n^2 )"></a>14、快速排序(nlogn~ n^2 )</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr<br>  &#125;<br>  <span class="hljs-keyword">const</span> curr = arr[arr.length - <span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">const</span> left = arr.filter(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item &lt; curr &amp;&amp; index !== arr.length - <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> right = arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; curr)<br>  <span class="hljs-keyword">return</span> [...quickSort(left), curr, ...quickSort(right)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15、归并排序-nlog-n"><a href="#15、归并排序-nlog-n" class="headerlink" title="15、归并排序( nlog(n)) **"></a>15、归并排序( nlog(n)) **</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;<br>    <span class="hljs-keyword">if</span> (left[i] &lt; right[j]) &#123;<br>      res.push(left[i]);<br>      i++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.push(right[j]);<br>      j++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (i &lt; left.length) &#123;<br>    res.push(...left.slice(i));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.push(...right.slice(j));<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<br><br>  <span class="hljs-keyword">const</span> left = mergeSort(arr.slice(<span class="hljs-number">0</span>, mid));<br>  <span class="hljs-keyword">const</span> right = mergeSort(arr.slice(mid));<br>  <span class="hljs-keyword">return</span> merge(left, right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16、二分查找（log2-n-）"><a href="#16、二分查找（log2-n-）" class="headerlink" title="16、二分查找（log2(n)）"></a>16、二分查找（log2(n)）</h3><p>题目:如何确定一个数在一个有序数组中的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params">arr, target, start, end</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> targetIndex = <span class="hljs-number">-1</span><br>  <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((start + end) / <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">if</span> (arr[mid] === target) &#123;<br>    targetIndex = mid<br>    <span class="hljs-keyword">return</span> targetIndex<br>  &#125;<br>  <span class="hljs-keyword">if</span> (start &gt;= end) &#123;<br>    <span class="hljs-keyword">return</span> targetIndex<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (arr[mid] &lt; target) &#123;<br>    <span class="hljs-keyword">return</span> search(arr, target, mid + <span class="hljs-number">1</span>, end)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> search(arr, target, start, mid <span class="hljs-number">-1</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17、防抖节流"><a href="#17、防抖节流" class="headerlink" title="17、防抖节流"></a>17、防抖节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 防抖 非立即执行</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    timer &amp;&amp; clearTimeout(timer)<br>    timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;, wait)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 防抖 立即执行</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> flag = !timer<br>    timer &amp;&amp; clearTimeout(timer)<br>    timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, wait)<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>      fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 节流 时间戳</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now()<br>    <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>      fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)<br>      prev = now<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 节流 定时器</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;, wait)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="18、LRU（最近最少使用）算法"><a href="#18、LRU（最近最少使用）算法" class="headerlink" title="18、LRU（最近最少使用）算法"></a>18、LRU（最近最少使用）算法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(capacity) &#123;<br>    <span class="hljs-keyword">this</span>.secretKey = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>    <span class="hljs-keyword">this</span>.capacity = capacity<br>  &#125;<br>  <span class="hljs-keyword">get</span>(key) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.secretKey.has(key)) &#123;<br>      <span class="hljs-keyword">let</span> tempValue = <span class="hljs-keyword">this</span>.secretkey.get(key)<br>      <span class="hljs-keyword">this</span>.secretKey.delete(key)<br>      <span class="hljs-keyword">this</span>.secretKey.set(key, tempValue)<br>      <span class="hljs-keyword">return</span> tempValue<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">set</span>(key, value) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.secretKey.has(key)) &#123;<br>      <span class="hljs-keyword">this</span>.secretKey.delete(key)<br>      <span class="hljs-keyword">this</span>.secretKey.set(key, value)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.capacity &gt; <span class="hljs-keyword">this</span>.secretKey.size) &#123;<br>      <span class="hljs-keyword">this</span>.secretKey.set(key, value)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">this</span>.secretKey.delete(<span class="hljs-keyword">this</span>.secretKey.keys().next.value)<br>      <span class="hljs-keyword">this</span>.secretKey.set(key, value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19、Promise"><a href="#19、Promise" class="headerlink" title="19、Promise"></a>19、Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(executor) &#123;<br>        <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'pending'</span><br>        <span class="hljs-keyword">this</span>.value = <span class="hljs-string">'undefined'</span><br>        <span class="hljs-keyword">this</span>.reason = <span class="hljs-string">'undefined'</span><br>        <span class="hljs-keyword">this</span>.onResolvedCallbacks = []<br>        <span class="hljs-keyword">this</span>.onRejectedCallbacks = []<br>        <br>        <span class="hljs-keyword">let</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'fulfilled'</span><br>            <span class="hljs-keyword">this</span>.value = value<br>            <span class="hljs-keyword">this</span>.onResolvedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn())<br>        &#125;<br>        <br>        <span class="hljs-keyword">let</span> reject = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'rejected'</span><br>            <span class="hljs-keyword">this</span>.reason = reason<br>            <span class="hljs-keyword">this</span>.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn())<br>        &#125;<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>           executor(resolve, reject) <br>        &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>            reject(error)<br>        &#125;<br>    &#125;<br>    then(onFulfilled, onRejected) &#123;<br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value<br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> err &#125;<br>        <span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'fulfilled'</span>) &#123;<br>                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value)<br>                        resolve(promise2, x, resolve, reject)<br>                    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                        reject(e)<br>                    &#125;<br>                &#125;, <span class="hljs-number">0</span>)<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'rejected'</span>) &#123;<br>                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-keyword">this</span>.reason)<br>                        resolvePromise(promise2, x, resolve, reject)<br>                    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                        reject(e)<br>                    &#125;<br>                &#125;, <span class="hljs-number">0</span>)<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'pending'</span>) &#123;<br>             <span class="hljs-keyword">this</span>.onResolvedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                 setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value)<br>                        resolvePromise(promise2, x, resolve, reject)<br>                    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                        reject(e)<br>                    &#125;<br>                 &#125;, <span class="hljs-number">0</span>)<br>             &#125;)<br>             <br>             <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                 setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                     <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-keyword">this</span>.reason)<br>                        resolvePromise(promise2,x, resolve, reject)<br>                     &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                         reject(e)<br>                     &#125;<br>                 &#125;, <span class="hljs-number">0</span>)<br>             &#125;)<br>            &#125;<br>        &#125;)<br>        <span class="hljs-keyword">return</span> promise2<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (x === promise2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'chaining cycle detected for promise'</span>)<br>    &#125;<br>    <span class="hljs-keyword">let</span> called<br>    <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'function'</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> then = x.then<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) &#123;<br>                then.call(x, y =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span> <br>                    called = <span class="hljs-literal">true</span><br>                    resolvePromise(promise2, y, resolve, reject)<br>                &#125;, err =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span> <br>                    called = <span class="hljs-literal">true</span><br>                    reject(err)<br>                &#125;)<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>            called = <span class="hljs-literal">true</span><br>            reject(error)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        resolve(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// resolve</span><br><span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        resolve(value)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// reject</span><br><span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> &#123;<br>        reject(value)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// all</span><br><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> result = []<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">let</span> len = promises.length<br>        <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>            resolve([])<br>        &#125;<br>        promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(item).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                count += <span class="hljs-number">1</span><br>                result[index] = res<br>                <span class="hljs-keyword">if</span> (count === len) &#123;<br>                    resolve(result)<br>                &#125;<br>            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// allSettled</span><br><span class="hljs-built_in">Promise</span>.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> result = []<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">let</span> len = promises.length<br>        <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>            resolve([])<br>        &#125;<br>        promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(item).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                count += <span class="hljs-number">1</span><br>                result[index] = &#123;<br>                    status: <span class="hljs-string">'fulfiled'</span>,<br>                    value: res<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len === count) &#123;<br>                    resolve(result)<br>                &#125;<br>            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                count += <span class="hljs-number">1</span><br>                result[index] = &#123;<br>                    status: <span class="hljs-string">'rejected'</span>,<br>                    reason: err<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len === count) &#123;<br>                    resolve(result)<br>                &#125;<br>            &#125;)<br>        &#125;)<br>   &#125;)<br>&#125;<br><br><span class="hljs-comment">// race</span><br><span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        promises.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(item).then(resolve).catch(reject)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="20、实现-DOM2JSON-一个函数，可以把一个-DOM-节点输出-JSON-的格式"><a href="#20、实现-DOM2JSON-一个函数，可以把一个-DOM-节点输出-JSON-的格式" class="headerlink" title="20、实现 DOM2JSON 一个函数，可以把一个 DOM 节点输出 JSON 的格式"></a>20、实现 DOM2JSON 一个函数，可以把一个 DOM 节点输出 JSON 的格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dom2Json</span>(<span class="hljs-params">domtree</span>) </span>&#123;<br><span class="hljs-keyword">let</span> obj = &#123;&#125;<br>obj.name = domtree.tagName<br>obj.children = []<br>domtree.childNodes.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> obj.children.push(dom2Json(child)))<br><span class="hljs-keyword">return</span> obj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="21、类数组转化为数组的方法"><a href="#21、类数组转化为数组的方法" class="headerlink" title="21、类数组转化为数组的方法"></a>21、类数组转化为数组的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrayLike =<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'div'</span>)<br><br><span class="hljs-comment">// 扩展运算符</span><br>[...arrayLike]<br><span class="hljs-comment">// Array.from</span><br><span class="hljs-built_in">Array</span>.from(arrayLike)<br><span class="hljs-comment">// Array.prototype.slice</span><br><span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike)<br><span class="hljs-comment">// Array.apply</span><br><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, arrayLike)<br><span class="hljs-comment">// Array.prototype.concat</span><br><span class="hljs-built_in">Array</span>.prototype.concat.apply([], arrayLike)<br></code></pre></td></tr></table></figure><h3 id="22、Object-is-实现"><a href="#22、Object-is-实现" class="headerlink" title="22、Object.is 实现"></a>22、Object.is 实现</h3><p><strong>Object</strong>.is不会转换被比较的两个值的类型，这点和===更为相似，他们之间也存在一些区别。  </p><ol><li>NaN在===中是不相等的，而在<strong>Object</strong>.is中是相等的   </li><li><ol start="2"><li>+0和-0在===中是相等的，而在<strong>Object</strong>.is中是不相等的</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.is = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (x === y) &#123;<br>    <span class="hljs-keyword">return</span> x !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / x === <span class="hljs-number">1</span> / y<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> x!== x &amp;&amp; y!==y<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="23、-AJAX"><a href="#23、-AJAX" class="headerlink" title="23、 AJAX"></a>23、 AJAX</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getJson = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br>    xhr.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">false</span>)<br>    xhr.setRequestHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (xhr.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span> || xhr.status === <span class="hljs-number">304</span>) &#123;<br>        resolve(xhr.responseText)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(xhr.responseText))<br>      &#125;<br>    &#125;<br>    xhr.send()<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="24、分片思想解决大数据量渲染问题"><a href="#24、分片思想解决大数据量渲染问题" class="headerlink" title="24、分片思想解决大数据量渲染问题"></a>24、分片思想解决大数据量渲染问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"ul"</span>)<br><span class="hljs-keyword">let</span> total = <span class="hljs-number">1000000</span> <span class="hljs-comment">// 插入100万条数据</span><br><span class="hljs-keyword">let</span> once = <span class="hljs-number">20</span> <span class="hljs-comment">// 一次插入20条</span><br><span class="hljs-keyword">let</span> page = total / once <span class="hljs-comment">// 总页数</span><br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span> <span class="hljs-comment">// 索引</span><br><span class="hljs-comment">// 循环加载数据</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params">curTotal, curIndex</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (curTotal &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>  <span class="hljs-comment">// 每页多少条数据</span><br>  <span class="hljs-keyword">const</span> pageCount = <span class="hljs-built_in">Math</span>.min(curTotal, once)<br>  <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++) &#123;<br>      <span class="hljs-keyword">let</span> li = doucument.createElement(<span class="hljs-string">'li'</span>)<br>      li.innerText = <span class="hljs-string">`第<span class="hljs-subst">$&#123;curIndex + i&#125;</span>项 `</span><br>      ul.appendChild(li)<br>    &#125;<br>    loop(curTotal - pageCount, curIndex + pageCount)<br>  &#125;)<br>&#125;<br>loop(total, index)<br></code></pre></td></tr></table></figure><h3 id="25、将虚拟-Dom-转化为真实-Dom"><a href="#25、将虚拟-Dom-转化为真实-Dom" class="headerlink" title="25、将虚拟 Dom 转化为真实 Dom"></a>25、将虚拟 Dom 转化为真实 Dom</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  tag: 'DIV',<br>  attrs:&#123;<br>  id:'app'<br>  &#125;,<br>  children: [<br>    &#123;<br>      tag: 'SPAN',<br>      children: [<br>        &#123; tag: 'A', children: [] &#125;<br>      ]<br>    &#125;,<br>    &#123;<br>      tag: 'SPAN',<br>      children: [<br>        &#123; tag: 'A', children: [] &#125;,<br>        &#123; tag: 'A', children: [] &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;<br>把上诉虚拟Dom转化成下方真实Dom<br>&lt;div id="app"&gt;<br>  &lt;span&gt;<br>    &lt;a&gt;&lt;/a&gt;<br>  &lt;/span&gt;<br>  &lt;span&gt;<br>    &lt;a&gt;&lt;/a&gt;<br>    &lt;a&gt;&lt;/a&gt;<br>  &lt;/span&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_render</span>(<span class="hljs-params">vnode</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode === <span class="hljs-string">'number'</span>) &#123;<br>    vnode = <span class="hljs-built_in">String</span>(vnode)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode === <span class="hljs-string">'string'</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createTextNode(vnode)<br>  &#125;<br>  <span class="hljs-keyword">const</span> dom = ducument.createElement(vnode.tag)<br>  <span class="hljs-keyword">if</span> (vnode.attrs) &#123;<br>    <span class="hljs-built_in">Object</span>.keys(vnode.attrs).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> value = vnode.attrs[key]<br>      dom.setAttribute(key, value)<br>    &#125;)<br>  &#125;<br>  vnode.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> dom.appendChild(_render(child)))<br>  <span class="hljs-keyword">return</span> dom<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="26、实现模板字符串解析功能"><a href="#26、实现模板字符串解析功能" class="headerlink" title="26、实现模板字符串解析功能"></a>26、实现模板字符串解析功能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> template = <span class="hljs-string">'我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;'</span>;<br><span class="hljs-keyword">let</span> data = &#123;<br>  name: <span class="hljs-string">'姓名'</span>,<br>  age: <span class="hljs-number">18</span><br>&#125;<br>render(template, data); <span class="hljs-comment">// 我是姓名，年龄18，性别undefined</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">template, data</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> computed = template.replace(<span class="hljs-regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, key</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> data[key]<br>  &#125;)<br>  <span class="hljs-keyword">return</span> computed<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="27、列表转成树形结构"><a href="#27、列表转成树形结构" class="headerlink" title="27、列表转成树形结构"></a>27、列表转成树形结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listToTree</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> map = &#123;&#125;<br>  <span class="hljs-keyword">let</span> treeData = []<br>  data.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!item.children) &#123;<br>      item.children = []<br>    &#125;<br>    map[item.id] = item<br>  &#125;)<br>  data.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> parent = map[item.pid]<br>    <span class="hljs-keyword">if</span> (parent) &#123;<br>      parent.children.push(item)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      treeData.push(item)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> treeData<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="28、树形结构转成列表"><a href="#28、树形结构转成列表" class="headerlink" title="28、树形结构转成列表"></a>28、树形结构转成列表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">treeToList</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result = []<br>  data.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    result.push(item)<br>    <span class="hljs-keyword">if</span> (item.children &amp;&amp; item.children.length &gt; <span class="hljs-number">0</span>) &#123;<br>      result.push(...treeToList(item.children))<br>    &#125;<br>    <span class="hljs-built_in">Reflect</span>.deleteProperty(item, <span class="hljs-string">'children'</span>)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低代码可视化拖拽编辑器实现方案</title>
    <link href="/my-hexo-blog/2022/08/11/%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8B%96%E6%8B%BD%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/my-hexo-blog/2022/08/11/%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8B%96%E6%8B%BD%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着业务不断发展，低代码、无代码平台越来越常见，它降低开发门槛、快速响应业务需求、提升开发效率。零开发经验的业务人员通过可视化拖拽等方式，即可快速搭建各种应用。本文主要是讲解低代码可视化拖拽平台前端展示层面的实现逻辑和方案，对于后端逻辑、数据库设计、以及自动化部署等暂时没有涉及。</p><p>编码水平一般，提供给小伙伴们一些思路或学习参考。<a href="https://github.com/YoLinDeng/visual-editor" target="_blank" rel="noopener">源码地址</a></p><p><a href="https://yolindeng.github.io/visual-editor-home-page/#/">效果展示</a></p><h3 id="展示区划分"><a href="#展示区划分" class="headerlink" title="展示区划分"></a>展示区划分</h3><p>首先我们需要先清晰我们要实现的UI展示效果，如下图，分为三部分（组件选项区、可视化展示区、元素配置编辑区）</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6cf60a0a0ef4a2599be4cea37faad87~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?%22" alt="展示效果"></p><h4 id="1、组件选项区"><a href="#1、组件选项区" class="headerlink" title="1、组件选项区"></a>1、组件选项区</h4><h5 id="1-1-数据格式定义"><a href="#1-1-数据格式定义" class="headerlink" title="1.1 数据格式定义"></a>1.1 数据格式定义</h5><p>为了展示出各种元素，先定义元素的类型（文字、图片、按钮、banner、表单等等），具体数据格式如下，详情可以查看源码路径（src/config/template.ts、src/config/base.ts）,这些组件的每一项也可以存储在库，通过接口查询回来，只是这里没有实现。</p><ul><li><p>template.ts: 定义所有类型自定义组件的配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config: <span class="hljs-built_in">any</span> =  &#123;<br>  text: [<br>    &#123;<br>      config: &#123;<br>        name: <span class="hljs-string">'content-box'</span>,<br>        noDrag: <span class="hljs-number">1</span>,<br>        slot: [<br>          &#123;<br>            name: <span class="hljs-string">'content-input'</span>,<br>            style: &#123;<br>              backgroundImage: <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/assets/title1-left-icon.png'</span>),<br>              backgroundRepeat: <span class="hljs-string">'no-repeat'</span>,<br>              backgroundSize: <span class="hljs-string">'contain'</span>,<br>              borderWidth: <span class="hljs-number">0</span>,<br>              fontSize: <span class="hljs-string">'14px'</span>,<br>              height: <span class="hljs-string">'13px'</span>,<br>              lineHeight: <span class="hljs-string">'32px'</span>,<br>              width: <span class="hljs-string">'18px'</span><br>            &#125;,<br>            value: <span class="hljs-string">''</span><br>          &#125;,<br>          &#123;<br>            name: <span class="hljs-string">'content-input'</span>,<br>            style: &#123;<br>              height: <span class="hljs-string">'32px'</span>,<br>              paddingLeft: <span class="hljs-string">'5px'</span>,<br>              paddingRight: <span class="hljs-string">'5px'</span><br>            &#125;,<br>            value: <span class="hljs-string">"&lt;div style=\"line-height: 2;\"&gt;&lt;span style=\"font-size: 16px; color: #fce7b6;\"&gt;&lt;strong&gt;活动规则&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;"</span><br>          &#125;,<br>          &#123;<br>            name: <span class="hljs-string">'content-input'</span>,<br>            style: &#123;<br>              backgroundImage: <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/assets/title1-right-icon.png'</span>),<br>              backgroundRepeat: <span class="hljs-string">'no-repeat'</span>,<br>              backgroundSize: <span class="hljs-string">'contain'</span>,<br>              borderWidth: <span class="hljs-number">0</span>,<br>              fontSize: <span class="hljs-string">'14px'</span>,<br>              height: <span class="hljs-string">'13px'</span>,<br>              lineHeight: <span class="hljs-string">'32px'</span>,<br>              marginRight: <span class="hljs-string">'5px'</span>,<br>              width: <span class="hljs-string">'18px'</span><br>            &#125;,<br>            value: <span class="hljs-string">''</span><br>          &#125;<br>        ],<br>        style: &#123;<br>          alignItems: <span class="hljs-string">'center'</span>,<br>          backgroundColor: <span class="hljs-string">'rgba(26, 96, 175, 1)'</span>,<br>          display: <span class="hljs-string">'flex'</span>,<br>          height: <span class="hljs-string">'40px'</span>,<br>          justifyContent: <span class="hljs-string">'center'</span>,<br>          paddingLeft: <span class="hljs-string">'1px'</span><br>        &#125;,<br>        value: <span class="hljs-string">''</span><br>      &#125;,<br>      name: <span class="hljs-string">'带点的标题'</span>,<br>      preview: <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/assets/title1.jpg'</span>)<br>    &#125;<br>  ],<br>  img: [<br>    &#123;<br>      config: &#123;<br>        value: <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/assets/gift.png'</span>),<br>        name: <span class="hljs-string">'content-asset'</span>,<br>        style: &#123;<br>          width: <span class="hljs-string">'100px'</span>,<br>          height: <span class="hljs-string">'100px'</span>,<br>          display: <span class="hljs-string">'inline-block'</span><br>        &#125;<br>      &#125;,<br>      preview: <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/assets/gift.png'</span>),<br>      name: <span class="hljs-string">'礼包'</span><br>    &#125;<br>  ],<br>  btn: [<br>....<br>  ],<br>  form: [<br>  ...<br>]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>base.ts: 中定义基本组件的配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config: <span class="hljs-built_in">any</span> = &#123;<br>  text: &#123;<br>    value: <span class="hljs-string">'&lt;div style="text-align: center; line-height: 1;"&gt;&lt;span style="font-size: 14px; color: #333333;"&gt;这是一行文字&lt;/span&gt;&lt;/div&gt;'</span>,<br>    style: &#123;&#125;,<br>    name: <span class="hljs-string">'content-input'</span><br>  &#125;,<br>  multipleText: &#123;<br>    value: <span class="hljs-string">'&lt;div style="text-align: center; line-height: 1.5;"&gt;&lt;span style="font-size: 14px; color: #333333;"&gt;这是多行文字&lt;br /&gt;这是多行文字&lt;br /&gt;这是多行文字&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;'</span>,<br>    name: <span class="hljs-string">'content-input'</span>,<br>    style: &#123;&#125;<br>  &#125;,<br>  img: &#123;<br>    value: <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/assets/logo.png'</span>),<br>    name: <span class="hljs-string">'content-asset'</span>,<br>    style: &#123;<br>      width: <span class="hljs-string">'100px'</span>,<br>      height: <span class="hljs-string">'100px'</span>,<br>      display: <span class="hljs-string">'inline-block'</span><br>    &#125;<br>  &#125;,<br>  box: &#123;<br>    name: <span class="hljs-string">'content-box'</span>,<br>    noDrag: <span class="hljs-number">0</span>,<br>    style: &#123;<br>      width: <span class="hljs-string">'100%'</span>,<br>      minHeight: <span class="hljs-string">'100px'</span>,<br>      height: <span class="hljs-string">'auto'</span>,<br>      display: <span class="hljs-string">'inline-block'</span>,<br>      boxSizing: <span class="hljs-string">'border-box'</span><br>    &#125;,<br>    slot: []<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基本元素（文字content-input、图片content-asset）主要包含以下属性: name（组件名称）、style（行内样式）、value（内容值）</strong></p><p><strong>盒子元素（content-box）主要包含以下属性:  name（组件名称）、style（行内样式）、noDrag（是否可拖拽）、slot（插槽内容</strong></p></li></ul><h5 id="1-2-实现可拖拽"><a href="#1-2-实现可拖拽" class="headerlink" title="1.2 实现可拖拽"></a>1.2 实现可拖拽</h5><p>为了实现可拖拽效果，这里使用了sortable.js拖拽库来实现。更多使用细节可查看<a href="https://www.itxst.com/sortablejs/neuinffi.html" target="_blank" rel="noopener">官方文档</a></p><p>关键实现代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html">// 左侧选项区DOM结构<br><span class="hljs-tag">&lt;<span class="hljs-name">el-tabs</span> <span class="hljs-attr">tab-position</span>=<span class="hljs-string">"left"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tabs-list"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"activeType"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">el-tab-pane</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in props.tabConfig"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.value"</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">"item.label"</span> <span class="hljs-attr">:name</span>=<span class="hljs-string">"item.value"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tabs-list-item"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"`iconfont $&#123;item.icon&#125;`"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.label&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tab-content"</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tab-content-title"</span>&gt;</span>&#123;&#123;item.label&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"main-box"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"mainBox"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"config-item base"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"activeType === 'base'"</span> <span class="hljs-attr">data-name</span>=<span class="hljs-string">"text"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"addToSubPage(Base.config['text'])"</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">:size</span>=<span class="hljs-string">"20"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Document</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"config-item base"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"activeType === 'base'"</span>  <span class="hljs-attr">data-name</span>=<span class="hljs-string">"box"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"addToSubPage(Base.config['box'])"</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">:size</span>=<span class="hljs-string">"20"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Box</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"config-item"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"_item in item.children"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"_item"</span> <span class="hljs-attr">:data-name</span>=<span class="hljs-string">"_item"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"addToSubPage(Base.config[_item])"</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"activeType === 'text'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"config-item-text"</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"Base.config[_item].value"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"activeType === 'img'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"config-item-img"</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"Base.config[_item].value"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"config-item"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(tItem, tIndex) in Template.config[activeType]"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"tItem.id"</span> <span class="hljs-attr">:data-type</span>=<span class="hljs-string">"activeType"</span> <span class="hljs-attr">:data-index</span>=<span class="hljs-string">"tIndex"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"addToSubPage(tItem.config)"</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"tItem.preview"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"preview"</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-tab-pane</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-tabs</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> mainBox = ref()<br><span class="hljs-keyword">const</span> initSortableSide = (): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取mainBox下每一个元素，遍历并注册拖拽组</span><br>  <span class="hljs-built_in">Array</span>.from(mainBox.value).forEach(<span class="hljs-function">(<span class="hljs-params">$box, index</span>) =&gt;</span> &#123;<br>    instance[<span class="hljs-string">`_sortable_<span class="hljs-subst">$&#123;index&#125;</span>`</span>] &amp;&amp; instance[<span class="hljs-string">`_sortable_<span class="hljs-subst">$&#123;index&#125;</span>`</span>].destroy()<br>    instance[<span class="hljs-string">`_sortable_<span class="hljs-subst">$&#123;index&#125;</span>`</span>] = Sortable.create($box, &#123;<br>      filter: <span class="hljs-string">'.ignore'</span>, <span class="hljs-comment">// 需要过滤或忽略指定元素</span><br>      sort: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不允许组内排序</span><br>      group: &#123;<br>        name: <span class="hljs-string">'shared'</span>, <span class="hljs-comment">// 自定义组名</span><br>        pull: <span class="hljs-string">'clone'</span>, <span class="hljs-comment">// 从当前组克隆拖出</span><br>        put: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不允许拖入</span><br>      &#125;,<br>      <span class="hljs-comment">// 开始拖拽回调函数</span><br>      onStart: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 给subpage展示区添加选中框样式</span><br>       (<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.subpage'</span>) <span class="hljs-keyword">as</span> HTMLElement).classList.add(<span class="hljs-string">'active'</span>)<br>      &#125;,<br>      <span class="hljs-comment">// 结束拖拽回调函数</span><br>      onEnd: <span class="hljs-function">(<span class="hljs-params">&#123; item, originalEvent &#125;: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        ...<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要讲一下onEnd里面的逻辑，当拖拽组件并将其移动到中间的可视化展示区的时候，需要做以下2个关键操作。</p><ul><li>判断是否拖拽到可视化展示区内</li><li>获取当前拖拽元素的配置，并更新pinia中store的值。(pinia是vue新一代状态管理插件，可以认为是vuex5.)</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript">onEnd: <span class="hljs-function">(<span class="hljs-params">&#123; item, originalEvent &#125;: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取鼠标放开后的X、Y坐标</span><br>    <span class="hljs-keyword">const</span> &#123; pageX, pageY &#125; = originalEvent<br>    <span class="hljs-comment">// 获取可视化展示区的上下左右坐标</span><br>    <span class="hljs-keyword">const</span> &#123; left, right, top, bottom &#125; = (<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.subpage'</span>) <span class="hljs-keyword">as</span> HTMLElement).getBoundingClientRect()<br>    <span class="hljs-keyword">const</span> &#123; dataset &#125; = item<br>    <span class="hljs-comment">// 为了移除被clone到可视化区的dom结构，通过配置来渲染可视化区的内容</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.subpage'</span>) <span class="hljs-keyword">as</span> HTMLElement).contains(item)) &#123;<br>      item.remove()<br>    &#125;<br>  <span class="hljs-comment">// 编辑判断</span><br>    <span class="hljs-keyword">if</span> (pageX &gt; left &amp;&amp; pageX  &lt; right &amp;&amp; pageY &gt; top &amp;&amp; pageY &lt; bottom) &#123;<br>      <span class="hljs-comment">// 获取自定义属性中的name、type 、index</span><br>      <span class="hljs-keyword">const</span> &#123; name, <span class="hljs-keyword">type</span>, index &#125; = dataset<br>      <span class="hljs-keyword">let</span> currConfigItem = &#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span><br>      <span class="hljs-comment">// 若存在type 说明不是基础类型,在template.ts找到对应的配置。</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span>) &#123;<br>        currConfigItem = utils.cloneDeep(Template.config[<span class="hljs-keyword">type</span>][index].config)<br>        <span class="hljs-comment">// 使用nanoid 生成唯一id</span><br>        currConfigItem.id = utils.nanoid()<br>        <span class="hljs-comment">// 递归遍历组件内部的slot，为每个元素添加唯一id</span><br>        currConfigItem.slot = configItemAddId(currConfigItem.slot)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 基础类型操作</span><br>        currConfigItem = utils.cloneDeep(Base.config[name])<br>        currConfigItem.id = utils.nanoid()<br>      &#125;<br>      <span class="hljs-comment">// 修改pinia的store数据</span><br>      templateStore.config.push(currConfigItem)<br>      <span class="hljs-comment">// 触发更新（通过watch实现）</span><br>      key.value = <span class="hljs-built_in">Date</span>.now()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'false'</span>)<br>    &#125;<br>  <span class="hljs-comment">// 移除中间可视化区选中样式</span><br>    (<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.subpage'</span>) <span class="hljs-keyword">as</span> HTMLElement).classList.remove(<span class="hljs-string">'active'</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2、可视化展示区"><a href="#2、可视化展示区" class="headerlink" title="2、可视化展示区"></a>2、可视化展示区</h4><p>中间的可视化展示区的功能主要是提供用户对具体元素选中以及拖拽操作。因此主要实现<strong>元素展示</strong> 、<strong>选中框</strong>以及<strong>可拖拽</strong>功能。</p><h5 id="2-1-元素展示"><a href="#2-1-元素展示" class="headerlink" title="2.1 元素展示"></a>2.1 元素展示</h5><p>元素展示比较简单，只需要通过遍历pinia的store中的页面配置config，并用动态组件component标签展示即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in template.config"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"item.name"</span> <span class="hljs-attr">:config</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">"item.id"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-2-实现选中框"><a href="#2-2-实现选中框" class="headerlink" title="2.2 实现选中框"></a>2.2 实现选中框</h5><p>实现选中框的逻辑相对复杂一点，其中关键的两个事件是hover（鼠标悬浮在元素上）和select（鼠标点击元素）。</p><p><strong>定义一个响应式对象来存储它们的变化情况：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> catcher: <span class="hljs-built_in">any</span> = reactive(<br>  &#123;<br>    hover: &#123;<br>      id: <span class="hljs-string">''</span>, <span class="hljs-comment">// 元素id</span><br>      rect: &#123;&#125;, <span class="hljs-comment">// 元素坐标</span><br>      eleName: <span class="hljs-string">''</span> <span class="hljs-comment">// 元素类名</span><br>    &#125;,<br>    select: &#123;<br>      id: <span class="hljs-string">''</span>,<br>      rect: &#123;&#125;,<br>      eleName: <span class="hljs-string">''</span><br>    &#125;<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><p><strong>定义事件监听器（mouseover、click）</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; onMounted, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">const</span> subpage = ref()<br><br><span class="hljs-keyword">const</span> listeners = &#123;<br>  mouseover: <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// findUpwardElement方法为向上查找最近的目标元素</span><br>    <span class="hljs-keyword">const</span> $el = utils.findUpwardElement(e.target, editorElements, <span class="hljs-string">'classList'</span>)<br>    <span class="hljs-keyword">if</span> ($el) &#123;<br>      catcher.hover.id = $el.id<br>      <span class="hljs-comment">// 重置catcher响应式对象</span><br>      resetRect($el, <span class="hljs-string">'hover'</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      catcher.hover.rect.width = <span class="hljs-number">0</span><br>      catcher.hover.id = <span class="hljs-string">''</span><br>    &#125;<br>  &#125;,<br>  click: <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> $el = utils.findUpwardElement(e.target, editorElements, <span class="hljs-string">'classList'</span>)<br>    <span class="hljs-keyword">if</span> ($el) &#123;<br>      template.activeElemId = $el.id<br>      catcher.select.id = $el.id<br>      resetRect($el, <span class="hljs-string">'select'</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!utils.findUpwardElement(e.target, [<span class="hljs-string">'mouse-catcher'</span>], <span class="hljs-string">'classList'</span>)) &#123;<br>      removeSelect()<br>    &#125;<br>  &#125;<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span><br><br>onMounted(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">Object</span>.keys(listeners).forEach(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    subpage.value.addEventListener(event, listeners[event], <span class="hljs-literal">true</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>定义修改catcher响应式对象方法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> rectInter &#123;<br>  width: <span class="hljs-built_in">number</span>;<br>  height: <span class="hljs-built_in">number</span>;<br>  top: <span class="hljs-built_in">number</span>;<br>  left: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">// 修改catcher对象方法</span><br><span class="hljs-keyword">const</span> resetRect = ($el: HTMLElement, <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> ($el) &#123;<br>    <span class="hljs-keyword">const</span> parentRect = utils.pick(subpage.value.getBoundingClientRect(), <span class="hljs-string">'left'</span>, <span class="hljs-string">'top'</span>)<br>    <span class="hljs-keyword">const</span> rect: rectInter = utils.pick($el.getBoundingClientRect(), <span class="hljs-string">'width'</span>, <span class="hljs-string">'height'</span>, <span class="hljs-string">'left'</span>, <span class="hljs-string">'top'</span>)<br>    rect.left -= parentRect.left<br>    rect.top -= parentRect.top<br>    catcher[<span class="hljs-keyword">type</span>].rect = rect<br>    catcher[<span class="hljs-keyword">type</span>].eleName = $el.className<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> removeSelect = (): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>  catcher.select.rect.width = <span class="hljs-number">0</span><br>  catcher.select.id = <span class="hljs-string">''</span><br>  catcher.hover.rect.width = <span class="hljs-number">0</span><br>  catcher.hover.id = <span class="hljs-string">''</span><br>  template.activeElemId = <span class="hljs-string">''</span><br>&#125;<br><br><span class="hljs-comment">// 重置select配置</span><br><span class="hljs-keyword">const</span> resetSelectRect = (id: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (id) &#123;<br>    resetRect(<span class="hljs-built_in">document</span>.getElementById(id) <span class="hljs-keyword">as</span> HTMLElement, <span class="hljs-string">'select'</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    removeSelect()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>选中框组件</strong></p><p>选中框组件包括选中框主体（通过不同颜色区分盒子还是元素）、功能栏（上下移动、删除、复制）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// 将catcher对象传入组件<br><span class="hljs-tag">&lt;<span class="hljs-name">MouseCatcher</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ignore"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"catcher"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MouseCatcher</span>&gt;</span><br></code></pre></td></tr></table></figure><p>比较关键的点是在操作功能栏的时候对全局配置的修改，详细逻辑可以查看源码（src/components/mouse-catcher/index.vue）</p><h5 id="2-3-实现可视区拖拽"><a href="#2-3-实现可视区拖拽" class="headerlink" title="2.3 实现可视区拖拽"></a>2.3 实现可视区拖拽</h5><p>接下来是实现可视化展示区的可拖拽，这个区域与选项区不同，它允许内部元素的排序以及拖到别的拖拽组（盒子）。</p><p>关键逻辑如下：(主要分析onEnd回调中的逻辑)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> initSortableSubpage = (): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>  instance._sortableSubpage &amp;&amp; instance._sortableSubpage.destroy()<br>  instance._sortableSubpage = Sortable.create(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.subpage'</span>), &#123;<br>    group: <span class="hljs-string">'shared'</span>,<br>    filter: <span class="hljs-string">'.ignore'</span>,<br>    onStart: <span class="hljs-function">(<span class="hljs-params">&#123; item &#125;: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(item.id)<br>    &#125;,<br>    onEnd: <span class="hljs-function">(<span class="hljs-params">obj: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> &#123; newIndex, oldIndex, originalEvent, item, to &#125; = obj<br>      <span class="hljs-comment">// 在可视区盒子内拖拽</span><br>      <span class="hljs-keyword">if</span> (to.classList.contains(<span class="hljs-string">'subpage'</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; pageX &#125; = originalEvent<br>        <span class="hljs-keyword">const</span> &#123; left, right &#125; = (<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.subpage'</span>) <span class="hljs-keyword">as</span> HTMLElement).getBoundingClientRect()<br>        <span class="hljs-comment">// 判断是否移出可视区</span><br>        <span class="hljs-keyword">if</span> (pageX &lt; left || pageX &gt; right) &#123;<br>          <span class="hljs-comment">// 移出可视区，则移除元素</span><br>          templateStore.config.splice(oldIndex, <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 判断移动位置发生更改</span><br>          <span class="hljs-keyword">if</span> (newIndex !== oldIndex) &#123;<br>            <span class="hljs-comment">// 新的位置在最后一位，需要减1</span><br>            <span class="hljs-keyword">if</span> (newIndex === templateStore.config.length) &#123;<br>              newIndex = newIndex - <span class="hljs-number">1</span><br>            &#125;<br>             <span class="hljs-comment">// 旧的位置在最后一位，需要减1</span><br>            <span class="hljs-keyword">if</span> (oldIndex === templateStore.config.length) &#123;<br>              oldIndex = oldIndex - <span class="hljs-number">1</span><br>            &#125;<br>            <span class="hljs-comment">// 数据互换位置</span><br>            <span class="hljs-keyword">const</span> oldVal = utils.cloneDeep(templateStore.config[oldIndex])<br>            <span class="hljs-keyword">const</span> newVal = utils.cloneDeep(templateStore.config[newIndex])<br>            utils.fill(templateStore.config, oldVal, newIndex, newIndex + <span class="hljs-number">1</span>)<br>            utils.fill(templateStore.config, newVal, oldIndex, oldIndex + <span class="hljs-number">1</span>)<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 若将元素移动至其他拖拽组（盒子）</span><br>        <span class="hljs-keyword">const</span> itemIndex = templateStore.config.findIndex(<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) =&gt;</span> x.id === item.id)<br>        <span class="hljs-keyword">const</span> currContentBox = utils.findConfig(templateStore.config, to.id)<br>        <span class="hljs-keyword">const</span> currItem = templateStore.config.splice(itemIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>        currContentBox.slot.push(currItem)<br>      &#125;<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4-实现盒子内拖拽"><a href="#2-4-实现盒子内拖拽" class="headerlink" title="2.4 实现盒子内拖拽"></a>2.4 实现盒子内拖拽</h5><p>这里需要注意需要筛选可视区盒子subpage中类名为content-box，并且不包含类名为no-drag的。</p><p>其关键逻辑也是在onEnd回调函数里，需要区分元素在当前盒子内部移动、元素移动到其他盒子、元素移动到可视区（subpage）盒子三种情况。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdcd5569e1a3498dbb25e6176cf32456~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="移动三种情况"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> initSortableContentBox = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.subpage .content-box'</span>)).filter(<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) =&gt;</span> !x.classList.contains(<span class="hljs-string">'no-drag'</span>)))<br>  <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.subpage .content-box'</span>)).filter(<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) =&gt;</span> !x.classList.contains(<span class="hljs-string">'no-drag'</span>)).forEach(<span class="hljs-function">(<span class="hljs-params">$content, contentIndex</span>) =&gt;</span> &#123;<br>    instance[<span class="hljs-string">`_sortableContentBox_<span class="hljs-subst">$&#123;contentIndex&#125;</span>`</span>] &amp;&amp; instance[<span class="hljs-string">`_sortableContentBox_<span class="hljs-subst">$&#123;contentIndex&#125;</span>`</span>].destroy()<br>    instance[<span class="hljs-string">`_sortableContentBox_<span class="hljs-subst">$&#123;contentIndex&#125;</span>`</span>] = Sortable.create($content, &#123;<br>      group: <span class="hljs-string">'shared'</span>,<br>      onStart: <span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">from</span> &#125;: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">from</span>.id)<br>      &#125;,<br>      onEnd: <span class="hljs-function">(<span class="hljs-params">obj: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> &#123; newIndex, oldIndex, item, to, <span class="hljs-keyword">from</span> &#125; = obj<br>        <span class="hljs-keyword">if</span> (to.classList.contains(<span class="hljs-string">'subpage'</span>)) &#123; <span class="hljs-comment">// 元素移动至可视区盒子</span><br>          <span class="hljs-keyword">const</span> currContentBox = utils.findConfig(templateStore.config, <span class="hljs-keyword">from</span>.id)<br>          <span class="hljs-keyword">const</span> currItemIndex = currContentBox.slot.findIndex(<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) =&gt;</span> x.id === item.id)<br>          <span class="hljs-keyword">const</span> currItem = currContentBox.slot.splice(currItemIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>          templateStore.config.push(currItem)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.id === to.id) &#123;<br>             <span class="hljs-comment">// 同一盒子中移动</span><br>            <span class="hljs-keyword">const</span> currContentBox = utils.findConfig(templateStore.config, <span class="hljs-keyword">from</span>.id)<br>            <span class="hljs-keyword">if</span> (newIndex !== oldIndex) &#123;<br>              <span class="hljs-keyword">if</span> (newIndex === currContentBox.length) &#123;<br>                newIndex = newIndex - <span class="hljs-number">1</span><br>              &#125;<br>              <span class="hljs-keyword">if</span> (oldIndex === currContentBox.length) &#123;<br>                oldIndex = oldIndex - <span class="hljs-number">1</span><br>              &#125;<br>              <span class="hljs-keyword">const</span> oldVal = utils.cloneDeep(currContentBox.slot[oldIndex])<br>              <span class="hljs-keyword">const</span> newVal = utils.cloneDeep(currContentBox.slot[newIndex])<br>              utils.fill(currContentBox.slot, oldVal, newIndex, newIndex + <span class="hljs-number">1</span>)<br>              utils.fill(currContentBox.slot, newVal, oldIndex, oldIndex + <span class="hljs-number">1</span>)<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从一个盒子移动到另一个盒子</span><br>            <span class="hljs-keyword">const</span> currContentBox = utils.findConfig(templateStore.config, <span class="hljs-keyword">from</span>.id)<br>            <span class="hljs-keyword">const</span> currItemIndex = currContentBox.slot.findIndex(<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) =&gt;</span> x.id === item.id)<br>            <span class="hljs-keyword">const</span> currItem = currContentBox.slot.splice(currItemIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">const</span> toContentBox = utils.findConfig(templateStore.config, to.id)<br>            toContentBox.slot.push(currItem)<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、元素配置编辑区"><a href="#3、元素配置编辑区" class="headerlink" title="3、元素配置编辑区"></a>3、元素配置编辑区</h4><p>该区域是用于编辑修改元素的行内样式，目前简单实现了字体、位置布局、背景、边框、阴影配置。</p><h5 id="3-1-字体编辑"><a href="#3-1-字体编辑" class="headerlink" title="3.1 字体编辑"></a>3.1 字体编辑</h5><p>字体编辑功能使用富文本编辑器tinymce，这里使用vue3-tinymce，它是基于 <code>vue@3.x</code> + <code>tinymce@5.8.x</code> 封装的富文本编辑器。</p><p>更多配置可参考<a href="https://jsdawn.gitee.io/vue3-tinymce/" target="_blank" rel="noopener">官方文档</a>, 下面的对vue3-tinymce进行封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;vue3-tinymce v-model&#x3D;&quot;state.content&quot; :setting&#x3D;&quot;state.setting&quot; &#x2F;&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot; setup&gt;<br>import &#123; reactive, watch &#125; from &#39;vue&#39;;<br>&#x2F;&#x2F; 引入组件<br>import Vue3Tinymce from &#39;@jsdawn&#x2F;vue3-tinymce&#39;<br>import &#123; useTemplateStore &#125; from &#39;@&#x2F;stores&#x2F;template&#39;<br>import &#123; findConfig &#125; from &#39;@&#x2F;utils&#39;<br><br>const template &#x3D; useTemplateStore()<br>const props &#x3D; defineProps(&#123;<br>  modelValue: &#123;<br>    type: String,<br>    default: &#39;&#39;<br>  &#125;<br>&#125;)<br><br>const state &#x3D; reactive(&#123;<br>  content: &#39;&#39;,<br>  setting: &#123;<br>    height: 300,<br>    language: &#39;zh-Hans&#39;,<br>    language_url: &#39;&#x2F;tinymce&#x2F;langs&#x2F;zh-Hans.js&#39;<br>  &#125;<br>&#125;)<br><br>watch(() &#x3D;&gt; props.modelValue, () &#x3D;&gt; &#123;<br>  props.modelValue &amp;&amp; (state.content &#x3D; findConfig(template.config, props.modelValue)?.value)<br>&#125;)<br><br>watch(() &#x3D;&gt; state.content, () &#x3D;&gt; &#123;<br>  const config &#x3D; findConfig(template.config, props.modelValue)<br>  config &amp;&amp; (config.value &#x3D; state.content)<br>&#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h5 id="3-2-位置布局"><a href="#3-2-位置布局" class="headerlink" title="3.2 位置布局"></a>3.2 位置布局</h5><p>可修改元素的内外边距、宽高、布局类型（display）、定位类型（position）。</p><h5 id="3-3-背景"><a href="#3-3-背景" class="headerlink" title="3.3 背景"></a>3.3 背景</h5><p>可修改元素背景颜色、圆角、渐变方式。</p><h5 id="3-4-边框"><a href="#3-4-边框" class="headerlink" title="3.4 边框"></a>3.4 边框</h5><p>可修改边框类型，包括无边框、实线、虚线、点线</p><h5 id="3-5-阴影"><a href="#3-5-阴影" class="headerlink" title="3.5 阴影"></a>3.5 阴影</h5><p>可修改阴影颜色、以及阴影的X、Y、距离、大小。</p><h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><h4 id="1、文字组件"><a href="#1、文字组件" class="headerlink" title="1、文字组件"></a>1、文字组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>export default &#123;<br>  name: &quot;ContentInput&quot;<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;script setup lang&#x3D;&#39;ts&#39;&gt;<br>import &#123; PropType &#125; from &#39;vue&#39;;<br>import &#123; useStyleFix &#125; from &#39;@&#x2F;utils&#x2F;hooks&#39;<br><br>const props &#x3D; defineProps(&#123;<br>  config: &#123;<br>    type: Object as PropType&lt;any&gt;<br>  &#125;<br>&#125;)<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>  &lt;div <br>    class&#x3D;&quot;content-input&quot;<br>    v-html&#x3D;&quot;props.config.value&quot;<br>    :style&#x3D;&quot;[props.config.style, useStyleFix(props.config.style)]&quot;<br>  &gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;<br>.content-input &#123;<br>  word-break: break-all;<br>  user-select: none;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><h4 id="2、图片组件"><a href="#2、图片组件" class="headerlink" title="2、图片组件"></a>2、图片组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>export default &#123;<br>  name: &quot;ContentAsset&quot;<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;script setup lang&#x3D;&#39;ts&#39;&gt;<br>import &#123; PropType &#125; from &#39;vue&#39;<br><br>const props &#x3D; defineProps(&#123;<br>  config: &#123;<br>    type: Object as PropType&lt;any&gt;<br>  &#125;<br>&#125;)<br>&lt;&#x2F;script&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;content-asset&quot; :style&#x3D;&quot;props.config.style&quot;&gt;<br>    &lt;img :src&#x3D;&quot;props.config.value&quot;&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;<br>img &#123;<br>  width: 100%;<br>  height: 100%;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><h4 id="3、盒子组件"><a href="#3、盒子组件" class="headerlink" title="3、盒子组件"></a>3、盒子组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>export default &#123;<br>  name: &quot;ContentBox&quot;<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;script setup lang&#x3D;&#39;ts&#39;&gt;<br>import &#123; PropType &#125; from &#39;vue&#39;<br>const props &#x3D; defineProps(&#123;<br>    config: &#123;<br>    type: Object as PropType&lt;any&gt;<br>  &#125;<br>&#125;)<br>&lt;&#x2F;script&gt;<br>&lt;template&gt;<br>  &lt;div :class&#x3D;&quot;[&#39;content-box&#39;, &#123; &#39;no-drag&#39;: props.config.noDrag &#125;]&quot; :style&#x3D;&quot;props.config.style&quot;&gt;<br>    &lt;component v-for&#x3D;&quot;item in props.config.slot&quot; :key&#x3D;&quot;item.id&quot; :is&#x3D;&quot;item.name&quot; :config&#x3D;&quot;item&quot; :id&#x3D;&quot;item.id&quot;&gt;&lt;&#x2F;component&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p>到这里基本的实现流程都完毕，目前的版本还比较简单，还有很多可以实现的功能，比如撤回、重做、自定义组件选项、接入数据库.</p>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>低代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>setup语法糖以及pinia的使用</title>
    <link href="/my-hexo-blog/2022/05/10/setup%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BB%A5%E5%8F%8Apinia%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/my-hexo-blog/2022/05/10/setup%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BB%A5%E5%8F%8Apinia%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="vue3-compositionAPI-相关-vue3-2-setup语法糖"><a href="#vue3-compositionAPI-相关-vue3-2-setup语法糖" class="headerlink" title="vue3 compositionAPI 相关 (vue3.2 setup语法糖)"></a>vue3 compositionAPI 相关 (vue3.2 setup语法糖)</h3><h4 id="1、文件结构"><a href="#1、文件结构" class="headerlink" title="1、文件结构"></a>1、文件结构</h4><p>  vue2中限制template只能有一个根元素，vue3没有限制  </p><h4 id="2、data"><a href="#2、data" class="headerlink" title="2、data"></a>2、data</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br> import &#123; reactive, ref, toRefs &#125; from &#39;vue&#39;<br>&#x2F;&#x2F; ref声明响应式数据，用于声明基本数据类型<br>const name &#x3D; ref(&#39;YoLin&#39;)<br>&#x2F;&#x2F; 修改<br>name.value &#x3D; &#39;Deng&#39;<br>&#x2F;&#x2F; reactive声明响应式数据，用于声明引用数据类型<br>const state &#x3D; reactive(&#123;<br>  name: &#39;YoLin&#39;,<br>  sex: &#39;男&#39;<br>&#125;)<br>&#x2F;&#x2F; 修改<br>state.name &#x3D; &#39;Deng&#39;<br><br>&#x2F;&#x2F; 使用toRefs解构<br>const &#123; name, sex &#125; &#x3D; toRefs(state)<br>&#x2F;&#x2F; 在template中可直接使用&#123;&#123; name &#125;&#125;、&#123;&#123; sex &#125;&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="3、method"><a href="#3、method" class="headerlink" title="3、method"></a>3、method</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &#x2F;&#x2F; 调用方法<br>  &lt;button @click&#x3D;&#39;changeName&#39;&gt;按钮&lt;&#x2F;button&gt;  <br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; reactive &#125; from &#39;vue&#39;<br><br>  const state &#x3D; reactive(&#123;<br>    name: &#39;YoLin&#39;<br>  &#125;)<br><br>  &#x2F;&#x2F; 声明method方法<br>  const changeName &#x3D; () &#x3D;&gt; &#123;<br>    state.name &#x3D; &#39;Deng&#39;<br>  &#125;  <br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="4、computed"><a href="#4、computed" class="headerlink" title="4、computed"></a>4、computed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import &#123; computed, ref &#125; from &#39;vue&#39;<br>  <br>  let count &#x3D; ref(0)<br>  const doubuleCount &#x3D; computed(() &#x3D;&gt; &#123;<br>    return count.value * 2<br>  &#125;)<br> &lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="5、watch"><a href="#5、watch" class="headerlink" title="5、watch"></a>5、watch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import &#123; watch, reactive &#125; from &#39;vue&#39;<br>  <br>  const state &#x3D; reactive(&#123;<br>    count: 1<br>  &#125;)<br>  const changeCount &#x3D; () &#x3D;&gt; &#123;<br>    state.count &#x3D; state.count * 2<br>  &#125;<br>  watch(() &#x3D;&gt; state.count, (newVal, oldVal) &#x3D;&gt; &#123;<br>    console.log(newVal)<br>  &#125;, &#123;<br>    immediate: true, &#x2F;&#x2F;立刻执行<br>    deep: true &#x2F;&#x2F; 深度监听<br>  &#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="6、props-父传子"><a href="#6、props-父传子" class="headerlink" title="6、props 父传子"></a>6、props 父传子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">子组件<br>&lt;template&gt;<br>  &lt;span&gt;&#123;&#123;props.name&#125;&#125;&lt;&#x2F;span&gt;<br>  &#x2F;&#x2F; 可省略【props.】<br>  &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  &#x2F;&#x2F; import &#123; defineProps &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; defineProps在&lt;script setup&gt;中自动可用，无需导入<br>  &#x2F;&#x2F; 需在.eslintrc.js文件中【globals】下配置【defineProps: true】<br><br>  &#x2F;&#x2F; 声明props<br>  const props &#x3D; defineProps(&#123;<br>    name: &#123;<br>      type: String,<br>      default: &#39;&#39;<br>    &#125;<br>  &#125;)  <br>&lt;&#x2F;script&gt;<br><br>父组件<br>引入子组件，组件会自动注册  <br>&lt;template&gt;<br>  &lt;child name&#x3D;&#39;Jerry&#39;&#x2F;&gt;  <br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  &#x2F;&#x2F; 引入子组件<br>  import child from &#39;.&#x2F;child.vue&#39;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="7、emit-子传父"><a href="#7、emit-子传父" class="headerlink" title="7、emit 子传父"></a>7、emit 子传父</h4><p>子组件. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;span&gt;&#123;&#123;props.name&#125;&#125;&lt;&#x2F;span&gt;<br>  &#x2F;&#x2F; 可省略【props.】<br>  &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt;<br>  &lt;button @click&#x3D;&#39;changeName&#39;&gt;更名&lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  &#x2F;&#x2F; import &#123; defineEmits, defineProps &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; defineEmits和defineProps在&lt;script setup&gt;中自动可用，无需导入<br>  &#x2F;&#x2F; 需在.eslintrc.js文件中【globals】下配置【defineEmits: true】、【defineProps: true】<br><br>  &#x2F;&#x2F; 声明props<br>  const props &#x3D; defineProps(&#123;<br>    name: &#123;<br>      type: String,<br>      default: &#39;&#39;<br>    &#125;<br>  &#125;) <br>  &#x2F;&#x2F; 声明事件<br>  const emit &#x3D; defineEmits([&#39;updateName&#39;])<br>  <br>  const changeName &#x3D; () &#x3D;&gt; &#123;<br>    &#x2F;&#x2F; 执行<br>    emit(&#39;updateName&#39;, &#39;Tom&#39;)<br>  &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;child :name&#x3D;&#39;state.name&#39; @updateName&#x3D;&#39;updateName&#39;&#x2F;&gt;  <br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; reactive &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; 引入子组件<br>  import child from &#39;.&#x2F;child.vue&#39;<br><br>  const state &#x3D; reactive(&#123;<br>    name: &#39;YoLin&#39;<br>  &#125;)<br>  <br>  &#x2F;&#x2F; 接收子组件触发的方法<br>  const updateName &#x3D; (name) &#x3D;&gt; &#123;<br>    state.name &#x3D; name<br>  &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="8、v-model"><a href="#8、v-model" class="headerlink" title="8、v-model"></a>8、v-model</h4><p>支持绑定多个v-model，v-model 是v-model:modelValue的简写</p><p>绑定其他字段，如v-model:name</p><p>子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;span @click&#x3D;&quot;changeInfo&quot;&gt;我叫&#123;&#123; modelValue &#125;&#125;，今年&#123;&#123; age &#125;&#125;岁&lt;&#x2F;span&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  &#x2F;&#x2F; import &#123; defineEmits, defineProps &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; defineEmits和defineProps在&lt;script setup&gt;中自动可用，无需导入<br>  &#x2F;&#x2F; 需在.eslintrc.js文件中【globals】下配置【defineEmits: true】、【defineProps: true】<br><br>  defineProps(&#123;<br>    modelValue: String,<br>    age: Number<br>  &#125;)<br><br>    const emit &#x3D; defineEmits([&#39;update:modelValue&#39;, &#39;update:age&#39;])<br>  const changeInfo &#x3D; () &#x3D;&gt; &#123;<br>    &#x2F;&#x2F; 触发父组件值更新<br>    emit(&#39;update:modelValue&#39;, &#39;Tom&#39;)<br>    emit(&#39;update:age&#39;, 30)<br>  &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &#x2F;&#x2F; v-model:modelValue简写为v-model<br>  &#x2F;&#x2F; 可绑定多个v-model<br>  &lt;child<br>    v-model&#x3D;&quot;state.name&quot;<br>    v-model:age&#x3D;&quot;state.age&quot;<br>  &#x2F;&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; reactive &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; 引入子组件<br>  import child from &#39;.&#x2F;child.vue&#39;<br><br>  const state &#x3D; reactive(&#123;<br>    name: &#39;Jerry&#39;,<br>    age: 20<br>  &#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="9、nextTick"><a href="#9、nextTick" class="headerlink" title="9、nextTick"></a>9、nextTick</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import &#123; nextTick &#125; from &#39;vue&#39;<br><br>  nextTick(() &#x3D;&gt; &#123;<br>    &#x2F;&#x2F; ...<br>  &#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="10、子组件ref变量和defineExpose"><a href="#10、子组件ref变量和defineExpose" class="headerlink" title="10、子组件ref变量和defineExpose"></a>10、子组件ref变量和defineExpose</h4><p>1、在标准的组件写法中，子组件的数据是默认隐式暴露给父组件的，但在script-setup模式下，所以的数据只是默认return给template使用，不会暴露到外部组件，所以父组件无法通过挂载ref变量来获取子组件的数据</p><p>2、如果想要调用子组件的数据，需要先在子组件显示的暴露出来，才能够正确的拿到，这个操作，就是由defineExpose来完成</p><p>子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;span&gt;&#123;&#123;state.name&#125;&#125;&lt;&#x2F;span&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; reactive, toRefs &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; defineExpose无需引入<br>  &#x2F;&#x2F; import &#123; defineExpose, reactive, toRefs &#125; from &#39;vue&#39;<br><br>  &#x2F;&#x2F; 声明state<br>  const state &#x3D; reactive(&#123;<br>    name: &#39;YoLin&#39;<br>  &#125;) <br><br>  &#x2F;&#x2F; 将方法、变量暴露给父组件使用，父组件才可通过ref API拿到子组件暴露的数据<br>  defineExpose(&#123;<br>    &#x2F;&#x2F; 解构state<br>    ...toRefs(state),<br>    &#x2F;&#x2F; 声明方法<br>    changeName () &#123;<br>      state.name &#x3D; &#39;Deng&#39;<br>    &#125;<br>  &#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;child ref&#x3D;&#39;childRef&#39;&#x2F;&gt;  <br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; ref, nextTick &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; 引入子组件<br>  import child from &#39;.&#x2F;child.vue&#39;<br><br>  &#x2F;&#x2F; 子组件ref（TypeScript语法）<br>  const childRef &#x3D; ref&lt;InstanceType&lt;typeof child&gt;&gt;()<br>  <br>  &#x2F;&#x2F; nextTick<br>  nextTick(() &#x3D;&gt; &#123;<br>    &#x2F;&#x2F; 获取子组件name<br>    console.log(childRef.value.name)<br>    &#x2F;&#x2F; 执行子组件方法<br>    childRef.value.changeName()<br>  &#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="11、插槽"><a href="#11、插槽" class="headerlink" title="11、插槽"></a>11、插槽</h4><p>  子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &#x2F;&#x2F; 匿名插槽<br>  &lt;slot&#x2F;&gt;<br>  &#x2F;&#x2F; 具名插槽<br>  &lt;slot name&#x3D;&#39;title&#39;&#x2F;&gt;<br>  &#x2F;&#x2F; 作用域插槽<br>  &lt;slot name&#x3D;&quot;footer&quot; :scope&#x3D;&quot;state&quot; &#x2F;&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; useSlots, reactive &#125; from &#39;vue&#39;<br>  const state &#x3D; reactive(&#123;<br>    name: &#39;张三&#39;,<br>    age: &#39;25岁&#39;<br>  &#125;)<br>  <br>  const slots &#x3D; useSlots()<br>  &#x2F;&#x2F; 匿名插槽使用情况<br>  const defaultSlot &#x3D; reactive(slots.default &amp;&amp; slots.default().length)<br>  console.log(defaultSlot) &#x2F;&#x2F; 1<br>  &#x2F;&#x2F; 具名插槽使用情况<br>  const titleSlot &#x3D; reactive(slots.title &amp;&amp; slots.title().length)<br>  console.log(titleSlot) &#x2F;&#x2F; 3<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;child&gt;<br>    &#x2F;&#x2F; 匿名插槽<br>    &lt;span&gt;我是默认插槽&lt;&#x2F;span&gt;<br>    &#x2F;&#x2F; 具名插槽<br>    &lt;template #title&gt;<br>      &lt;h1&gt;我是具名插槽&lt;&#x2F;h1&gt;<br>      &lt;h1&gt;我是具名插槽&lt;&#x2F;h1&gt;<br>      &lt;h1&gt;我是具名插槽&lt;&#x2F;h1&gt;<br>    &lt;&#x2F;template&gt;<br>    &#x2F;&#x2F; 作用域插槽<br>    &lt;template #footer&#x3D;&quot;&#123; scope &#125;&quot;&gt;<br>      &lt;footer&gt;作用域插槽——姓名：&#123;&#123; scope.name &#125;&#125;，年龄&#123;&#123; scope.age &#125;&#125;&lt;&#x2F;footer&gt;<br>    &lt;&#x2F;template&gt;<br>  &lt;&#x2F;child&gt; <br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  &#x2F;&#x2F; 引入子组件<br>  import child from &#39;.&#x2F;child.vue&#39;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="12、路由useRoute和useRouter"><a href="#12、路由useRoute和useRouter" class="headerlink" title="12、路由useRoute和useRouter"></a>12、路由useRoute和useRouter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import &#123; useRoute, useRouter &#125; from &#39;vue-router&#39;<br>  &#x2F;&#x2F; 必须先声明<br>  const route &#x3D; useRoute()<br>  const router &#x3D; useRouter()<br>  <br>  &#x2F;&#x2F; 路由信息<br>  console.log(route.query)<br>  &#x2F;&#x2F; 路由跳转<br>  router.push(&#39;&#x2F;index&#39;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="13、路由导航守卫"><a href="#13、路由导航守卫" class="headerlink" title="13、路由导航守卫"></a>13、路由导航守卫</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; from &#39;vue-router&#39;<br>  &#x2F;&#x2F;添加一个导航守卫，当组件将要离开的时候触发<br> onBeforeRouteLeave((to, from, next) &#x3D;&gt; &#123;<br>next()<br> &#125;)<br>  &#x2F;&#x2F; 添加一个导航守卫，当组件将要更新时触发<br>  onBeforeRouteUpdate((to, from, next) &#x3D;&gt;&#123;<br>    next()<br>  &#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="14、store"><a href="#14、store" class="headerlink" title="14、store"></a>14、store</h4><p>  <strong>vuex</strong></p><p>  *Vue3 中的Vuex不再提供辅助函数写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import &#123; useStore &#125; from &#39;vuex&#39;<br>  import &#123; key &#125; from &#39;..&#x2F;store&#x2F;index&#39;<br><br>  &#x2F;&#x2F; 必须先声明调用<br>  const store &#x3D; useStore(key)<br><br>  &#x2F;&#x2F; 获取Vuex的state<br>  store.state.xxx<br><br>  &#x2F;&#x2F; 触发mutations的方法<br>  store.commit(&#39;fnName&#39;)<br><br>  &#x2F;&#x2F; 触发actions的方法<br>  store.dispatch(&#39;fnName&#39;)<br><br>  &#x2F;&#x2F; 获取Getters<br>  store.getters.xxx<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="15、pinia"><a href="#15、pinia" class="headerlink" title="15、pinia"></a>15、pinia</h4><p> <code>Pinia</code> 就是 <code>Vuex 5</code> ，<code>Pinia</code> 的优点：</p><ul><li><p>1、同时支持 Composition Api 和 Options api 的语法；</p></li><li><p>2、去掉 mutations ，只有 state 、getters 和 actions ；</p></li><li><p>3、不支持嵌套的模块，通过组合 store 来代替；</p></li></ul><p>*4、更完善的typescript支持</p><ul><li>5、清晰、显式的代码拆分</li></ul><p>安装：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用 npm</span><br>npm install pinia<br><br><span class="hljs-comment"># 使用 yarn</span><br>yarn <span class="hljs-keyword">add</span><span class="bash"> pinia</span><br></code></pre></td></tr></table></figure><p>main.js引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span><br><br><span class="hljs-keyword">const</span> app = createApp(App)<br>app.use(createPinia())<br>app.mount(<span class="hljs-string">'#app'</span>)<br></code></pre></td></tr></table></figure><p>配置store.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span><br><br><span class="hljs-comment">// defineStore 调用后返回一个函数，调用该函数获得 Store 实体</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useStore = defineStore(&#123;<br>  <span class="hljs-comment">// id: 必须，在所有 Store 中唯一</span><br>  id: <span class="hljs-string">'globalState'</span>,<br>  <span class="hljs-comment">// state: 返回对象的函数</span><br>  state: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;<br>    count: <span class="hljs-number">1</span>,<br>    data: &#123;<br>      name: <span class="hljs-string">'Jerry'</span>,<br>      sex: <span class="hljs-string">'男'</span><br>    &#125;<br>  &#125;),<br>  <span class="hljs-comment">// getter 第一个参数是 state，是当前的状态，也可以使用 this 获取状态</span><br>  <span class="hljs-comment">// getter 中也可以访问其他的 getter，或者是其他的 Store</span><br>  getters: &#123;<br>    <span class="hljs-comment">// 通过 state 获取状态</span><br>    doubleCount: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.count * <span class="hljs-number">2</span>,<br>    <span class="hljs-comment">// 通过 this 获取状态（注意this指向）</span><br>    tripleCount() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count * <span class="hljs-number">3</span><br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    updateData (newData, count) &#123;<br>      <span class="hljs-comment">// 使用 this 直接修改</span><br>      <span class="hljs-keyword">this</span>.data = &#123; ...newData &#125;<br>      <span class="hljs-keyword">this</span>.count = count<br>      <br>      <span class="hljs-comment">// 使用 $patch 修改多个值</span><br>      <span class="hljs-keyword">this</span>.$patch(&#123;<br>        data: &#123; ...newData &#125;,<br>        count<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用store</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &#x2F;&#x2F; 获取 store 的 state<br>  &lt;p&gt;姓名：&#123;&#123;store.data.name&#125;&#125;&lt;&#x2F;p&gt;<br>  &lt;p&gt;性别：&#123;&#123;store.data.sex&#125;&#125;&lt;&#x2F;p&gt;<br>  <br>  &#x2F;&#x2F; 调用 mutations 方法 &#x2F; 修改 store<br>  &lt;button @click&#x3D;&#39;update&#39;&gt;修改用户信息&lt;&#x2F;button&gt;<br>  <br>  &#x2F;&#x2F; 获取 getter<br>  &lt;p&gt;获取getter：&#123;&#123;store.doubleCount&#125;&#125;&lt;&#x2F;p&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; useStore &#125; from &#39;@store&#x2F;store.js&#39;<br>  const store &#x3D; useStore()<br>  <br>  function update () &#123;<br>    &#x2F;&#x2F; 通过 actions 定义的方法修改 state<br>    store.updateData(&#123; name: &#39;Tom&#39;, sex: &#39;女&#39; &#125;)<br>    <br>    &#x2F;&#x2F; 通过 store 直接修改<br>    store.data &#x3D; &#123; name: &#39;Tom&#39;, sex: &#39;女&#39; &#125;<br>    <br>    &#x2F;&#x2F; 同时改变多个状态<br>    store.$patch((state) &#x3D;&gt; &#123;<br>      state.data &#x3D; &#123; name: &#39;Tom&#39;, sex: &#39;女&#39; &#125;<br>      state.count &#x3D; 2<br>    &#125;)<br>  &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p>其他方法</p><p>1、$state可以替换store的整个state</p><p>2、重制状态， <code>$reset()</code> 方法将状态重置为初始值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = useStore()<br>store.$state = &#123;&#125;<br>store.$reset()<br></code></pre></td></tr></table></figure><h4 id="16、声明周期"><a href="#16、声明周期" class="headerlink" title="16、声明周期"></a>16、声明周期</h4><p>通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。</p><p>Option API: beforeCreate、created、beforeMount、mounted、beforeUnmount(原vue2的beforeDestroy)、unmounted(原vue2的destroyed)、errorCaptured<br>activated、deactivated(在keep-alive标签下才有)</p><p>renderTracked(新增，状态跟踪, 每次渲染后重新收集响应式依赖)、renderTriggered(新增、状态触发, 每次触发页面重新渲染时自动执行), 新增的这两个用于调试使用</p><p>Composition API: setup中不需要beforeCreate 和 created, 其余只需要在Option API名称前面加上“on”</p><h4 id="17、原型绑定与组件内使用"><a href="#17、原型绑定与组件内使用" class="headerlink" title="17、原型绑定与组件内使用"></a>17、原型绑定与组件内使用</h4><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span><br><span class="hljs-keyword">const</span> app = createApp(App)<br><br><span class="hljs-comment">// 获取原型</span><br><span class="hljs-keyword">const</span> prototype = app.config.globalProperties<br><br><span class="hljs-comment">// 绑定参数</span><br>prototype.name = <span class="hljs-string">'Jerry'</span><br></code></pre></td></tr></table></figure><p>组件内使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import &#123; getCurrentInstance &#125; from &#39;vue&#39;<br><br>  &#x2F;&#x2F; 获取原型<br>  const &#123; proxy &#125; &#x3D; getCurrentInstance()<br>  <br>  &#x2F;&#x2F; 输出<br>  console.log(proxy.name)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="18、V-bind-css-变量注入"><a href="#18、V-bind-css-变量注入" class="headerlink" title="18、V-bind() css 变量注入"></a>18、V-bind() css 变量注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;span&gt;Jerry&lt;&#x2F;span&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; ref, reactive &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; prop接收样式<br>  const props &#x3D; defineProps(&#123;<br>    border: &#123;<br>      type: String,<br>      default: &#39;1px solid yellow&#39;<br>    &#125;<br>  &#125;)<br>  <br>  &#x2F;&#x2F; 常量声明样式<br>  const background &#x3D; &#39;red&#39;<br>  <br>  &#x2F;&#x2F; 响应式数据声明样式<br>  const color &#x3D; ref(&#39;blue&#39;)<br>  const style &#x3D; reactive(&#123;<br>    opacity: &#39;0.8&#39;<br>  &#125;)<br>&lt;&#x2F;script&gt;<br><br>&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;<br>  span &#123;<br>    &#x2F;&#x2F; 使用常量声明的样式<br>    background: v-bind(background);<br>    <br>    &#x2F;&#x2F; 使用响应式数据声明的样式<br>    color: v-bind(color);<br>    opacity: v-bind(&#39;style.opacity&#39;);<br>    <br>    &#x2F;&#x2F; 使用prop接收的样式<br>    border: v-bind(&#39;props.border&#39;);<br>  &#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><h4 id="19、Provide-和inject"><a href="#19、Provide-和inject" class="headerlink" title="19、Provide 和inject"></a>19、Provide 和inject</h4><p>  父组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;child&#x2F;&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>  import &#123; provide &#125; from &#39;vue&#39;<br>  import &#123; ref, watch &#125; from &#39;vue&#39;<br>  &#x2F;&#x2F; 引入子组件<br>  import child from &#39;.&#x2F;child.vue&#39;<br><br>  let name &#x3D; ref(&#39;Jerry&#39;)<br>  &#x2F;&#x2F; 声明provide<br>  provide(&#39;provideState&#39;, &#123;<br>    name,<br>    changeName: () &#x3D;&gt; &#123;<br>      name.value &#x3D; &#39;Tom&#39;<br>    &#125;<br>  &#125;)<br><br>  &#x2F;&#x2F; 监听name改变<br>  watch(name, () &#x3D;&gt; &#123;<br>    console.log(&#96;name变成了$&#123;name&#125;&#96;)<br>    setTimeout(() &#x3D;&gt; &#123;<br>      console.log(name.value) &#x2F;&#x2F; Tom<br>    &#125;, 1000)<br>  &#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  import &#123; inject &#125; from &#39;vue&#39;<br>&#x2F;&#x2F; 注入<br>  const provideState &#x3D; inject(&#39;provideState&#39;)<br>  <br>  &#x2F;&#x2F; 子组件触发name改变<br>  provideState.changeName()<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="20、对await-的支持"><a href="#20、对await-的支持" class="headerlink" title="20、对await 的支持"></a>20、对await 的支持</h4><p>不必再配合 async 就可以直接使用 await 了，这种情况下，组件的 setup 会自动变成 async setup </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>  const post &#x3D; await fetch(&#39;&#x2F;api&#39;).then(() &#x3D;&gt; &#123;&#125;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="21、定义组件的name"><a href="#21、定义组件的name" class="headerlink" title="21、定义组件的name"></a>21、定义组件的name</h4><p>用单独的<code>&lt;script&gt;</code>块来定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    name: &#39;ComponentName&#39;,<br>  &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/my-hexo-blog/2022/05/06/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/my-hexo-blog/2022/05/06/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h3><ul><li><p><strong>减少HTTP请求</strong>：尽量减少页面的请求数（<strong>首次加载同时请求数不能超过4个</strong>）</p><ul><li><p>合并CSS和JS</p></li><li><p>使用CSS精灵图</p></li></ul></li><li><p><strong>缓存资源</strong></p><p>使用缓存可减少向服务器的请求数，节省加载时间，所有静态资源都要在服务器端设置缓存</p><ul><li>缓存一切可缓存的资源</li><li>使用长缓存</li><li>使用外联的样式和脚本</li></ul></li><li><p><strong>压缩代码</strong></p><p>减少资源大小可加快网页显示速度，对代码进行压缩，并在服务器端设置<code>GZip</code></p><ul><li>压缩代码(多余的缩进、空格和换行符)</li><li>启用Gzip</li></ul></li><li><p><strong>无阻塞</strong>：头部内联的样式和脚本会阻塞页面的渲染，样式放在头部并使用<code>link</code>方式引入，脚本放在尾部并使用异步方式加载</p></li><li><p><strong>首屏加载</strong> </p><p>针对首屏的快速显示做优化</p></li><li><p><strong>按需加载</strong></p><p>将不影响首屏的资源和当前屏幕不用的资源放到用户需要时才加载，可大大提升显示速度和降低总体流量(<strong>按需加载会导致大量重绘，影响渲染性能</strong>)</p><ul><li>懒加载</li><li>滚屏加载</li><li>Media Query加载</li></ul></li><li><p><strong>预加载</strong></p><p>大型资源页面可使用<code>Loading</code>，资源加载完成后再显示页面，但加载时间过长，会造成用户流失</p></li><li><p><strong>压缩图像</strong></p><ul><li>使用<a href="https://tinyjpg.com/" target="_blank" rel="noopener">TinyJpg</a>和<a href="https://tinypng.com/" target="_blank" rel="noopener">TinyPng</a>压缩图像</li><li>使用CSS3、SVG、IconFont代替图像</li><li>使用img的srcset按需加载图像</li></ul></li><li><p><strong>减少Cookie</strong></p><p>Cookie会影响加载速度，静态资源域名不使用Cookie</p></li><li><p><strong>避免重定向</strong></p></li><li><p><strong>异步加载第三方资源</strong></p></li></ul><h3 id="执行优化"><a href="#执行优化" class="headerlink" title="执行优化"></a>执行优化</h3><ul><li><p><strong>CSS写在头部，JS写在尾部并异步</strong></p></li><li><p><strong>避免img、iframe等的src为空</strong>：空<code>src</code>会重新加载当前页面，影响速度和效率</p></li><li><p><strong>尽量避免重置图像大小</strong>：多次重置图像大小会引发图像的多次重绘，影响性能</p></li><li><p><strong>图像尽量避免使用DataURL</strong>：<code>DataURL</code>图像没有使用图像的压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长</p></li></ul><h3 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a><strong>渲染优化</strong></h3><ul><li><p><strong>设置viewport</strong>：HTML的<code>viewport</code>可加速页面的渲染</p></li><li><p><strong>减少DOM节点</strong></p></li><li><p><strong>优化动画</strong></p><ul><li>尽量使用CSS3动画</li><li>合理使用requestAnimationFrame动画代替setTimeout</li><li>适当使用Canvas动画：5个元素以内使用<code>CSS动画</code>，5个元素以上使用<code>Canvas动画</code>，<code>iOS8+</code>可使用<code>WebGL动画</code></li></ul></li><li><p><strong>优化高频事件</strong>：<code>scroll</code>、<code>touchmove</code>等事件可导致多次渲染</p><p>（1）函数节流</p><p>（2）函数防抖</p><p>（3）使用requestAnimationFrame监听帧变化：使得在正确的时间进行渲染</p><p>（4）增加响应变化的时间间隔：减少重绘次数</p></li><li><p><strong>GPU加速</strong></p><p>使用某些HTML5标签和CSS3属性会触发<code>GPU渲染</code>，请合理使用(<strong>过渡使用会引发手机耗电量增加</strong>)</p><ul><li>HTML标签：<code>video</code>、<code>canvas</code>、<code>webgl</code></li><li>CSS属性：<code>opacity</code>、<code>transform</code>、<code>transition</code></li></ul></li></ul><h3 id="样式优化"><a href="#样式优化" class="headerlink" title="样式优化"></a><strong>样式优化</strong></h3><ul><li><strong>避免在HTML中书写style</strong></li><li><strong>避免CSS表达式</strong></li></ul><ul><li><p><strong>移除CSS空规则</strong></p></li><li><p><strong>正确使用display</strong></p></li><li><p><strong>不滥用float</strong></p></li><li><p><strong>不滥用Web字体</strong></p></li><li><p><strong>不声明过多的font-size</strong>： 过多的<code>font-size</code>影响CSS树的效率</p></li><li><p><strong>值为0时不需要任何单位</strong></p></li><li><p><strong>标准化各种浏览器前缀</strong></p><p>无前缀属性应放在最后</p><p>CSS动画属性只用-webkit-、无前缀两种</p><p>其它前缀为-webkit-、-moz-、-ms-、无前缀四种：<code>Opera</code>改用<code>blink</code>内核，<code>-o-</code>已淘汰</p></li><li><p><strong>避免让选择符看起来像正则表达式</strong>：高级选择符执行耗时长且不易读懂，避免使用</p></li></ul><h3 id="脚本优化"><a href="#脚本优化" class="headerlink" title="脚本优化"></a><strong>脚本优化</strong></h3><ul><li><p><strong>减少重绘和回流</strong></p><p>避免不必要的DOM操作</p><p>避免使用document.write</p><p>减少drawImage</p><p>尽量改变class而不是style，使用classList代替className</p></li><li><p><strong>缓存DOM选择与计算</strong></p></li><li><p><strong>缓存.length的值</strong></p></li><li><p><strong>尽量使用事件代理</strong></p></li><li><p><strong>尽量使用id选择器</strong></p></li></ul><ul><li><strong>touch事件优化</strong>：使用<code>tap</code>(<code>touchstart</code>和<code>touchend</code>)代替<code>click</code>(<strong>注意<code>touch</code>响应过快，易引发误操作</strong>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>页面加载优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP相关</title>
    <link href="/my-hexo-blog/2022/04/08/HTTP%E7%9B%B8%E5%85%B3/"/>
    <url>/my-hexo-blog/2022/04/08/HTTP%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP-与HTTPS的区别"><a href="#HTTP-与HTTPS的区别" class="headerlink" title="HTTP 与HTTPS的区别"></a>HTTP 与HTTPS的区别</h3><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</li><li>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li><li>HTTPS 由于需要加密以及多次握手，性能方面不如 HTTP</li><li>HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高</li></ul><h3 id="UDP和TCP的区别"><a href="#UDP和TCP的区别" class="headerlink" title="UDP和TCP的区别"></a>UDP和TCP的区别</h3><p>UDP（用户数据包协议）的特点：</p><ul><li>UDP不提供复杂的控制机制，利用ip提供面向无连接的通信服务</li><li>传输途中出现丢包，UDP也不负责重发</li><li>当包到达的顺序出现混乱时，UDP也没有纠正的功能</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li></ul><p>TCP（传输控制协议）的特点：</p><ul><li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li><li>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</li><li>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</li><li>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</li></ul><h3 id="如何理解TCP-IP协议"><a href="#如何理解TCP-IP协议" class="headerlink" title="如何理解TCP/IP协议"></a>如何理解TCP/IP协议</h3><p>TCP/IP，传输控制协议/网际协议，是指能够在多个不同网络实现信息传输的协议簇</p><ul><li><p>TCP</p><p>一种面向连接、可靠、基于字节流的传输层通信协议</p></li><li><p>IP</p><p>用于封包交换数据网络的协议</p></li></ul><p>TCP/IP协议不仅仅指的是<code>TCP</code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的协议簇</p><p>TCP/IP协议族按层次分别了五层体系或者四层体系</p><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层</p><p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层</p><h3 id="DNS协议-是什么？说说DNS-完整的查询过程"><a href="#DNS协议-是什么？说说DNS-完整的查询过程" class="headerlink" title="DNS协议 是什么？说说DNS 完整的查询过程?"></a>DNS协议 是什么？说说DNS 完整的查询过程?</h3><p>DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器</p><p>过程：</p><ul><li><p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p></li><li><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p></li><li><p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p></li><li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询。</p><p>1、本地服务器向根域名服务器发送请求，获取顶级域名的地址给本地服务器</p><p>2、本地服务器根据顶级域名地址发送请求，获取权限域名的地址</p><p>3、根据权限域名地址发送请求，最终得到该域名对应的ip</p></li></ul><ul><li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</li><li>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</li></ul><h3 id="如何理解CDN，说说实现原理？"><a href="#如何理解CDN，说说实现原理？" class="headerlink" title="如何理解CDN，说说实现原理？"></a>如何理解CDN，说说实现原理？</h3><p><code>CDN</code> 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度</p><p><code>CDN</code> 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速</p><p>通过<code>CDN</code>的负载均衡系统，智能调度边缘节点提供服务，相当于<code>CDN</code>服务的大脑，而缓存系统相当于<code>CDN</code>的心脏，缓存命中直接返回给用户，否则回源</p><h3 id="HTTP1-0-1-1-2-0的区别"><a href="#HTTP1-0-1-1-2-0的区别" class="headerlink" title="HTTP1.0/1.1/2.0的区别"></a>HTTP1.0/1.1/2.0的区别</h3><p>HTTP1.0:</p><p>浏览器和服务器只是短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接</p><p>HTTP1.1</p><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li><li>在同一个TCP连接里面，客户端可以同时发送多个请求</li><li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li><li>新增了一些请求方法</li><li>新增了一些请求头和响应头</li></ul><p>HTTP2.0</p><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><h3 id="HTTP常见的状态码有哪些，适用的场景？"><a href="#HTTP常见的状态码有哪些，适用的场景？" class="headerlink" title="HTTP常见的状态码有哪些，适用的场景？"></a>HTTP常见的状态码有哪些，适用的场景？</h3><p>分类：</p><ul><li><p>1 表示消息</p><ul><li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级</li></ul></li><li><p>2 表示成功</p><ul><li>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</li><li>201（已创建）：请求成功并且服务器创建了新的资源</li><li>202（已创建）：服务器已经接收请求，但尚未处理</li><li>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</li><li>204（无内容）：服务器成功处理请求，但没有返回任何内容</li><li>205（重置内容）：服务器成功处理请求，但没有返回任何内容</li><li>206（部分内容）：服务器成功处理了部分请求</li></ul></li></ul><ul><li><p>3 表示重定向</p><ul><li>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</li><li>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</li><li>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul></li><li><p>4 表示请求错误</p><ul><li>400（错误请求）： 服务器不理解请求的语法</li><li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403（禁止）： 服务器拒绝请求</li><li>404（未找到）： 服务器找不到请求的网页</li><li>405（方法禁用）： 禁用请求中指定的方法</li><li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li><li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li><li>408（请求超时）： 服务器等候请求时发生超时</li></ul></li></ul><ul><li><p>5 表示服务器错误</p><ul><li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li><li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li><li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li><li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue相关问题</title>
    <link href="/my-hexo-blog/2022/03/18/vue%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/my-hexo-blog/2022/03/18/vue%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="简述MVVM"><a href="#简述MVVM" class="headerlink" title="简述MVVM"></a>简述MVVM</h3><p>视图模型双向绑定，是Model-View-ViewModel的缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。以前是操作DOM结构更新视图，现在是数据驱动视图。</p><p><strong>MVVM的优点</strong>  </p><ul><li>1、低耦合，视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；</li><li>2、可重用性，你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑</li><li>3、独立开发</li><li>4、可测试</li></ul><h3 id="Vue2-x双向绑定数据绑定"><a href="#Vue2-x双向绑定数据绑定" class="headerlink" title="Vue2.x双向绑定数据绑定"></a>Vue2.x双向绑定数据绑定</h3><p>采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调</p><p>vue的双向绑定是指，数据变化更新视图变化，视图变化更新数据变化。<br>view变化更新Data可以通过事件监听的方式来实现，所以vue的数据双向绑定的工作主要是如何根据data变化更新view<br>主要通过以下4个步骤来实现数据双向绑定：</p><ul><li>1、实现一个监听器Observer：对数据对象进行遍历，包括子属性对象的属性，利用Object.defineProperty()对这个属性都加上setter 和getter。当给对象的某个属性赋值的时候就会触发setter，监听到数据变化（在getter收集依赖，在setter通知依赖更新）</li><li>2、实现一个解析器Complie: 解析Vue模版指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li><li>3、实现一个订阅者Watcher： Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li><li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li></ul><h3 id="谈谈对vue2生命周期的理解？"><a href="#谈谈对vue2生命周期的理解？" class="headerlink" title="谈谈对vue2生命周期的理解？"></a>谈谈对vue2生命周期的理解？</h3><p>每个vue实例在创建的时候会经过一系列的初始化过程，vue的生命周期钩子，就是在达到某个阶段或条件的时候出发的函数，目的是为了完成一些动作或事件。  </p><ul><li>create阶段：vue实例被创建<br>beforeCreate: 创建前，此时data和methods中的数据都还没有初始化<br>created： 创建完毕，data中有值，未挂载  </li><li>mount阶段： vue实例被挂载到真实DOM节点<br>beforeMount：可以发起服务端请求，去数据<br>mounted: 此时可以操作DOM  </li><li>update阶段：当vue实例里面的data数据变化时，触发组件的重新渲染<br>beforeUpdate :更新前<br>updated：更新后  </li><li>destroy阶段：vue实例被销毁<br>beforeDestroy：实例被销毁前，此时可以手动销毁一些方法<br>destroyed:销毁后</li></ul><p><strong>组件生命周期</strong><br>生命周期（父子组件） 父组件beforeCreate –&gt; 父组件created –&gt; 父组件beforeMount –&gt; 子组件beforeCreate –&gt; 子组件created –&gt; 子组件beforeMount –&gt; 子组件 mounted –&gt; 父组件mounted –&gt;父组件beforeUpdate –&gt;子组件beforeDestroy–&gt; 子组件destroyed –&gt; 父组件updated</p><h3 id="computed与watch"><a href="#computed与watch" class="headerlink" title="computed与watch"></a>computed与watch</h3><p>能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p><ul><li>watch属性监听: 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</li><li>computed计算属性： 属性的结果会被缓存，当computed中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 computed中的函数必须用return返回最终的结果 computed更高效，优先使用。data 不改变，computed 不更新。<br>使用场景 computed：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 watch：当一条数据影响多条数据的时候使用，例：搜索数据  </li></ul><h3 id="组件中的data为什么是一个函数？"><a href="#组件中的data为什么是一个函数？" class="headerlink" title="组件中的data为什么是一个函数？"></a>组件中的data为什么是一个函数？</h3><p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 2.如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</p><h3 id="为什么v-for和v-if不建议用在一起"><a href="#为什么v-for和v-if不建议用在一起" class="headerlink" title="为什么v-for和v-if不建议用在一起"></a>为什么v-for和v-if不建议用在一起</h3><p>当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费，建议使用computed，先对数据进行过滤。<br>3.x 版本中 v-if 总是优先于 v-for 生效  </p><h3 id="React-Vue-项目中-key-的作用"><a href="#React-Vue-项目中-key-的作用" class="headerlink" title="React/Vue 项目中 key 的作用"></a>React/Vue 项目中 key 的作用</h3><ul><li>key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM;</li><li>为了在数据变化时强制更新组件，以避免“就地复用”带来的副作用<br>当 Vue.js 用 v-for 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误  </li></ul><h3 id="vue组件的通信方式"><a href="#vue组件的通信方式" class="headerlink" title="vue组件的通信方式"></a>vue组件的通信方式</h3><ul><li>props/$emit 父子组件之间通信</li><li>provide/inject 父-&gt;子孙组件之间</li><li>ref/refs，获取子组件实例，并调用其方法和访问数据</li><li>eventBus ,又称为事件总线,在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。 缺点：难以维护。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// event-bus.js</span><br> <br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> EventBus = <span class="hljs-keyword">new</span> Vue()<br></code></pre></td></tr></table></figure><p>导出EventBus,通过$emit发送事件，通过$on接收事件，通过$off移除事件监听者  </p><ul><li>Vuex:  Vue.js 应用程序开发的状态管理模式(state、getters、mutations、actions、mudules)</li><li>$attrs与 $listeners ,父-&gt;子，如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false， $listeners绑定父组件的所有事件<br><strong>总结</strong><br>常见使用场景可以分为三类：</li><li>父子通信： 父向子传递数据是通过 props，子向父是通过 events（ $emit）；通过父链 / 子链也可以通信（ $parent / $children）；ref 也可以访问组件实例; provide/inject、$attrs/$listeners</li><li>兄弟通讯： eventBus； VueX</li><li>跨级通讯：eventBus、VueX、provide/inject、$attrs/$listeners</li></ul><h3 id="nextTick的实现"><a href="#nextTick的实现" class="headerlink" title="nextTick的实现"></a>nextTick的实现</h3><ul><li>nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM</li><li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li><li>我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。<br><strong>nextTick的实现原理是什么？</strong><br>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</li></ul><h3 id="匿名插槽、具名插槽、作用域插槽"><a href="#匿名插槽、具名插槽、作用域插槽" class="headerlink" title="匿名插槽、具名插槽、作用域插槽"></a>匿名插槽、具名插槽、作用域插槽</h3><p>子组件：<br><slot></slot>(匿名插槽)<br><slot name="header"></slot>(具名插槽)<br><slot nmae="header" :value="value"></slot>(作用域插槽)  </p><p>父之间:<br>旧版本：  </p><p><template slot="header" slot-scope="scope"></template>  </p><p>新版本：  </p><p><template v-slot:header="scope"></template>  </p><h3 id="keep-alive的实现"><a href="#keep-alive的实现" class="headerlink" title="keep-alive的实现"></a>keep-alive的实现</h3><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染<br>Vue.js内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。  </p><h3 id="mixin（混入）"><a href="#mixin（混入）" class="headerlink" title="mixin（混入）"></a>mixin（混入）</h3><p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin<br>多个组件有相同的逻辑，抽离出来<br>mixin并不是完美的解决方案，会有一些问题<br>vue3提出的Composition API旨在解决这些问题<br>劣势：<br>1.变量来源不明确，不利于阅读<br>2.多mixin可能会造成命名冲突<br>3.mixin和组件可能出现多对多的关系，使得项目复杂度变高  </p><h3 id="vue3-0-中为什么要使用-Proxy，它相比以前的实现方式有什么改进"><a href="#vue3-0-中为什么要使用-Proxy，它相比以前的实现方式有什么改进" class="headerlink" title="vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进"></a>vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进</h3><p>1、在vue2.x中通过Object.defineProperty为每个对象添加getter、setter方法来监听数据的变化，vue3.x通过Proxy代理目标对象，且一开始只代理最外层，嵌套对象惰性监听（lazy by default），性能更好。</p><p>2、支持数组索引修改，对象属性的增加、删除</p><h3 id="vue-数组中-key-的作用是什么"><a href="#vue-数组中-key-的作用是什么" class="headerlink" title="vue 数组中 key 的作用是什么"></a>vue 数组中 key 的作用是什么</h3><p>diff算法需求对比虚拟dom的修改，然后异步的渲染到页面中，当出现大量的相同标签的时候，vnode会首先判断key和标签名是否一致，如果一致再判断子节点一致，使用key可以帮助diff算法提升判断的速度，在页面重新渲染时更快、消耗更少。</p><h3 id="vue-中-v-if-和-v-show-的区别是什么"><a href="#vue-中-v-if-和-v-show-的区别是什么" class="headerlink" title="vue 中 v-if 和 v-show 的区别是什么"></a>vue 中 v-if 和 v-show 的区别是什么</h3><p>v-show 总是会进行编译和渲染的工作 - 它只是简单的在元素上添加了 <code>display: none;</code> 的样式。v-show 具有较高的初始化性能成本上的消耗，但是使得转换状态变得很容易。 相比之下，v-if 才是真正「有条件」的：它的加载是惰性的，因此，若它的初始条件是 false，它就不会做任何事情。这对于初始加载时间来说是有益的，当条件为 true 时，v-if 才会编译并渲染其内容。切换 v-if 下的块儿内容实际上时销毁了其内部的所有元素，比如说处于 v-if 下的组件实际上在切换状态时会被销毁并重新生成，因此，切换一个较大 v-if 块儿时会比 v-show 消耗的性能多。</p><h3 id="vue中computed的原理是什么"><a href="#vue中computed的原理是什么" class="headerlink" title="vue中computed的原理是什么"></a>vue中computed的原理是什么</h3><p>computed的实现是基于响应式原理中Watcher对象的实现，在初始化data和computed的时候会涉及到以下几个对象：1、Observer对象（现在数据监听）、2、Dep对象（收集依赖，触发watcher数据更新）3、Watcher对象（执行更新函数，更新依赖变化）。</p><p>computed有两种定义方式，一种是方法、一种是get和set属性，其内部监听的对象必须是已经定义响应式的属性。</p><p>vue在创建computed属性的时候，会循环所有的计算属性，每个计算属性都会创建一个watch，通过defineProperty定义监听，在get中收集依赖，在set中重新执行计算方法，computed是懒执行，在第一次初始化后，不会执行计算，下一次变更时在set中执行计算。</p><h3 id="vue-loader-的实现原理是什么"><a href="#vue-loader-的实现原理是什么" class="headerlink" title="vue-loader 的实现原理是什么"></a>vue-loader 的实现原理是什么</h3><p>vue-loader会把sfc（单文件组件规范）中的内容拆分为template、script、style三个虚拟模块，然后分别匹配webpack配置中的对应rules，比如script模块会匹配所有跟处理javascript和typescript相关的loader。</p><p>template中的内容会通过vue compiler转换为render函数合并到script虚拟模块中。</p><p>scoped style会经过vue-loader/style-post-loader的处理，成为只匹配特定元素的私有样式。</p><h3 id="vue实现一个messageAPI"><a href="#vue实现一个messageAPI" class="headerlink" title="vue实现一个messageAPI"></a>vue实现一个messageAPI</h3><p>可以先写好一个 render 函数，作用是把某一 HTML 片段挂载到 #root 下 / 从 #root 删除该片段。然后写一个 Vue 插件，就是一个暴露了包含 install 方法的模块，install 方法中将 设置 Vue.prototype.$message = message 对象。最后使用 Vue.use 全局注册这个插件即可。</p><h3 id="如果使用-SSR，可以在-created-componentWillMount-中访问-localStorage-吗"><a href="#如果使用-SSR，可以在-created-componentWillMount-中访问-localStorage-吗" class="headerlink" title="如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗"></a>如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗</h3><p>不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错</p><h3 id="在-vue-中数组是否可以以在数组中的次序为-key"><a href="#在-vue-中数组是否可以以在数组中的次序为-key" class="headerlink" title="在 vue 中数组是否可以以在数组中的次序为 key"></a>在 vue 中数组是否可以以在数组中的次序为 key</h3><p>不可，key 应为唯一标识，在数组变更时插入或删除后，index 无法确保始终指向对应的序列</p><h3 id="vue中的router实现原理"><a href="#vue中的router实现原理" class="headerlink" title="vue中的router实现原理"></a>vue中的router实现原理</h3><p>前端路由实现的本质是监听url的变化，实现方式有2种，Hash模式和History模式，无需刷新页面就能重新加载相应的页面。通过location.hash 跳转路由，通过hashchange监听路由变化。History url 通过history.pushState 和 history.replaceState改变url，通过popstate 事件监听路由变化。</p><p>两种模式的区别：</p><ul><li>hash 只能改变#后的值，而history模式可以随意设置同源url</li><li>hash 只能添加字符串类的数据，而history可以通过API添加多种类型的数据</li><li>hash 的历史记录只显示之前的<code>www.a.com</code>而不会显示 hash 值，而 history 的每条记录都会进入到历史记录；</li><li>hash 无需后端配置且兼容性好，而 history 需要配置<code>index.html</code>用于匹配不到资源的情况。</li></ul><h3 id="vue实例挂载的过程中发生了什么？"><a href="#vue实例挂载的过程中发生了什么？" class="headerlink" title="vue实例挂载的过程中发生了什么？"></a>vue实例挂载的过程中发生了什么？</h3><p>1、new Vue 的时候调用了_init方法</p><ul><li>定义$set、$get、$delete、$watch 等方法</li><li>定义$on $off $emit 等事件</li><li>定义_update $forceUpdate $destory 生命周期</li></ul><p>2、调用$mount 进行页面的挂载，挂载的时候主要通过mountComponent方法</p><p>3、定义updateComponent更新函数</p><p>4、执行render函数生成虚拟dom</p><p>5、_update将虚拟dom生成真实dom结构，渲染到页面中</p><h3 id="在created和mounted这两个生命周期中请求数据有什么区别呢？"><a href="#在created和mounted这两个生命周期中请求数据有什么区别呢？" class="headerlink" title="在created和mounted这两个生命周期中请求数据有什么区别呢？"></a>在created和mounted这两个生命周期中请求数据有什么区别呢？</h3><p>created后vue实力化完成，可以获取到属性和方法等，无法获取dom，而在mounted的时候dom已经挂载了，因此可以获取到dom，如果在mounted请求数据，页面可能会闪动一下。放在created中则不会。</p><h3 id="SPA首屏加载速度慢的怎么解决？"><a href="#SPA首屏加载速度慢的怎么解决？" class="headerlink" title="SPA首屏加载速度慢的怎么解决？"></a>SPA首屏加载速度慢的怎么解决？</h3><ul><li><p>减少入口文件体积（路由懒加载）</p></li><li><p>静态资源本地缓存</p><p>后端返回资源：</p><p>1、采用HTTP缓存，强缓存：Cache-Control, 协商缓存：Last-Modified, Etag</p><p>2、Service Worker离线缓存</p><p>客户端合理运用localStorage</p></li><li><p>UI框架按需加载</p></li><li><p>图片资源的压缩（压缩图片，使用icon，精灵图）</p></li><li><p>组件重复打包（在<code>webpack</code>的<code>config</code>文件中，修改<code>CommonsChunkPlugin</code>的配置）</p></li><li><p>开启GZip压缩</p><p>1、安装<code>compression-webpack-plugin</code>，在<code>vue.congig.js</code>中引入并修改<code>webpack</code>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CompressionPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'compression-webpack-plugin'</span>)<br><br>configureWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) &#123;<br>            <span class="hljs-comment">// 为生产环境修改配置...</span><br>            config.mode = <span class="hljs-string">'production'</span><br>            <span class="hljs-keyword">return</span> &#123;<br>                plugins: [<span class="hljs-keyword">new</span> CompressionPlugin(&#123;<br>                    test: <span class="hljs-regexp">/\.js$|\.html$|\.css/</span>, <span class="hljs-comment">//匹配文件名</span><br>                    threshold: <span class="hljs-number">10240</span>, <span class="hljs-comment">//对超过10k的数据进行压缩</span><br>                    deleteOriginalAssets: <span class="hljs-literal">false</span> <span class="hljs-comment">//是否删除原文件</span><br>                &#125;)]<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>2、服务端设置</p></li><li><p>使用SSR</p></li></ul><p>Nuxt.js</p><p>小结：减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化</p><h3 id="为什么组件data属性是一个函数而不是一个对象？"><a href="#为什么组件data属性是一个函数而不是一个对象？" class="headerlink" title="为什么组件data属性是一个函数而不是一个对象？"></a>为什么组件data属性是一个函数而不是一个对象？</h3><ul><li>根实例对象<code>data</code>可以是对象也可以是函数（根实例是单例），不会产生数据污染情况</li><li>组件实例对象<code>data</code>必须为函数，目的是为了防止多个组件实例对象之间共用一个<code>data</code>，产生数据污染。采用函数的形式，<code>initData</code>时会将其作为工厂函数都会返回全新<code>data</code>对象</li></ul><h3 id="Vue中给对象添加新的属性，界面不刷新？"><a href="#Vue中给对象添加新的属性，界面不刷新？" class="headerlink" title="Vue中给对象添加新的属性，界面不刷新？"></a>Vue中给对象添加新的属性，界面不刷新？</h3><p>因为新加的属性不是响应式的数据</p><ul><li>如果为对象添加少量的新属性，可以直接采用<code>Vue.set()</code></li><li>如果需要为新对象添加大量的新属性，则通过<code>Object.assign()</code>创建新对象</li><li>如果你实在不知道怎么操作时，可采取<code>$forceUpdate()</code>进行强制刷新 (不建议)</li></ul><p><code>vue3</code>是用过<code>proxy</code>实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p><h3 id="Vue组件与插件的区别"><a href="#Vue组件与插件的区别" class="headerlink" title="Vue组件与插件的区别"></a>Vue组件与插件的区别</h3><p>组件 <code>(Component)</code> 是用来构成你的 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code></p><p>插件 <code>(Plugin)</code> 是用来增强你的技术栈的功能模块，它的目标是 <code>Vue</code> 本身</p><p>简单来说，插件就是指对<code>Vue</code>的功能的增强或补充</p><h3 id="vue的mixin的理解，有什么应用场景"><a href="#vue的mixin的理解，有什么应用场景" class="headerlink" title="vue的mixin的理解，有什么应用场景"></a>vue的mixin的理解，有什么应用场景</h3><ul><li>替换型策略有<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>，就是将新的同名参数替代旧的参数</li><li>合并型策略是<code>data</code>, 通过<code>set</code>方法进行合并和重新赋值</li><li>队列型策略有生命周期函数和<code>watch</code>，原理是将函数存入一个数组，然后正序遍历依次执行</li><li>叠加型有<code>component</code>、<code>directives</code>、<code>filters</code>，通过原型链进行层层的叠加</li></ul><p>不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立</p><p>这时，可以通过<code>Vue</code>的<code>mixin</code>功能将相同或者相似的代码提出来</p><h3 id="Vue-observable你有了解过吗？"><a href="#Vue-observable你有了解过吗？" class="headerlink" title="Vue.observable你有了解过吗？"></a>Vue.observable你有了解过吗？</h3><p><code>Vue.observable</code>，让一个对象变成响应式数据。<code>Vue</code> 内部会用它来处理 <code>data</code> 函数返回的对象</p><p>在 <code>Vue 2.x</code> 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，它和被返回的对象是同一个对象</p><p>在 <code>Vue 3.x</code> 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的</p><p>在非父子组件通信时，可以使用通常的<code>bus</code>或者使用<code>vuex</code>，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，<code>observable</code>就是一个很好的选择</p><h3 id="自定义指令的应用场景"><a href="#自定义指令的应用场景" class="headerlink" title="自定义指令的应用场景"></a>自定义指令的应用场景</h3><p>自定义指令也像组件那样存在钩子函数：</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</li><li><code>update</code>：所在组件的 <code>VNode</code> 更新时调用，但是可能发生在其子 <code>VNode</code> 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</li><li><code>componentUpdated</code>：指令所在组件的 <code>VNode</code> 及其子 <code>VNode</code> 全部更新后调用</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用</li></ul><p>所有的钩子函数的参数都有以下</p><ul><li>el</li><li>binding</li><li>vnode</li><li>oldVnode</li></ul><p>应用场景</p><ul><li>防抖</li><li>图片懒加载</li><li>一键copy功能</li><li>权限校验</li></ul><h3 id="vue-中diff算法的作用"><a href="#vue-中diff算法的作用" class="headerlink" title="vue 中diff算法的作用"></a>vue 中diff算法的作用</h3><p>用于虚拟dom渲染成真实dom的新旧VNode节点比较</p><p>特点：</p><ul><li>比较只会在同层级进行，不会跨层级比较</li><li>在diff比较的过程中，循环从两边向中间比较</li></ul><h3 id="vue项目中有封装过axios吗？主要封装哪方面？"><a href="#vue项目中有封装过axios吗？主要封装哪方面？" class="headerlink" title="vue项目中有封装过axios吗？主要封装哪方面？"></a>vue项目中有封装过axios吗？主要封装哪方面？</h3><p>axios是基于Promise的Http网络请求库</p><p>封装：对超时时间、设置请求头、根据项目环境使用请求地址、错误处理等。</p><p>通过请求拦截器和响应拦截器实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> instance = axios.create(&#123;<br>  baseURL: <span class="hljs-string">`<span class="hljs-subst">$&#123;host&#125;</span>/lightning/api/backend`</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> errorHandle = <span class="hljs-function">(<span class="hljs-params">status, message, url</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (status) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'0001'</span>:<br>      url !== <span class="hljs-string">'/activity/icid'</span> &amp;&amp; store.dispatch(<span class="hljs-string">'logout'</span>)<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">'5301'</span>:<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>      Message.error(message)<br>  &#125;<br>&#125;<br>instance.interceptors.request.use(<br>  config =&gt; &#123;<br>    config.headers.token = localStorage.getItem(<span class="hljs-string">'lightning_auth_ssoToken'</span>) <span class="hljs-comment">// sso token</span><br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  error =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>  &#125;<br>)<br><br>instance.interceptors.response.use(<br>  (response) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> code = response.data.code<br>    <span class="hljs-keyword">if</span> (code === <span class="hljs-string">'0000'</span>) &#123;<br>        Message.success(response.data.message)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">if</span> (code === <span class="hljs-string">'0001'</span>) &#123;<br>        Message.error(response.data.message)<br>       &#125;<br>      errorHandle(code, response.data.message, response.config.url)<br>    &#125;<br>    <span class="hljs-keyword">return</span> response<br>  &#125;,<br>  error =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; response &#125; = error<br>    response<br>      ? errorHandle(response.data.code, response.data.message, response.config.url)<br>      : Message.warning(<span class="hljs-string">'网络连接失败，请稍后重试！'</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>  &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createAPI = <span class="hljs-function">(<span class="hljs-params">url, method, params, config = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (method === <span class="hljs-string">'get'</span>) &#123;<br>    config.params = params<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    config.data = params<br>  &#125;<br>  <span class="hljs-keyword">return</span> instance(&#123;<br>    url,<br>    method,<br>    ...config<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vue的SSR（Nuxt）"><a href="#vue的SSR（Nuxt）" class="headerlink" title="vue的SSR（Nuxt）"></a>vue的SSR（Nuxt）</h3><p>1、Vue SSR 是在SPA上进行改良的服务端渲染</p><p>2、通过Vue SSR渲染的页面，需要在客户端激活才能实现交互</p><p>3、Vue SRR将包含两部分：服务端渲染首屏，包含交互的SPA</p><p>SSR主要解决两个问题：</p><ul><li>1、SEO</li><li>2、首屏呈现渲染</li></ul><h3 id="vue3做了哪些优化？"><a href="#vue3做了哪些优化？" class="headerlink" title="vue3做了哪些优化？"></a>vue3做了哪些优化？</h3><ul><li><p>源码</p><p>1、源码管理（<code>monorepo</code>的方式维护）</p><p>2、TS</p></li><li><p>性能</p><p>1、体积优化（tree-shanking）</p><p>2、编译优化（优化diff算法）</p><p>3、数据劫持优化（Proxy）</p></li><li><p>语法API（Composition API）</p><p>1、优化逻辑组织</p><p>2、优化逻辑复用</p></li></ul><h3 id="vue3性能提升主要通过哪几个方面体现"><a href="#vue3性能提升主要通过哪几个方面体现" class="headerlink" title="vue3性能提升主要通过哪几个方面体现"></a>vue3性能提升主要通过哪几个方面体现</h3><p>1、编译阶段</p><ul><li><p>diff算法的优化</p><p>增加静态标记，在dff的过程中不会比较</p></li><li><p>静态提升</p><p>对不参与更新的元素，会做静态提升，只会被创建一次，在渲染的时直接复用，避免重复创建，优化运行时的内存占用</p></li><li><p>事件监听缓存</p></li><li><p>SSR优化</p><p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p></li></ul><p>2、源码体积</p><p>移除了不常用的一些API，使用Tree-shanking,把没有用到的模块摇掉，打包的整体体积变小。</p><p>3、响应式系统</p><p>采用Proxy重写了响应式系统，因为Proxy可以对整个对象进行监听，所以不需要深度遍历。</p><h3 id="为什么要用Proxy-API代替defineProperty-API"><a href="#为什么要用Proxy-API代替defineProperty-API" class="headerlink" title="为什么要用Proxy API代替defineProperty API"></a>为什么要用Proxy API代替defineProperty API</h3><p>Object.defineProperty需要遍历属性进行监听，如果嵌套对象，需要深层监听，造成性能问题，不能监听对象属性的添加和删除，不能监听数组的变化（vue2通过重写数组方法实现监听）。</p><p>Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的，可以监听数据的变化，但它不兼容ie</p>]]></content>
    
    
    <categories>
      
      <category>框架原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack相关</title>
    <link href="/my-hexo-blog/2022/02/17/webpack%E7%9B%B8%E5%85%B3/"/>
    <url>/my-hexo-blog/2022/02/17/webpack%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="webpack的理解，解决了什么问题？"><a href="#webpack的理解，解决了什么问题？" class="headerlink" title="webpack的理解，解决了什么问题？"></a>webpack的理解，解决了什么问题？</h3><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p><p>webpack可以解决一下几个问题：</p><ul><li>需要通过模块化的方式来开发</li><li>使用一些高级特性来提高开发效率，比如通过ES6+、TS开发脚本逻辑，scss、less等CSS扩展语言来编写css</li><li>监听文件的变化来并且反映到浏览器上，提高开发的效率（热更新）</li><li>开发完毕后需要对代码进行压缩、合并以及其他相关优化</li></ul><h3 id="webpack的构建流程"><a href="#webpack的构建流程" class="headerlink" title="webpack的构建流程"></a>webpack的构建流程</h3><p>webpack的运行流程是个串行的过程，它的工作流程就是将各个插件串联起来</p><p>从启动到结束会依次执行一下三个步骤：</p><ul><li><p>初始化流程：从配置文件或shell语句中读取或合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</p></li><li><p>编辑构建流程：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理</p><p>初始化后会调用Compiler的run来真正启动webpack编译构建流程：</p><ul><li>complie 开始编译（构建一个compilation 对象，执行模块创建、依赖收集、分块、打包等主要任务）</li><li>make 从入口点文件分析模块及其依赖的模块，创建这些模块对象</li><li>build-module 构建模块（调用配置的loaders，模块转换完后，使用acorn解析输出AST树）</li><li>seal 封装构建结果</li><li>emit 把各个chunk输出到结果文件</li></ul></li><li><p>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</p></li></ul><h3 id="webpack-中常见的Loader"><a href="#webpack-中常见的Loader" class="headerlink" title="webpack 中常见的Loader"></a>webpack 中常见的Loader</h3><p>loader用于对模块的源码进行转换，在import或者加载模块时预处理文件。</p><p>像一些css、sass、png等文件，webpack则无能为力，这个时候就需要配置对应的loader进行文件内容的解析</p><p>配置loader的三种方式：</p><ul><li><p>配置方式（推荐），在webpack.config.js中指定loader</p><p>在module.rules属性中配置，rules是一个数组，所以可以配置多个loader，每个配置是一个对象，test属性表示匹配规则，一般是正则表达式，use属性来调用对应的loader</p></li><li><p>内联方式：在每个import语句中显式指定loader</p></li><li><p>cli方式：在shell命令中指定它们</p></li></ul><p>特性：</p><ul><li>loader可以同步也可以异步</li><li>loader运行在node.js中，并且可以执行任何操作</li><li>除了常见的通过 <code>package.json</code> 的 <code>main</code> 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 <code>loader</code> 字段直接引用一个模块</li><li>插件(plugin)可以为 loader 带来更多特性</li><li>loader 能够产生额外的任意文件</li></ul><p>常见的loader：</p><ul><li><p>css-loader</p><p>分析css模块之间的关系，合并成一个css。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save-dev css-loader <span class="hljs-comment">// sh</span><br><br>rules: [<br>  ...,<br> &#123;<br>  test: <span class="hljs-regexp">/\.css$/</span>,<br>    use: &#123;<br>      loader: <span class="hljs-string">"css-loader"</span>,<br>      options: &#123;<br>     <span class="hljs-comment">// 启用/禁用 url() 处理</span><br>     url: <span class="hljs-literal">true</span>,<br>     <span class="hljs-comment">// 启用/禁用 @import 处理</span><br>     <span class="hljs-keyword">import</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// 启用/禁用 Sourcemap</span><br>        sourceMap: <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br> &#125;<br>]<br></code></pre></td></tr></table></figure><p>如果只通过css-loader加载文件，这时候页面代码设置的样式并没有生效。</p><p>原因在于，<code>css-loader</code>只是负责将<code>.css</code>文件进行一个解析，而并不会将解析后的<code>css</code>插入到页面中</p><p>如果我们希望再完成插入<code>style</code>的操作，那么我们还需要另外一个<code>loader</code>，就是<code>style-loader</code></p></li><li><p>style-loader</p><p>把css-loader生成的内容，用style标签挂载到页面的head中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save-dev style-loader <span class="hljs-comment">// sh</span><br><br>rules: [<br>  ...,<br> &#123;<br>  test: <span class="hljs-regexp">/\.css$/</span>,<br>    use: [<span class="hljs-string">"style-loader"</span>, <span class="hljs-string">"css-loader"</span>]<br> &#125;<br>]<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>less-loader/sass-loader</p><p>开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高</p></li><li><p>raw-loader</p><p>在 <code>webpack</code>中通过 <code>import</code>方式导入文件内容，该<code>loader</code>并不是内置的，所以首先要安装</p></li><li><p>file-loader</p><p>把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save-dev file-loader <span class="hljs-comment">// sh</span><br><br><br>rules: [<br>  ...,<br> &#123;<br>  test: <span class="hljs-regexp">/\.(png|jpe?g|gif)$/</span>,<br>    use: &#123;<br>      loader: <span class="hljs-string">"file-loader"</span>,<br>      options: &#123;<br>        <span class="hljs-comment">// placeholder 占位符 [name] 源资源模块的名称</span><br>        <span class="hljs-comment">// [ext] 源资源模块的后缀</span><br>        name: <span class="hljs-string">"[name]_[hash].[ext]"</span>,<br>        <span class="hljs-comment">//打包后的存放位置</span><br>        outputPath: <span class="hljs-string">"./images"</span>,<br>        <span class="hljs-comment">// 打包后文件的 url</span><br>        publicPath: <span class="hljs-string">'./images'</span>,<br>      &#125;<br>    &#125;<br> &#125;<br>]<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>url-loader</p><p>可以处理理 <code>file-loader</code> 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save-dev url-loader <span class="hljs-comment">// sh</span><br><br>rules: [<br>  ...,<br> &#123;<br>  test: <span class="hljs-regexp">/\.(png|jpe?g|gif)$/</span>,<br>    use: &#123;<br>      loader: <span class="hljs-string">"url-loader"</span>,<br>      options: &#123;<br>        <span class="hljs-comment">// placeholder 占位符 [name] 源资源模块的名称</span><br>        <span class="hljs-comment">// [ext] 源资源模块的后缀</span><br>        name: <span class="hljs-string">"[name]_[hash].[ext]"</span>,<br>        <span class="hljs-comment">//打包后的存放位置</span><br>        outputPath: <span class="hljs-string">"./images"</span><br>        <span class="hljs-comment">// 打包后文件的 url</span><br>        publicPath: <span class="hljs-string">'./images'</span>,<br>        <span class="hljs-comment">// 小于 100 字节转成 base64 格式</span><br>        limit: <span class="hljs-number">100</span><br>      &#125;<br>    &#125;<br> &#125;<br>]<br></code></pre></td></tr></table></figure></li></ul><h3 id="webpack-中常见的plugin-解决了什么问题？"><a href="#webpack-中常见的plugin-解决了什么问题？" class="headerlink" title="webpack 中常见的plugin, 解决了什么问题？"></a>webpack 中常见的plugin, 解决了什么问题？</h3><p><code>plugin</code>赋予其各种灵活的功能，运行在 <code>webpack</code> 的不同阶段（钩子 / 生命周期），贯穿了<code>webpack</code>整个编译周期，目的在于解决<code>loader</code> 无法实现的其他事</p><p>特性：</p><p>本质是一个具有apply方法的js对象，apply方法会被webpack compiler调用，并且在整个编译生命周期都可以访问到compiler对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pluginName = <span class="hljs-string">'ConsoleLogOnBuildWebpackPlugin'</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;<br>  apply(compiler) &#123;<br>    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'webpack 构建过程开始！'</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = ConsoleLogOnBuildWebpackPlugin;<br></code></pre></td></tr></table></figure><p>编译生命周期钩子,如下：</p><ul><li>entry-option: 初始化option</li><li>run</li><li>compile: 真正开始编译，在创建compilation对象之前</li><li>Compilation：生成了compilation对象</li><li>make：从entry开始递归分析依赖，准备对每个模块进行build</li><li>after-compile: 编译build过程结束</li><li>emit: 在将内存中 assets 内容写到磁盘文件夹之前</li><li>after-emit: 在将内存中 assets 内容写到磁盘文件夹之后</li><li>done:  完成所有的编译过程</li><li>failed：编译失败的时候</li></ul><p>常见的plugin</p><ul><li><p>html-webpack-plugin</p><p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br> ...<br>  plugins: [<br>     <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>       title: <span class="hljs-string">"My App"</span>,<br>       filename: <span class="hljs-string">"app.html"</span>,<br>       template: <span class="hljs-string">"./src/html/index.html"</span><br>     &#125;) <br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>clean-webpack-plugin（删除（清理）构建目录）</p></li><li><p>mini-css-extract-plugin（提取css到一个独立的文件中）</p></li><li><p>DefinePlugin</p><p>允许在编译时创建配置的全局对象，是一个<code>webpack</code>内置的插件，不需要安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; DefinePlugun &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br> ...<br>    plugins:[<br>        <span class="hljs-keyword">new</span> DefinePlugin(&#123;<br>            BASE_URL:<span class="hljs-string">'"./"'</span><br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候编译<code>template</code>模块的时候，就能通过下述形式获取全局对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"&lt;%= BASE_URL%&gt;favicon.ico&gt;"</span></span><br></code></pre></td></tr></table></figure></li><li><p>copy-webpack-plugin</p><p>复制文件或目录到执行区域，如<code>vue</code>的打包过程中，如果我们将一些文件放到<code>public</code>的目录下，那么这个目录会被复制到<code>dist</code>文件夹中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> CopyWebpackPlugin(&#123;<br>    parrerns:[<br>        &#123;<br>            <span class="hljs-keyword">from</span>:<span class="hljs-string">"public"</span>,<br>            globOptions:&#123;<br>                ignore:[<br>                    <span class="hljs-string">'**/index.html'</span><br>                ]<br>            &#125;<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>复制的规则在<code>patterns</code>属性中设置：</p><ul><li><p>from：设置从哪一个源中开始复制</p></li><li><p>to：复制到的位置，可以省略，会默认复制到打包的目录下</p></li><li><p>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件</p></li></ul></li></ul><h3 id="说说Loader和plugin的区别？编写Loader和plugin的思路？"><a href="#说说Loader和plugin的区别？编写Loader和plugin的思路？" class="headerlink" title="说说Loader和plugin的区别？编写Loader和plugin的思路？"></a>说说Loader和plugin的区别？编写Loader和plugin的思路？</h3><p>概念：</p><ul><li>loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</li><li>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事</li></ul><p>运行时机的区别：</p><ul><li>loader是运行在打包文件之前</li><li>plugin在整个编译周期都起作用</li></ul><p>在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果。</p><p>对于loader实质是一个转化器，将A文件进行编译转化为B文件，操作的是文件。</p><p>编写loader：</p><p>loader本质是一个函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数，</p><p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容，函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息，函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导出一个函数，source为webpack传递给loader的文件源内容</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> content = doSomeThing2JsString(source);<br>    <br>    <span class="hljs-comment">// 如果 loader 配置了 options 对象，那么this.query将指向 options</span><br>    <span class="hljs-keyword">const</span> options = <span class="hljs-keyword">this</span>.query;<br>    <br>    <span class="hljs-comment">// 可以用作解析其他模块路径的上下文</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this.context'</span>);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * this.callback 参数：</span><br><span class="hljs-comment">     * error：Error | null，当 loader 出错时向外抛出一个 error</span><br><span class="hljs-comment">     * content：String | Buffer，经过 loader 编译后需要导出的内容</span><br><span class="hljs-comment">     * sourceMap：为方便调试生成的编译后内容的 source map</span><br><span class="hljs-comment">     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">this</span>.callback(<span class="hljs-literal">null</span>, content); <span class="hljs-comment">// 异步</span><br>    <span class="hljs-keyword">return</span> content; <span class="hljs-comment">// 同步</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p><p>编写plugin：</p><p>由于webpack基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p><p><code>webpack</code>编译会创建两个核心对象：</p><ul><li><p>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</p></li><li><p>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</p><p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p><ul><li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li><li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li><li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPlugin</span> </span>&#123;<br>    <span class="hljs-comment">// Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span><br>  apply (compiler) &#123;<br>    <span class="hljs-comment">// 找到合适的事件钩子，实现自己的插件功能</span><br>    compiler.hooks.emit.tap(<span class="hljs-string">'MyPlugin'</span>, compilation =&gt; &#123;<br>        <span class="hljs-comment">// compilation: 当前打包构建流程的上下文</span><br>        <span class="hljs-built_in">console</span>.log(compilation);<br>        <br>        <span class="hljs-comment">// do something...</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p><h3 id="webpack的热更新是如何做到的？"><a href="#webpack的热更新是如何做到的？" class="headerlink" title="webpack的热更新是如何做到的？"></a>webpack的热更新是如何做到的？</h3><p>总结：</p><ul><li>通过webpack-dev-server创建两个服务器：提供静态资源服务（express）和Socket服务</li><li>express server 负责直接提供静态资源服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server是一个websocket的长链接，可双向进行通信</li><li>当socket server 监听到对应模块发生变化时，会生产两个文件，.json(manifest) 、.js文件（update chunk）</li><li>通过长链接，socket server可直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul><h3 id="webpack-proxy-的工作原理，为什么能解决跨域？"><a href="#webpack-proxy-的工作原理，为什么能解决跨域？" class="headerlink" title="webpack proxy 的工作原理，为什么能解决跨域？"></a>webpack proxy 的工作原理，为什么能解决跨域？</h3><p>Webpack proxy 是webpack提供的代理服务，可接收客户端请求进行转发到对应的服务器，解决前端开发模式下跨域的问题</p><p>通过服务器工具webpack-dev-server实现，<strong>只适用在开发阶段</strong></p><p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ./webpack.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">// ...</span><br>    devServer: &#123;<br>        contentBase: path.join(__dirname, <span class="hljs-string">'dist'</span>),<br>        compress: <span class="hljs-literal">true</span>,<br>        port: <span class="hljs-number">9000</span>,<br>        proxy: &#123;<br>            <span class="hljs-string">'/api'</span>: &#123;<br>                target: <span class="hljs-string">'https://api.github.com'</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p><p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code>/api</code>，值为对应的代理匹配规则，对应如下：</p><p>pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite</p><ul><li>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false</li><li>changeOrigin：它表示是否更新代理后请求的 headers 中host地址</li></ul><p>工作原理：</p><p>proxy的工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器</p><p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http-proxy-middleware'</span>)<br><span class="hljs-keyword">const</span> app = express()<br>app.use(<span class="hljs-string">'api'</span>, proxy(&#123; <span class="hljs-attr">target</span>: <span class="hljs-string">'http://www.example.org'</span>, <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span> &#125;))<br>app.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>跨域：</p><p>本地开发时候，通过webpack-dev-server启动了一个服务独立运行在localhost的一个端口上，而后端又是运行在另外一台服务器中，由于浏览器的同源策略的原因，因此本地访问会出现跨域的问题。</p><p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p><p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。</p><p><strong>服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</strong></p><h3 id="如何借助webpack来优化前端性能？"><a href="#如何借助webpack来优化前端性能？" class="headerlink" title="如何借助webpack来优化前端性能？"></a>如何借助webpack来优化前端性能？</h3><p>手段：</p><ul><li><p>JS代码压缩(terser-webpack-plugin)</p><p><code>terser</code>是一个<code>JavaScript</code>的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让<code>bundle</code>更小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> TerserPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>)<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    optimization: &#123;<br>        minimize: <span class="hljs-literal">true</span>,<br>        minimizer: [<br>            <span class="hljs-keyword">new</span> TerserPlugin(&#123;<br>                parallel: <span class="hljs-literal">true</span> <span class="hljs-comment">// 电脑cpu核数-1</span><br>            &#125;)<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li><li>parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1</li><li>terserOptions：设置我们的terser相关的配置：</li><li>compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true</li><li>mangle：设置丑化相关的选项，可以直接设置为true</li><li>toplevel：底层变量是否进行转换</li><li>keep_classnames：保留类的名称</li><li>keep_fnames：保留函数的名称</li></ul></li></ul><ul><li><p>css代码压缩(css-minimizer-webpack-plugin)</p><p>css压缩通常是去除无用的空格等</p></li><li><p>HTML代码压缩（HtmlWebpackPlugin）</p><p>使用<code>HtmlWebpackPlugin</code>插件来生成<code>HTML</code>的模板时候，通过配置属性<code>minify</code>进行<code>html</code>优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    plugin:[<br>        <span class="hljs-keyword">new</span> HtmlwebpackPlugin(&#123;<br>            ...<br>            minify:&#123;<br>                minifyCSS:<span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否压缩css</span><br>                collapseWhitespace:<span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否折叠空格</span><br>                removeComments:<span class="hljs-literal">true</span> <span class="hljs-comment">// 是否移除注释</span><br>            &#125;<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>文件大小压缩(compression-webpack-plugin)</p><p>对文件的大小进行压缩，减少<code>http</code>传输过程中宽带的损耗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> ComepressionPlugin(&#123;<br>    test:<span class="hljs-regexp">/\.(css|js)$/</span>,  <span class="hljs-comment">// 哪些文件需要压缩</span><br>    threshold:<span class="hljs-number">500</span>, <span class="hljs-comment">// 设置文件多大开始压缩</span><br>    minRatio:<span class="hljs-number">0.7</span>, <span class="hljs-comment">// 至少压缩的比例</span><br>    algorithm:<span class="hljs-string">"gzip"</span>, <span class="hljs-comment">// 采用的压缩算法</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>图片压缩（file-loader、image-webpack-loader）</p><p>一般来说在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要来的大，所以图片压缩较为重要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;<br>  rules: [<br>    &#123;<br>      test: <span class="hljs-regexp">/\.(png|jpg|gif)$/</span>,<br>      use: [<br>        &#123;<br>          loader: <span class="hljs-string">'file-loader'</span>,<br>          options: &#123;<br>            name: <span class="hljs-string">'[name]_[hash].[ext]'</span>,<br>            outputPath: <span class="hljs-string">'images/'</span>,<br>          &#125;<br>        &#125;,<br>        &#123;<br>          loader: <span class="hljs-string">'image-webpack-loader'</span>,<br>          options: &#123;<br>            <span class="hljs-comment">// 压缩 jpeg 的配置</span><br>            mozjpeg: &#123;<br>              progressive: <span class="hljs-literal">true</span>,<br>              quality: <span class="hljs-number">65</span><br>            &#125;,<br>            <span class="hljs-comment">// 使用 imagemin**-optipng 压缩 png，enable: false 为关闭</span><br>            optipng: &#123;<br>              enabled: <span class="hljs-literal">false</span>,<br>            &#125;,<br>            <span class="hljs-comment">// 使用 imagemin-pngquant 压缩 png</span><br>            pngquant: &#123;<br>              quality: <span class="hljs-string">'65-90'</span>,<br>              speed: <span class="hljs-number">4</span><br>            &#125;,<br>            <span class="hljs-comment">// 压缩 gif 的配置</span><br>            gifsicle: &#123;<br>              interlaced: <span class="hljs-literal">false</span>,<br>            &#125;,<br>            <span class="hljs-comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span><br>            webp: &#123;<br>              quality: <span class="hljs-number">75</span><br>            &#125;<br>          &#125;<br>        &#125;<br>      ]<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>tree sharking</p><p><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码，依赖于<code>ES Module</code>的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p><p>两种方案：</p><ul><li>usedExports： 通过标记某些函数是否被使用，之后通过Terser来进行优化的</li><li>sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用</li></ul><p>usedExports:</p><p>配置方法也很简单，只需要将<code>usedExports</code>设为<code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    optimization:&#123;<br>        usedExports<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用之后，没被用上的代码在<code>webpack</code>打包中会加入<code>unused harmony export mul</code>注释，用来告知 <code>Terser</code> 在优化时，可以删除掉这段代码</p><p>sideEffects:</p><p><code>sideEffects</code>用于告知<code>webpack compiler</code>哪些模块时有副作用，配置方法是在<code>package.json</code>中设置<code>sideEffects</code>属性</p><p>如果<code>sideEffects</code>设置为false，就是告知<code>webpack</code>可以安全的删除未用到的<code>exports</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">"sideEffecis"</span>:[<br>    <span class="hljs-string">"./src/util/format.js"</span>,<br>    <span class="hljs-string">"*.css"</span> <span class="hljs-comment">// 所有的css文件</span><br>]<br></code></pre></td></tr></table></figure><p>css tree shaking</p><p><code>css</code>进行<code>tree shaking</code>优化可以安装<code>PurgeCss</code>插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PurgeCssPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'purgecss-webpack-plugin'</span>)<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    plugins:[<br>        <span class="hljs-keyword">new</span> PurgeCssPlugin(&#123;<br>            path:glob.sync(<span class="hljs-string">`<span class="hljs-subst">$&#123;path.resolve(<span class="hljs-string">'./src'</span>)&#125;</span>/**/*`</span>), &#123;<span class="hljs-attr">nodir</span>:<span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// src里面的所有文件</span><br>            satelist:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>                <span class="hljs-keyword">return</span> &#123;<br>                    standard:[<span class="hljs-string">"html"</span>]<br>                &#125;<br>            &#125;<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>paths：表示要检测哪些目录下的内容需要被分析，配合使用glob</li><li>默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性</li></ul></li><li><p>代码分离</p><p>将代码分离到不同的<code>bundle</code>中，之后我们可以按需加载，或者并行加载这些文件</p><p>默认情况下，所有的<code>JavaScript</code>代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p><p>代码分离可以分出出更小的<code>bundle</code>，以及控制资源加载优先级，提供代码的加载性能</p><p>这里通过<code>splitChunksPlugin</code>来实现，该插件<code>webpack</code>已经默认安装和集成，只需要配置即可</p><p>默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">optimization</span>:&#123;<br>       <span class="hljs-attribute">splitChunks</span>:&#123;<br>           chunks:<span class="hljs-string">"all"</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>splitChunks</code>主要属性有如下：</p><ul><li>Chunks，对同步代码还是异步代码进行处理</li><li>minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分</li><li>maxSize： 将大于maxSize的包，拆分为不小于minSize的包</li><li>minChunks：被引入的次数，默认是1</li></ul></li><li><p>内联chunk</p><p>可以通过<code>InlineChunkHtmlPlugin</code>插件将一些<code>chunk</code>的模块内联到<code>html</code>，如<code>runtime</code>的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的</p></li></ul><p>关于<code>webpack</code>对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化</p><h3 id="如何提高webpack的构建速度"><a href="#如何提高webpack的构建速度" class="headerlink" title="如何提高webpack的构建速度"></a>如何提高webpack的构建速度</h3><p>优化手段：</p><ul><li><p>优化 loader 配置</p><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，接触<code>include</code>、<code>exclude</code>规定哪些匹配应用<code>loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        <span class="hljs-comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span><br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span><br>        use: [<span class="hljs-string">'babel-loader?cacheDirectory'</span>],<br>        <span class="hljs-comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span><br>        include: path.resolve(__dirname, <span class="hljs-string">'src'</span>),<br>      &#125;,<br>    ]<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>合理使用 resolve.extensions</p><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入到合适的模块代码</p><p>通过<code>resolve.extensions</code>是解析到文件时自动添加拓展名，默认情况如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    extensions:[<span class="hljs-string">".warm"</span>,<span class="hljs-string">".mjs"</span>,<span class="hljs-string">".js"</span>,<span class="hljs-string">".json"</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找</p><p>当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度</p></li></ul><ul><li><p>优化 resolve.modules</p><p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>[&#39;node_modules&#39;]</code>，所以默认会从<code>node_modules</code>中查找文件 当安装的第三方模块都放在项目根目录下的 <code>./node_modules</code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  resolve: &#123;<br>    <span class="hljs-comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span><br>    <span class="hljs-comment">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span><br>    modules: [path.resolve(__dirname, <span class="hljs-string">'node_modules'</span>)]<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>优化 resolve.alias</p><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p><p>通过配置<code>alias</code>以减少查找过程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    resolve:&#123;<br>        alias:&#123;<br>            <span class="hljs-string">"@"</span>:path.resolve(__dirname,<span class="hljs-string">'./src'</span>)<br>        &#125;<br>    &#125;<br>&#125;<br>#<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>使用 DLLPlugin 插件</p><p><code>DLL</code>全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p><p>使用步骤分成两部分：</p><ul><li>打包一个 DLL 库</li><li>引入 DLL 库</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 打包一个 DLL 库,webpack内置了一个DllPlugin可以帮助我们打包一个DLL的库文件</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    plugins:[<br>        <span class="hljs-keyword">new</span> webpack.DllPlugin(&#123;<br>            name:<span class="hljs-string">'dll_[name]'</span>,<br>            path:path.resolve(__dirname,<span class="hljs-string">"./dll/[name].manifest.json"</span>)<br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 webpack 自带的 DllReferencePlugin 插件对 mainfest.json 映射文件进行分析，获取要使用的DLL库</span><br><span class="hljs-comment">// 然后再通过AddAssetHtmlPlugin插件，将我们打包的DLL库引入到Html模块中</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    ...<br>    <span class="hljs-keyword">new</span> webpack.DllReferencePlugin(&#123;<br>        context:path.resolve(__dirname,<span class="hljs-string">"./dll/dll_react.js"</span>),<br>        mainfest:path.resolve(__dirname,<span class="hljs-string">"./dll/react.mainfest.json"</span>)<br>    &#125;),<br>    <span class="hljs-keyword">new</span> AddAssetHtmlPlugin(&#123;<br>        outputPath:<span class="hljs-string">"./auto"</span>,<br>        filepath:path.resolve(__dirname,<span class="hljs-string">"./dll/dll_react.js"</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 cache-loader</p><p>在一些性能开销较大的 <code>loader</code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度</p><p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code>loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.ext$/</span>,<br>                use: [<span class="hljs-string">'cache-loader'</span>, ...loaders],<br>                include: path.resolve(<span class="hljs-string">'src'</span>),<br>            &#125;,<br>        ],<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>terser 启动多线程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用多进程并行运行来提高构建速度</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  optimization: &#123;<br>    minimizer: [<br>      <span class="hljs-keyword">new</span> TerserPlugin(&#123;<br>        parallel: <span class="hljs-literal">true</span>,<br>      &#125;),<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><ul><li>合理使用 sourceMap(打包生成 <code>sourceMap</code> 的时候，如果信息越详细，打包速度就会越慢)</li></ul><p>总结： 可以看到，优化<code>webpack</code>构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手</p><h3 id="与webpack类似的打包工具有哪些？区别？"><a href="#与webpack类似的打包工具有哪些？区别？" class="headerlink" title="与webpack类似的打包工具有哪些？区别？"></a>与webpack类似的打包工具有哪些？区别？</h3><ul><li><p>Rollup</p><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup</code>要小巧的多</p><p><code>Rollup</code>的优点：</p><ul><li>代码更简洁、效率更高</li><li>默认支持 Tree-shaking</li></ul><p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup</code>需要使用插件去完成</p><p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p><p>但是在用于打包<code>JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p></li><li><p>Parcel</p><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p><p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p><p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p><p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p><p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p></li><li><p>Snowpack</p><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p><p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p></li><li><p>Vite</p><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p><p>它主要由两部分组成：</p><ul><li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 模块热更新HMR</li><li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li></ul><p>其作用类似<code>webpack</code>+ <code>webpack-dev-server</code>，其特点如下：</p><ul><li>快速的冷启动</li><li>即时的模块热更新</li><li>真正的按需编译</li></ul><p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p><p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p><p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Promise及其静态方法</title>
    <link href="/my-hexo-blog/2022/02/16/%E6%89%8B%E5%86%99Promise%E5%8F%8A%E5%85%B6%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <url>/my-hexo-blog/2022/02/16/%E6%89%8B%E5%86%99Promise%E5%8F%8A%E5%85%B6%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><ul><li>1、Promise.resolve最终结果还是一个Promise，并且与Promise.resolve(该值)传入的值息息相关</li><li>2、传入的参数可以是一个Promise实例，那么该函数执行的结果是直接将实例返回</li><li>3、这里最主要需要理解跟随，可以理解成Promise最终状态就是这个thenable对象输出的值</li></ul><p><strong>源码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.myResolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-comment">// 是Promise实例，直接返回即可</span><br>    <span class="hljs-keyword">if</span> (value &amp;&amp; value <span class="hljs-keyword">typeof</span> <span class="hljs-string">'object'</span> &amp;&amp; (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    <span class="hljs-comment">// 否则其他情况一律再通过Promise包装一下 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        resolve(value)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>Promise.reject() 方法返回一个带有拒绝原因的Promise对象。</p><p><strong>源码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.myReject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> &#123;<br>        reject(value)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p><strong>源码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.myAll = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> result = []<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> (promises.length === <span class="hljs-number">0</span>) &#123;<br>            resolve(result)<br>        &#125;<br>        promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span>&#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(item).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                count += <span class="hljs-number">1</span><br>                result[index] = res<br>                <span class="hljs-keyword">if</span> (count === promises.length)&#123;<br>                  resolve(result)<br>                &#125;<br>            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更,一旦发生状态变更，状态总是fulfilled，不会变成rejected</p><ul><li>不管是全部成功还是有部分失败，最终都会进入Promise.allSettled的.then回调中</li></ul><ul><li>最后的返回值中，成功和失败的项都有status属性，成功时值是fulfilled，失败时是rejected</li></ul><ul><li>最后的返回值中，成功含有value属性，而失败则是reason属性  </li></ul><p><strong>源码实现</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vim">Promise.prototype.myAllSettled = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(promises)</span> &#123;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise((<span class="hljs-built_in">resolve</span>, reject) =&gt; &#123;<br>    const result = []<br>    <span class="hljs-keyword">let</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> (promises.length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">resolve</span>(result)<br>    &#125;<br>    promises.forEach((item, <span class="hljs-built_in">index</span>) =&gt; &#123;<br>      Promise.<span class="hljs-built_in">resolve</span>(item).then(<span class="hljs-keyword">res</span> =&gt; &#123;<br>        <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span><br>        result[<span class="hljs-built_in">index</span>] = &#123;<br>          statu<span class="hljs-variable">s:</span> <span class="hljs-string">'fulfilled'</span>,<br>          value: <span class="hljs-keyword">res</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count</span> === promises.length) &#123;<br>          <span class="hljs-built_in">resolve</span>(result)<br>        &#125;<br>      &#125;).<span class="hljs-keyword">catch</span>(err =&gt; &#123;<br>        <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span><br>        result[<span class="hljs-built_in">index</span>] = &#123;<br>          statu<span class="hljs-variable">s:</span> <span class="hljs-string">'rejected'</span>,<br>          reason: err<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count</span> === promises.length) &#123;<br>          <span class="hljs-built_in">resolve</span>(result)<br>        &#125;<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">const</span> p = Promise.race([<span class="hljs-built_in">p1</span>, <span class="hljs-built_in">p2</span>, <span class="hljs-built_in">p3</span>])<br></code></pre></td></tr></table></figure><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。<br><strong>源码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.myRace = <span class="hljs-function">(<span class="hljs-params">promises</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        promises.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(item).then(resolve).catch(reject)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(executor) &#123;<br>        <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'pending'</span><br>        <span class="hljs-keyword">this</span>.value = <span class="hljs-string">'undefined'</span><br>        <span class="hljs-keyword">this</span>.reason = <span class="hljs-string">'undefined'</span><br>        <span class="hljs-keyword">this</span>.onResolvedCallbacks = []<br>        <span class="hljs-keyword">this</span>.onRejectedCallbacks = []<br>        <br>        <span class="hljs-keyword">let</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'fulfilled'</span><br>            <span class="hljs-keyword">this</span>.value = value<br>            <span class="hljs-keyword">this</span>.onResolvedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn())<br>        &#125;<br>        <br>        <span class="hljs-keyword">let</span> reject = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'rejected'</span><br>            <span class="hljs-keyword">this</span>.reason = reason<br>            <span class="hljs-keyword">this</span>.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn())<br>        &#125;<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>           executor(resolve, reject) <br>        &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>            reject(error)<br>        &#125;<br>    &#125;<br>    then(onFulfilled, onRejected) &#123;<br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value<br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> err &#125;<br>        <span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'fulfilled'</span>) &#123;<br>                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value)<br>                        resolve(promise2, x, resolve, reject)<br>                    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                        reject(e)<br>                    &#125;<br>                &#125;, <span class="hljs-number">0</span>)<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'rejected'</span>) &#123;<br>                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-keyword">this</span>.reason)<br>                        resolvePromise(promise2, x, resolve, reject)<br>                    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                        reject(e)<br>                    &#125;<br>                &#125;, <span class="hljs-number">0</span>)<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'pending'</span>) &#123;<br>             <span class="hljs-keyword">this</span>.onResolvedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                 setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value)<br>                        resolvePromise(promise2, x, resolve, reject)<br>                    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                        reject(e)<br>                    &#125;<br>                 &#125;, <span class="hljs-number">0</span>)<br>             &#125;)<br>             <br>             <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                 setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                     <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-keyword">this</span>.reason)<br>                        resolvePromise(promise2,x, resolve, reject)<br>                     &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                         reject(e)<br>                     &#125;<br>                 &#125;, <span class="hljs-number">0</span>)<br>             &#125;)<br>            &#125;<br>        &#125;)<br>        <span class="hljs-keyword">return</span> promise2<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (x === promise2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'chaining cycle detected for promise'</span>)<br>    &#125;<br>    <span class="hljs-keyword">let</span> called<br>    <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'function'</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> then = x.then<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) &#123;<br>                then.call(x, y =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span> <br>                    called = <span class="hljs-literal">true</span><br>                    resolvePromise(promise2, y, resolve, reject)<br>                &#125;, err =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span> <br>                    called = <span class="hljs-literal">true</span><br>                    reject(err)<br>                &#125;)<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>            called = <span class="hljs-literal">true</span><br>            reject(error)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        resolve(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// resolve</span><br><span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        resolve(value)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// reject</span><br><span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> &#123;<br>        reject(value)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// all</span><br><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> result = []<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">let</span> len = promises.length<br>        <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>            resolve([])<br>        &#125;<br>        promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(item).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                count += <span class="hljs-number">1</span><br>                result[index] = res<br>                <span class="hljs-keyword">if</span> (count === len) &#123;<br>                    resolve(result)<br>                &#125;<br>            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// allSettled</span><br><span class="hljs-built_in">Promise</span>.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> result = []<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">let</span> len = promises.length<br>        <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>            resolve([])<br>        &#125;<br>        promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(item).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                count += <span class="hljs-number">1</span><br>                result[index] = &#123;<br>                    status: <span class="hljs-string">'fulfiled'</span>,<br>                    value: res<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len === count) &#123;<br>                    resolve(result)<br>                &#125;<br>            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                count += <span class="hljs-number">1</span><br>                result[index] = &#123;<br>                    status: <span class="hljs-string">'rejected'</span>,<br>                    reason: err<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len === count) &#123;<br>                    resolve(result)<br>                &#125;<br>            &#125;)<br>        &#125;)<br>   &#125;)<br>&#125;<br><br><span class="hljs-comment">// race</span><br><span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        promises.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(item).then(resolve).catch(reject)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>commonJs与ESModule的区别</title>
    <link href="/my-hexo-blog/2021/11/02/commonJs%E4%B8%8EESModule%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/my-hexo-blog/2021/11/02/commonJs%E4%B8%8EESModule%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>学习之前引出几个问题：</p><ul><li>Commonjs 和 Es Module 有什么区别 ？</li><li>Commonjs 如何解决的循环引用问题 ？</li><li>Es Module 如何解决循环引用问题 ？</li><li>exports 和 module.exports 有何不同？</li><li>require 模块查找机制 ？</li><li>import() 的动态引入？</li><li>Es Module 如何改变模块下的私有变量 ？</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>开发很容易存在全局污染和依赖管理混乱问题，所以就需要模块化来解决这两个问题，今天介绍的是前端模块化的两个重要方案，commonjs 和 ESModule</p><h3 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h3><p>commonjs的提出弥补了，前端模块化的空缺，nodejs借鉴了commonjs，实现了模块化管理。</p><p>目前commonjs广泛应用于以下几个场景：</p><ul><li>Node（commonjs在服务端的一个具体代表性实现）</li><li>Browserify（ commonjs 在浏览器中的一种实现）</li><li>wepack 打包工具对 CommonJS 的支持和转换</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>在commonjs中每个js文件就是一个单独的模块，称为module。</li><li>模块中包含commonjs的核心变量：exports、module.exports、require</li><li>exports 和 module.export可以用于导出模块中的内容</li><li>require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>每个模块文件上存在 module，exports，require三个变量，然而这三个变量是没有被定义的，但是我们可以在 Commonjs 规范下每一个 js 模块上直接使用它们</p><ul><li>module 记录当前模块信息。</li><li>require 引入模块的方法。</li><li>exports 当前模块导出的属性</li></ul><p>在编译的过程中，实际 Commonjs 对 js 的代码块进行了首尾包装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exports,require,module,__filename,__dirname</span>)</span>&#123;<br>   <span class="hljs-keyword">const</span> sayName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./hello.js'</span>)<br>    <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            name:sayName(),<br>            author:<span class="hljs-string">'YoLin'</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在 Commonjs 规范下模块中，会形成一个包装函数，我们写的代码将作为包装函数的执行上下文，使用的 require ，exports ，module 本质上是通过形参的方式传递到包装函数中的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">wrapper</span> (script) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'(function (exports, require, module, __filename, __dirname) &#123;'</span> + <br>        script +<br>     <span class="hljs-string">'\n&#125;)'</span><br>&#125;<br></code></pre></td></tr></table></figure><p>包装函数执行</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const modulefunction = <span class="hljs-keyword">wrapper</span>(`<br>  const sayName = require(<span class="hljs-string">'./hello.js'</span>)<br>    module.exports = <span class="hljs-keyword">function</span> say()&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-type">name</span>:sayName(),<br>            author:<span class="hljs-string">'YoLin'</span><br>        &#125;<br>    &#125;<br>`)<br></code></pre></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">runInThisContext(<span class="hljs-name">modulefunction</span>)(<span class="hljs-name">module</span>.exports, require, module, __filename, __dirname)<br></code></pre></td></tr></table></figure><p>在模块加载的时候，会通过 runInThisContext (可以理解成 eval ) 执行 modulefunction ，传入require ，exports ，module 等参数。最终我们写的 nodejs 文件就这么执行了。</p><h4 id="require-文件加载流程"><a href="#require-文件加载流程" class="headerlink" title="require 文件加载流程"></a>require 文件加载流程</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>、<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>) <span class="hljs-comment">// 核心模块</span><br><span class="hljs-number">2</span>、<span class="hljs-keyword">const</span> sayName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./sayName.js'</span>) <span class="hljs-comment">// 文件模块</span><br><span class="hljs-number">3</span>、<span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto-js'</span>) <span class="hljs-comment">// 第三方模块</span><br></code></pre></td></tr></table></figure><p>如上所示：require可以加载核心模块、文件模块、第三方自定义模块。<br>当 require 方法执行的时候，接收的唯一参数作为一个标识符 ，Commonjs 下对不同的标识符，处理流程不同，但是目的相同，都是找到对应的模块。</p><h4 id="require-加载标识符原则"><a href="#require-加载标识符原则" class="headerlink" title="require 加载标识符原则"></a>require 加载标识符原则</h4><p>nodejs中对标识符的处理原则</p><ul><li>对fs、http、path等标识符，会被作为核心模块</li><li>./和../作为相对路径的文件模块，/作为绝对路径的文件模块</li><li>非路径形式也非核心模块的模块，将作为自定义模块</li></ul><p><strong>核心模块的处理：</strong><br>核心模块的优先级仅次于缓存加载，在 Node 源码编译中，已被编译成二进制代码，所以加载核心模块，加载过程中速度最快。</p><p><strong>路径形式的文件模块处理：</strong><br>已 ./ ，../ 和 / 开始的标识符，会被当作文件模块处理。require() 方法会将路径转换成真实路径，并以真实路径作为索引，将编译后的结果缓存起来，第二次加载的时候会更快。</p><p><strong>自定义模块处理：</strong><br>自定义模块，一般指的是非核心的模块，它可能是一个文件或者一个包，它的查找会遵循以下原则：</p><ul><li>在当前目录下的 node_modules 目录查找。</li><li>如果没有，在父级目录的 node_modules 查找，如果没有在父级目录的父级目录的 node_modules 中查找</li><li>沿着路径向上递归，直到根目录下的 node_modules 目录。</li><li>在查找过程中，会找 package.json 下 main 属性指向的文件，如果没有  package.json ，在 node 环境下会以此查找 index.js ，index.json ，index.node。</li></ul><h3 id="require-模块引入与处理"><a href="#require-模块引入与处理" class="headerlink" title="require 模块引入与处理"></a>require 模块引入与处理</h3><p>CommonJS 模块同步加载并执行模块文件，CommonJS 模块在执行阶段分析模块依赖，采用深度优先遍历（depth-first traversal），执行顺序是父 -&gt; 子 -&gt; 父；</p><h4 id="require-加载原理"><a href="#require-加载原理" class="headerlink" title="require 加载原理"></a>require 加载原理</h4><p>过程：</p><ul><li><p>require 会接收一个参数——文件标识符，然后分析定位文件，分析过程我们上述已经讲到了，加下来会从 Module 上查找有没有缓存，如果有缓存，那么直接返回缓存的内容。</p></li><li><p>如果没有缓存，会创建一个 module 对象，缓存到 Module 上，然后执行文件，加载完文件，将 loaded 属性设置为 true ，然后返回 module.exports 对象。借此完成模块加载流程。</p></li><li><p>模块导出就是 return 这个变量的其实跟 a = b 赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址。</p></li><li><p>exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对 exports 进行赋值会导致 exports 操作的不再是 module.exports 的引用。</p></li></ul><h4 id="require-避免重复加载"><a href="#require-避免重复加载" class="headerlink" title="require 避免重复加载"></a>require 避免重复加载</h4><p>加载之后的文件的 module 会被缓存到 Module 上，<br>如果其他模块再次引入，则会直接读取缓存中的，无需再次执行模块</p><h4 id="require-避免循环引用"><a href="#require-避免循环引用" class="headerlink" title="require 避免循环引用"></a>require 避免循环引用</h4>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript知识点</title>
    <link href="/my-hexo-blog/2021/11/02/typescript%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/my-hexo-blog/2021/11/02/typescript%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="TypeScript基础学习"><a href="#TypeScript基础学习" class="headerlink" title="TypeScript基础学习"></a>TypeScript基础学习</h3><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">let</span> age: <span class="hljs-built_in">number</span> = <span class="hljs-number">20</span><br><br><span class="hljs-keyword">let</span> binaryNumber: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b1111</span> <span class="hljs-comment">// 支持二进制或八进制</span><br><br><span class="hljs-keyword">let</span> fistName: <span class="hljs-built_in">string</span> = <span class="hljs-string">'YoLinDeng'</span><br><br><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><br><span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span> = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 说明undefined和null类型是所以类型的子类型</span><br></code></pre></td></tr></table></figure><p><strong>null和undefined的区别</strong><br>null表示“没有对象”，即该处不该有值</p><ul><li>1）作为函数的参数，表示该函数的参数不是对象</li><li>2）作为对象原型链的终点</li></ul><p>undefined表示缺少值，就是此处应该有值，但是还没有定义</p><ul><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ul><h4 id="any类型和联合类型"><a href="#any类型和联合类型" class="headerlink" title="any类型和联合类型"></a>any类型和联合类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> notSure: <span class="hljs-built_in">any</span> = <span class="hljs-number">1</span><span class="hljs-comment">// 有明确类型的时候避免使用any类型，没有代码提示以及校验</span><br><br><span class="hljs-keyword">let</span> numberOrString: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> = <span class="hljs-number">123</span><br>numberOrString = <span class="hljs-string">'abc'</span><br></code></pre></td></tr></table></figure><h4 id="Array-和-Tuple（元组）"><a href="#Array-和-Tuple（元组）" class="headerlink" title="Array 和 Tuple（元组）"></a>Array 和 Tuple（元组）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义数组</span><br><span class="hljs-keyword">let</span> arrOfNumbers: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arr2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 定义元组,限定了一定数据类型的数组</span><br><span class="hljs-keyword">let</span> user: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'YoLinDeng'</span>, <span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><h4 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface(接口)"></a>interface(接口)</h4><ul><li>对对象的形状进行描述</li><li>对类进行抽象</li><li>Duck Typing(鸭子类型)</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml">interface <span class="hljs-title">Person</span> &#123;<br>    readonly <span class="hljs-attribute">id:</span><span class="hljs-string"> number</span>; <span class="hljs-comment">// 只读</span><br>    <span class="hljs-attribute">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: number; <span class="hljs-comment">// 可选</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attribute">yoLin</span>: <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-attribute">id:</span><span class="hljs-string"> 1,</span><br><span class="hljs-string">    name</span>: <span class="hljs-string">'YoLinDeng'</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数和类型推断"><a href="#函数和类型推断" class="headerlink" title="函数和类型推断"></a>函数和类型推断</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> z === <span class="hljs-string">'number'</span>) &#123;<br>        <span class="hljs-keyword">return</span> x + y + z<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y  <br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> z === <span class="hljs-string">'number'</span>) &#123;<br>        <span class="hljs-keyword">return</span> x + y + z<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y  <br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> add2 = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = add<br><br>当我们没有指定类型的时候，ts的complier会给我推断出一个类型<br></code></pre></td></tr></table></figure><h4 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h4><p>类(Class)：定义了一切事物的抽象特点<br>对象（Object）:类的实例<br>面向对象（OOP）:三大特征：封装，继承，多态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  name: string;<br>  <span class="hljs-keyword">constructor</span>(name: string) &#123;<br>    <span class="hljs-keyword">this</span>.name = name<br>  &#125;<br>  run() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span> is running`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> snake = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">'liLy'</span>)<br><span class="hljs-built_in">console</span>.log(snake.run())<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  bark() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span> is barking`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> xiaobao = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">'xiaobao'</span>)<br><span class="hljs-built_in">console</span>.log(xiaobao.run())<br><span class="hljs-built_in">console</span>.log(xiaobao.bark())<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(name) &#123;<br>    <span class="hljs-keyword">super</span>(name)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>  &#125;<br>  run() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Meow,<span class="hljs-subst">$&#123;<span class="hljs-keyword">super</span>.run()&#125;</span>`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> maomao = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">'maomao'</span>)<br><span class="hljs-built_in">console</span>.log(maomao.run())<br></code></pre></td></tr></table></figure><p>修饰符：public（公有的）、private（私有的）、<br>protected(只有自己和子类可以访问)、readonly（只读）、static（静态，不需要实例化，可以在类上直接调用）</p><p><strong>类和接口</strong>：<br>使用interface和implements抽象和验证类的属性和方法，对类的一部分内容进行抽象。<br>将特性提取成接口，使用implements来实现,像一种契约，定义和约束object的样子。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Radio</span> &#123;<br>  switchRadio(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Battery</span> &#123;<br>  checkBatteryStatus(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">RadioWithBattery</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Radio</span> &#123;<br>  checkBatteryStatus(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Car</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">RadioWithBattery</span> &#123;<br>  switchRadio() &#123;<br><br>  &#125;<br>  checkBatteryStatus() &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">CellPhone</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">RadioWithBattery</span> &#123;<br>  switchRadio() &#123;<br><br>  &#125;<br>  checkBatteryStatus() &#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Enum枚举"><a href="#Enum枚举" class="headerlink" title="Enum枚举"></a>Enum枚举</h4><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nsis">// 常量枚举, 提升性能，不会编译成js代码，只有常量值才可以进行常量枚举，计算值不行。<br>const enum Direction1 &#123;<br>  <span class="hljs-literal">left</span>,<br>  <span class="hljs-literal">right</span>,<br>  <span class="hljs-literal">top</span>,<br>  <span class="hljs-literal">bottom</span><br>&#125;<br>enum Direction2 &#123;<br>  <span class="hljs-literal">left</span> = <span class="hljs-string">'LEFT'</span>,<br>  <span class="hljs-literal">right</span> = <span class="hljs-string">'RIGHT'</span>,<br>  <span class="hljs-literal">top</span> = <span class="hljs-string">'TOP'</span>,<br>  <span class="hljs-literal">bottom</span> = <span class="hljs-string">'BOTTOM'</span><br>&#125;<br>console.log(Direction1.<span class="hljs-literal">left</span>)<br>console.log(Direction1[<span class="hljs-number">0</span>])<br>console.log(Direction2.<span class="hljs-literal">left</span> === <span class="hljs-string">'LEFT'</span>)<br></code></pre></td></tr></table></figure><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>在定义函数接口或类的时候，先不指定具体类型，在使用的时候才指定。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> arg<br>&#125;<br><span class="hljs-keyword">const</span> result1: <span class="hljs-built_in">number</span> = echo(<span class="hljs-number">123</span>)<br><span class="hljs-keyword">const</span> result2: <span class="hljs-built_in">string</span> = echo(<span class="hljs-string">'string'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">tuple: [T, U]</span>): [<span class="hljs-title">T</span>, <span class="hljs-title">U</span>] </span>&#123;<br>  <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">0</span>], tuple[<span class="hljs-number">1</span>]]<br>&#125;<br><br><span class="hljs-keyword">const</span> result3 =  swap([<span class="hljs-string">'string'</span>, <span class="hljs-number">123</span>])<br></code></pre></td></tr></table></figure><p><strong>约束泛型</strong><br>使用extends继承接口进行约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IWithLength &#123;<br>  length: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echoWithLength</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">IWithLength</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(arg.length)<br>  <span class="hljs-keyword">return</span> arg<br>&#125;<br><span class="hljs-keyword">const</span> str = echoWithLength(<span class="hljs-string">'str'</span>)<br><span class="hljs-keyword">const</span> obj = echoWithLength(&#123; length: <span class="hljs-number">10</span> &#125;)<br><span class="hljs-keyword">const</span> arr = echoWithLength([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p><strong>泛型在类中的使用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">data</span> = []<br>  push(item: T) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.push(item)<br>  &#125;<br>  pop(): T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.shift()<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> queue = new Queue&lt;number&gt;()<br>queue.push(<span class="hljs-number">1</span>)<br>console.log(queue.pop().toFixed())<br></code></pre></td></tr></table></figure><p><strong>接口interface中使用泛型</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">KeyPair</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt; &#123;</span><br><span class="hljs-symbol">  key:</span> T;<br><span class="hljs-symbol">  value:</span> U;<br>&#125;<br>let <span class="hljs-string">kp1:</span> KeyPair&lt;number, string&gt; = &#123; <span class="hljs-string">key:</span> <span class="hljs-number">123</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'123'</span>&#125;<br>let <span class="hljs-string">kp2:</span> KeyPair&lt;string, number&gt; = &#123; <span class="hljs-string">key:</span> <span class="hljs-string">'str'</span>, <span class="hljs-string">value:</span> <span class="hljs-number">123</span>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型定义数组</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">let arr: Array&lt;number&gt; = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>interface描述函数</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IPlus&lt;T&gt; &#123;<br>    (a: T, b: T): <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plus</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-keyword">const</span> a: IPlus&lt;<span class="hljs-built_in">number</span>&gt; = plus<br><span class="hljs-keyword">const</span> b: IPlus&lt;<span class="hljs-built_in">string</span>&gt; = connect<br></code></pre></td></tr></table></figure><h4 id="类型别名和类型断言"><a href="#类型别名和类型断言" class="headerlink" title="类型别名和类型断言"></a>类型别名和类型断言</h4><p>type aliases</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> PlusType = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-keyword">const</span> sum2: PlusType = sum<br><br><span class="hljs-comment">// 联合类型中使用类型别名</span><br><span class="hljs-keyword">type</span> NameResolver = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span><br><span class="hljs-keyword">type</span> NameOrResolver = <span class="hljs-built_in">string</span> | NameResolver<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">n: NameOrResolver</span>): <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">'string'</span>) &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>type assertion 断言</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">input: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> str = input <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span><br>    <span class="hljs-comment">// or</span><br>    &lt;<span class="hljs-built_in">string</span>&gt;input<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><p>创建.d.ts文件，例如jQuery.d.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> Jquery: <span class="hljs-function">(<span class="hljs-params">selector: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">any</span><br></code></pre></td></tr></table></figure><p>再tsconfig.json中写配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">"include"</span>: [<span class="hljs-string">"**/*"</span>] <span class="hljs-comment">//编译当前文件夹下的所有文件</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存原理</title>
    <link href="/my-hexo-blog/2021/07/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"/>
    <url>/my-hexo-blog/2021/07/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>HTTP报文分为两种：</p><p>HTTP请求(Request)报文<br>请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体<br>HTTP响应(Response)报文<br>缓存过程分析</p><p>浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中</p><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识<br>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中<br>强制缓存</p><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程<br>主要有三种：</p><p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）<br>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存<br>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果<br>那么强制缓存的缓存规则是什么？ 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p><p>Expires</p><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果<br>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义</p><p>Cache-Control</p><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）<br>private：所有内容只有客户端可以缓存，Cache-Control的默认取值<br>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定<br>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存<br>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效<br>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？<br>状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。</p><p>那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？<br>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性</p><p>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。<br>时效性：一旦该进程关闭，则该进程的内存则会清空<br>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><p>协商缓存</p><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><p>协商缓存生效，返回304<br>协商缓存失效，返回200和请求结果结果<br>协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><p>Last-Modified / If-Modified-Since</p><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间</p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件</p><p>Etag / If-None-Match</p><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200</p><p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p><p>总结</p><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue变化侦测</title>
    <link href="/my-hexo-blog/2021/07/10/vue%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
    <url>/my-hexo-blog/2021/07/10/vue%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>变化侦测就是追踪状态，亦或者说是数据的变化，一旦发生了变化，就要去更新视图。</p><p>变化侦测可不是个新名词，它在目前的前端三大框架中均有涉及。在<strong>Angular</strong>中是通过脏值检查流程来实现变化侦测；在<strong>React</strong>是通过对比<strong>虚拟DOM</strong>来实现变化侦测，而在<strong>Vue</strong>中也有自己的一套变化侦测实现机制。</p><h3 id="object变化侦测"><a href="#object变化侦测" class="headerlink" title="object变化侦测"></a><strong>object变化侦测</strong></h3><h4 id="1-让Object数据变得“可观测”"><a href="#1-让Object数据变得“可观测”" class="headerlink" title="1.让Object数据变得“可观测”"></a>1.让Object数据变得“可观测”</h4><p>通过JS提供的Object.defineProperty方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/ 源码位置：src/core/observer/index.js<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (value) &#123;<br>    <span class="hljs-keyword">this</span>.value = value<br>    <span class="hljs-comment">// 给value新增一个__ob__属性，值为该value的Observer实例</span><br>    <span class="hljs-comment">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br>    def(value,<span class="hljs-string">'__ob__'</span>,<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-comment">// 当value为数组时的逻辑</span><br>      <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">this</span>.walk(value)<br>    &#125;<br>  &#125;<br><br>  walk (obj: <span class="hljs-built_in">Object</span>) &#123;<br>    <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>      defineReactive(obj, keys[i])<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使一个对象转化成可观测对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123; Object &#125;</span> </span>obj 对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123; String &#125;</span> </span>key 对象的key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123; Any &#125;</span> </span>val 对象的某个key的值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params">obj,key,val</span>) </span>&#123;<br>  <span class="hljs-comment">// 如果只传了obj和key，那么val = obj[key]</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>    val = obj[key]<br>  &#125;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'object'</span>)&#123;<br>      <span class="hljs-keyword">new</span> Observer(val)<br>  &#125;<br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    <span class="hljs-keyword">get</span>()&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被读取了`</span>);<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-keyword">set</span>(newVal)&#123;<br>      <span class="hljs-keyword">if</span>(val === newVal)&#123;<br>          <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>属性被修改了`</span>);<br>      val = newVal;<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。</p><p>并且给<code>value</code>新增一个<code>__ob__</code>属性，值为该<code>value</code>的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作</p><p>通过类型判断，如果是object类型，则会调用walk方法，通过循环遍历，调用defineReactive将每一个属性都转换成getter/setter的形式，如果子属性也是一个对象，则通过new Observer(val) 来递归子属性,这样object的所以属性（包括属性）都转化成getter和setting的形式来侦测变化，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> Observer(&#123;<br>  <span class="hljs-string">'brand'</span>:<span class="hljs-string">'BMW'</span>,<br>  <span class="hljs-string">'price'</span>:<span class="hljs-number">3000</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这样，car的两个属性就是可观测了。</p><h4 id="2-依赖收集"><a href="#2-依赖收集" class="headerlink" title="2.依赖收集"></a>2.依赖收集</h4><p><strong>在getter中收集依赖，在setter中通知依赖更新</strong>。</p><p>通过实现Dep类（依赖管理器）订阅器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 源码位置：src/core/observer/dep.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> () &#123;<br>    <span class="hljs-keyword">this</span>.subs = []<br>  &#125;<br><br>  addSub (sub) &#123;<br>    <span class="hljs-keyword">this</span>.subs.push(sub)<br>  &#125;<br>  <span class="hljs-comment">// 删除一个依赖</span><br>  removeSub (sub) &#123;<br>    remove(<span class="hljs-keyword">this</span>.subs, sub)<br>  &#125;<br>  <span class="hljs-comment">// 添加一个依赖</span><br>  depend () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.target) &#123;<br>      <span class="hljs-keyword">this</span>.addSub(<span class="hljs-built_in">window</span>.target)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 通知所有依赖更新</span><br>  notify () &#123;<br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-keyword">this</span>.subs.slice()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;<br>      subs[i].update()<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove an item from an array</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span> (<span class="hljs-params">arr, item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (arr.length) &#123;<br>    <span class="hljs-keyword">const</span> index = arr.indexOf(item)<br>    <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr.splice(index, <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的依赖管理器<code>Dep</code>类中，我们先初始化了一个<code>subs</code>数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。</p><p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params">obj,key,val</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>    val = obj[key]<br>  &#125;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'object'</span>)&#123;<br>    <span class="hljs-keyword">new</span> Observer(val)<br>  &#125;<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()  <span class="hljs-comment">//实例化一个依赖管理器，生成一个依赖管理数组dep</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    <span class="hljs-keyword">get</span>()&#123;<br>      dep.depend()    <span class="hljs-comment">// 在getter中收集依赖</span><br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-keyword">set</span>(newVal)&#123;<br>      <span class="hljs-keyword">if</span>(val === newVal)&#123;<br>          <span class="hljs-keyword">return</span><br>      &#125;<br>      val = newVal;<br>      dep.notify()   <span class="hljs-comment">// 在setter中通知依赖更新</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新</p><h4 id="3-依赖到底是谁"><a href="#3-依赖到底是谁" class="headerlink" title="3.依赖到底是谁"></a>3.依赖到底是谁</h4><p>实现Watcher类（依赖）订阅者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (vm,expOrFn,cb) &#123;<br>    <span class="hljs-keyword">this</span>.vm = vm;<br>    <span class="hljs-keyword">this</span>.cb = cb;<br>    <span class="hljs-keyword">this</span>.getter = parsePath(expOrFn)<br>    <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.get()<br>  &#125;<br>  <span class="hljs-keyword">get</span> () &#123;<br>    <span class="hljs-built_in">window</span>.target = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">this</span>.vm<br>    <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>.getter.call(vm, vm)<br>    <span class="hljs-built_in">window</span>.target = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>  update () &#123;<br>    <span class="hljs-keyword">const</span> oldValue = <span class="hljs-keyword">this</span>.value<br>    <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.get()<br>    <span class="hljs-keyword">this</span>.cb.call(<span class="hljs-keyword">this</span>.vm, <span class="hljs-keyword">this</span>.value, oldValue)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Parse simple path.</span><br><span class="hljs-comment"> * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来</span><br><span class="hljs-comment"> * 例如：</span><br><span class="hljs-comment"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span><br><span class="hljs-comment"> * parsePath('a.b.c')(data)  // 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> bailRE = <span class="hljs-regexp">/[^\w.$]/</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePath</span> (<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (bailRE.test(path)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> segments = path.split(<span class="hljs-string">'.'</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; segments.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span><br>      obj = obj[segments[i]]<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例，在创建<code>Watcher</code>实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个<code>Watcher</code>实例就代表这个依赖，当数据变化时，我们就通知<code>Watcher</code>实例，由<code>Watcher</code>实例再去通知真正的依赖。</p><p>那么，在创建<code>Watcher</code>实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？</p><p>下面我们分析<code>Watcher</code>类的代码实现逻辑：</p><ol><li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li><li>在构造函数中调用了<code>this.get()</code>实例方法；</li><li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm, vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li><li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即watcher实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图。</li></ol><p>简单总结一下就是：<code>Watcher</code>先把自己设置到全局唯一的指定位置（<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>watcher</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Watcher</code>发送通知。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。</p><h4 id="4-不足之处"><a href="#4-不足之处" class="headerlink" title="4.不足之处"></a>4.不足之处</h4><p>向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p><p>Vue<code>增加了两个全局API:</code>Vue.set<code>和</code>Vue.delete</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><h4 id="其整个流程大致如下："><a href="#其整个流程大致如下：" class="headerlink" title="其整个流程大致如下："></a>其整个流程大致如下：</h4><ol><li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li><li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li><li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li><li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li></ol><h3 id="Array的变化侦测"><a href="#Array的变化侦测" class="headerlink" title="Array的变化侦测"></a>Array的变化侦测</h3><p>由于数组无法使用Object .defineProperty来实现数据响应式</p><p><strong>Array型数据还是在getter中收集依赖。</strong></p><h4 id="1-实现数组方法拦截器"><a href="#1-实现数组方法拦截器" class="headerlink" title="1.实现数组方法拦截器"></a>1.实现数组方法拦截器</h4><p>在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。</p><p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有7个，分别是：<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>。那么源码中的拦截器代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/array.js</span><br><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-built_in">Array</span>.prototype<br><span class="hljs-comment">// 创建一个对象作为拦截器</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-built_in">Object</span>.create(arrayProto)<br><br><span class="hljs-comment">// 改变数组自身内容的7个方法</span><br><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">'push'</span>,<br>  <span class="hljs-string">'pop'</span>,<br>  <span class="hljs-string">'shift'</span>,<br>  <span class="hljs-string">'unshift'</span>,<br>  <span class="hljs-string">'splice'</span>,<br>  <span class="hljs-string">'sort'</span>,<br>  <span class="hljs-string">'reverse'</span><br>]<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> original = arrayProto[method]      <span class="hljs-comment">// 缓存原生方法</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(arrayMethods, method, &#123;<br>    enumerable: <span class="hljs-literal">false</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>    value:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span>(<span class="hljs-params">...args</span>)</span>&#123;<br>      <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-keyword">this</span>, args)<br>      <span class="hljs-keyword">return</span> result<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在上面的代码中，首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就后说，实标上执行的是函数<code>mutator</code>，而<code>mutator</code>函数内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。 那么，接下来我们就可以在<code>mutato</code>r函数中做一些其他的事，比如说发送变化通知</p><h4 id="2-使用拦截器"><a href="#2-使用拦截器" class="headerlink" title="2.使用拦截器"></a>2.使用拦截器</h4><p>把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p><p>其实挂载不难，我们只需把数据的<code>__proto__</code>属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/index.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (value) &#123;<br>    <span class="hljs-keyword">this</span>.value = value<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hasProto = <span class="hljs-string">'__proto__'</span> <span class="hljs-keyword">in</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> arrayKeys = <span class="hljs-built_in">Object</span>.getOwnPropertyNames(arrayMethods)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Augment an target Object or Array by intercepting</span><br><span class="hljs-comment"> * the prototype chain using __proto__</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">protoAugment</span> (<span class="hljs-params">target, src: Object, keys: any</span>) </span>&#123;<br>  target.__proto__ = src<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Augment an target Object or Array by defining</span><br><span class="hljs-comment"> * hidden properties.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* istanbul ignore next */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyAugment</span> (<span class="hljs-params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = keys.length; i &lt; l; i++) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    def(target, key, src[key])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value.__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的7个方法循环加入到<code>value</code>上。这时我们就可以在拦截器中监听到数据变化了。</p><h4 id="3-再谈依赖收集"><a href="#3-再谈依赖收集" class="headerlink" title="3.再谈依赖收集"></a>3.再谈依赖收集</h4><p>在<code>Observer</code>类中实例化了一个依赖管理器，用来收集数组依赖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 源码位置：/src/core/observer/index.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (value) &#123;<br>    <span class="hljs-keyword">this</span>.value = value<br>    <span class="hljs-keyword">this</span>.dep = <span class="hljs-keyword">new</span> Dep()    <span class="hljs-comment">// 实例化一个依赖管理器，用来收集数组依赖</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>数组的依赖也在<code>getter</code>中收集，那么在<code>getter</code>中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在<code>Observer</code>类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。源码是这么做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params">obj,key,val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> childOb = observe(val)<br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    <span class="hljs-keyword">get</span>()&#123;<br>      <span class="hljs-keyword">if</span> (childOb) &#123;<br>        childOb.dep.depend()<br>      &#125;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-keyword">set</span>(newVal)&#123;<br>      <span class="hljs-keyword">if</span>(val === newVal)&#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      val = newVal;<br>      dep.notify()   <span class="hljs-comment">// 在setter中通知依赖更新</span><br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Attempt to create an observer instance for a value,</span><br><span class="hljs-comment"> * returns the new observer if successfully observed,</span><br><span class="hljs-comment"> * or the existing observer if the value already has one.</span><br><span class="hljs-comment"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span><br><span class="hljs-comment"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">value, asRootData</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> ob<br>  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ob = <span class="hljs-keyword">new</span> Observer(value)<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码中，我们首先通过<code>observe</code>函数为被获取的数据<code>arr</code>尝试创建一个<code>Observer</code>实例，在<code>observe</code>函数内部，先判断当前传入的数据上是否有<code>__ob__</code>属性，因为在上篇文章中说了，如果数据有<code>__ob__</code>属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用<code>new Observer(value)</code>将其转化成响应式的，并把数据对应的<code>Observer</code>实例返回。</p><h4 id="4-如何通知依赖"><a href="#4-如何通知依赖" class="headerlink" title="4.如何通知依赖"></a>4.如何通知依赖</h4><p><code>vaule</code>上的<code>__ob__</code>就是其对应的<code>Observer</code>类实例，有了<code>Observer</code>类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的<code>dep.notify()</code>方法，让它去通知依赖更新即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-keyword">this</span>, args)<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-keyword">this</span>.__ob__<br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的<code>this</code>就是数据<code>value</code>，拿到<code>value</code>上的<code>Observer</code>类实例，从而你就可以调用<code>Observer</code>类实例上面依赖管理器的<code>dep.notify()</code>方法，以达到通知依赖的目的。</p><h4 id="5-深度侦测"><a href="#5-深度侦测" class="headerlink" title="5. 深度侦测"></a>5. 深度侦测</h4><p>所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  value: any;<br>  dep: Dep;<br><br>  <span class="hljs-keyword">constructor</span> (value: any) &#123;<br>    <span class="hljs-keyword">this</span>.value = value<br>    <span class="hljs-keyword">this</span>.dep = <span class="hljs-keyword">new</span> Dep()<br>    def(value, <span class="hljs-string">'__ob__'</span>, <span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">const</span> augment = hasProto<br>        ? protoAugment<br>        : copyAugment<br>      augment(value, arrayMethods, arrayKeys)<br>      <span class="hljs-keyword">this</span>.observeArray(value)   <span class="hljs-comment">// 将数组中的所有元素都转化为可被侦测的响应式</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">this</span>.walk(value)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Observe a list of Array items.</span><br><span class="hljs-comment">   */</span><br>  observeArray (items: <span class="hljs-built_in">Array</span>&lt;any&gt;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123;<br>      observe(items[i])<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">value, asRootData</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> ob<br>  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ob = <span class="hljs-keyword">new</span> Observer(value)<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p><p>而对应<code>object</code>数据，在上一篇文章中我们已经在<code>defineReactive</code>函数中进行了递归操作</p><h4 id="6-数组新增元素的侦测"><a href="#6-数组新增元素的侦测" class="headerlink" title="6.数组新增元素的侦测"></a>6.数组新增元素的侦测</h4><p>只需拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-comment">// cache original method</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-keyword">this</span>, args)<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-keyword">this</span>.__ob__<br>    <span class="hljs-keyword">let</span> inserted<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">'push'</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">'unshift'</span>:<br>        inserted = args   <span class="hljs-comment">// 如果是push或unshift方法，那么传入参数就是新增的元素</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">'splice'</span>:<br>        inserted = args.slice(<span class="hljs-number">2</span>) <span class="hljs-comment">// 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span><br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted) <span class="hljs-comment">// 调用observe函数将新增的元素转化成响应式</span><br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在上面拦截器定义代码中，如果是<code>push</code>或<code>unshift</code>方法，那么传入参数就是新增的元素;如果是<code>splice</code>方法，那么传入参数列表中下标为2的就是新增的元素，拿到新增的元素后，就可以调用<code>observe</code>函数将新增的元素转化成响应式的了。</p><h3 id="7-不足之处"><a href="#7-不足之处" class="headerlink" title="7. 不足之处"></a>7. 不足之处</h3><p>对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据</p><p>Vue<code>也注意到了这个问题， 为了解决这一问题，</code>Vue<code>增加了两个全局API:</code>Vue.set<code>和</code>Vue.delete</p>]]></content>
    
    
    <categories>
      
      <category>框架原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>div局中</title>
    <link href="/my-hexo-blog/2021/06/23/div%E5%B1%80%E4%B8%AD/"/>
    <url>/my-hexo-blog/2021/06/23/div%E5%B1%80%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="div居中的几种方法"><a href="#div居中的几种方法" class="headerlink" title="div居中的几种方法"></a>div居中的几种方法</h3><h4 id="使div水平垂直居中"><a href="#使div水平垂直居中" class="headerlink" title="使div水平垂直居中"></a>使div水平垂直居中</h4><h5 id="1、flex布局实现（已知元素宽度）"><a href="#1、flex布局实现（已知元素宽度）" class="headerlink" title="1、flex布局实现（已知元素宽度）"></a>1、flex布局实现（已知元素宽度）</h5><p>给父盒子设置：<br>display: flex;<br>justify-content: center;<br>align-items: center;</p><h5 id="2、position（已知元素宽度）"><a href="#2、position（已知元素宽度）" class="headerlink" title="2、position（已知元素宽度）"></a>2、position（已知元素宽度）</h5><p>父元素设置为：position: relative;<br>子元素设置为：position: absolute;<br>距上50%，据左50%，然后减去元素自身宽度的一半距离就可以实现</p><h5 id="3、position-transform-（未知宽度）"><a href="#3、position-transform-（未知宽度）" class="headerlink" title="3、position + transform （未知宽度）"></a>3、position + transform （未知宽度）</h5><p>父元素设置为：position: relative;<br>子元素设置为：position: absolute;<br>距上50%，据左50%，然后使用transform: translate(-50%,-50%);</p><h5 id="4、position（元素已知宽度）"><a href="#4、position（元素已知宽度）" class="headerlink" title="4、position（元素已知宽度）"></a>4、position（元素已知宽度）</h5><p>父元素设置为：position: relative;<br>子元素设置为：position: absolute;<br>left、right、bottom、top都为0，margin: auto;</p><p>如果子元素不设置宽度和高度，将会铺满整个父级(模态框)</p><h5 id="5-table-cell-布局实现"><a href="#5-table-cell-布局实现" class="headerlink" title="5. table-cell 布局实现"></a>5. table-cell 布局实现</h5><p>table 实现垂直居中，子集元素可以是块元素，也可以不是块元素</p><h4 id="使内容（文字，图片）水平垂直居中（table-cell-布局）"><a href="#使内容（文字，图片）水平垂直居中（table-cell-布局）" class="headerlink" title="使内容（文字，图片）水平垂直居中（table-cell 布局）"></a>使内容（文字，图片）水平垂直居中（table-cell 布局）</h4><p>行元素 text-align ：center；</p><p>块元素 ：margin ：0 auto；<br>text-align : center  给元素的父级加，可以使文本或者行级元素(例如：图片)水平居中<br>line-height : 值为元素的高度，可以使元素的文本内容垂直居中<br>margin: 0 auto 使用条件：父级元素宽度可有可无，子级元素必须使块元素，而且要有宽度（否则继承父级）</p><p>display：table-cell 会使元素表现的类似一个表格中的单元格td，利用这个特性可以实现文字的垂直居中效果。同时它也会破坏一些 CSS 属性，使用 table-cell 时最好不要与 float 以及 position: absolute 一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对margin值无反应，可以响 padding 的设置，表现几乎类似一个 td 元素。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css性能优化</title>
    <link href="/my-hexo-blog/2021/06/23/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/my-hexo-blog/2021/06/23/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<ol><li>合并css文件，如果页面加载10个css文件,每个文件1k，那么也要比只加载一个100k的css文件慢。</li><li>减少css嵌套，最好不要嵌套三层以上。</li><li>不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。</li><li>建立公共样式类，把相同样式提取出来作为公共类使用。</li><li>减少通配符*或者类似[hidden=”true”]这类选择器的使用，挨个查找所有…这性能能好吗？</li><li>巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。</li><li>拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。</li><li>不用css表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。</li><li>少用css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。</li><li>cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。</li><li>善后工作，css压缩(在线压缩工具 YUI Compressor)</li><li>GZIP压缩，是一种流行的文件压缩算法</li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="避免使用-import，外部的css文件中使用-import会使得页面在加载时增加额外的延迟。"><a href="#避免使用-import，外部的css文件中使用-import会使得页面在加载时增加额外的延迟。" class="headerlink" title="避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。"></a>避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。</h4><h4 id="避免过分重排"><a href="#避免过分重排" class="headerlink" title="避免过分重排"></a>避免过分重排</h4><p>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow</p><p>导致reflow发生的情况</p><ol><li>改变窗口的大小  </li><li>改变文字的大小</li><li>添加 删除样式表</li><li>内容的改变 输入框输入内容也会</li><li>伪类的激活</li><li>操作class属性</li><li>脚本操作dom js改变css类</li><li>计算offsetWidth和offsetHeight</li><li>设置style属性</li><li>改变元素的内外边距 </li></ol><p>常见重排元素</p><ol><li>大小有关的 width,height,padding,margin,border-width,border,min-height</li><li>布局有关的 display,top,position,float,left,right,bottom</li><li>字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align</li><li>隐藏有关的 overflow,overflow-x,overflow-y<h4 id="repaint-重绘"><a href="#repaint-重绘" class="headerlink" title="repaint 重绘"></a>repaint 重绘</h4></li></ol><p>当一个元素的外观被改变，但是布局没有改变的情况<br>当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素<br>常见的重绘元素</p><ul><li>颜色 color,background</li><li>边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width</li><li>背景有关 background,backgound-image,background-position,background-repeat,background-size</li></ul><h4 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h4><p>性能优化时最容易想到的，也是最常见的方法，就是文件压缩，这一方案往往效果显著<br>文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具webpack，gulp/grunt，rollup，压缩之后能够明显减少，可以大大降低浏览器的加载时间。</p><h4 id="去除无用CSS"><a href="#去除无用CSS" class="headerlink" title="去除无用CSS"></a>去除无用CSS</h4><ul><li>不同元素或者其他情况下的重复代码，</li><li>整个页面内没有生效的CSS代码</li></ul><h4 id="有选择地使用选择器"><a href="#有选择地使用选择器" class="headerlink" title="有选择地使用选择器"></a>有选择地使用选择器</h4><ol><li>保持简单，不要使用嵌套过多过于复杂的选择器</li><li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</li><li>不要使用类选择器和ID选择器修饰元素标签，如：h3#markdown-content，这一多此一举，还会降低效率</li><li>不要为了追求速度而放弃可读性和可维护性</li></ol><h4 id="减少使用昂贵的属性"><a href="#减少使用昂贵的属性" class="headerlink" title="减少使用昂贵的属性"></a>减少使用昂贵的属性</h4><h4 id="硬件加速的好坏"><a href="#硬件加速的好坏" class="headerlink" title="硬件加速的好坏"></a>硬件加速的好坏</h4>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>圣杯布局和双飞翼布局</title>
    <link href="/my-hexo-blog/2021/06/23/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <url>/my-hexo-blog/2021/06/23/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>通俗的来说就是左右两栏固定宽度，中间部分自适应的三栏布局。</p><h3 id="两者本质"><a href="#两者本质" class="headerlink" title="两者本质"></a>两者本质</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><ul><li>首先把left、middle、right都放出来</li><li>给它们三个设置上float: left, 脱离文档流；</li><li>一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档</li><li>left、right设置上各自的宽度<br>middle设置width: 100%;</li></ul><p>接下来比较重要了：</p><ul><li>给left、middle、right设置position: relative;</li><li>left设置 left: -leftWidth, right设置 right: -rightWidth;</li><li>container设置padding: 0, rightWidth, 0, leftWidth;</li></ul><p>因为不这样设置 会遮挡middle的内容</p><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>双飞翼布局和圣杯布局很类似，不过是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。</p><ul><li>首先把left、middle、right都放出来, middle中增加inner</li><li>给它们三个设置上float: left, 脱离文档流；</li><li>一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档</li><li>left、right设置上各自的宽度</li><li>middle设置width: 100%;<br>接下来与圣杯布局不一样的地方：</li><li>left设置 margin-left: -100%, right设置 right: -rightWidth;</li><li>container设置padding: 0, rightWidth, 0, leftWidth;</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js时间循环机制</title>
    <link href="/my-hexo-blog/2021/06/23/js%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/my-hexo-blog/2021/06/23/js%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="浏览器环境下js引擎的事件循环机制"><a href="#浏览器环境下js引擎的事件循环机制" class="headerlink" title="浏览器环境下js引擎的事件循环机制"></a>浏览器环境下js引擎的事件循环机制</h4><h5 id="1-执行栈与事件队列"><a href="#1-执行栈与事件队列" class="headerlink" title="1.执行栈与事件队列"></a>1.执行栈与事件队列</h5><p>基本类型以及对象的指针存放在栈中，对象的值存放在堆内存中。<br><strong>执行栈</strong>：js引擎在解析一段代码的时候，将其中的同步代码按照执行顺序加入到执行栈中，然后从头开始执行。当执行完毕后，当前函数的执行上下文会从栈顶弹层出，随之函数及其执行上下文会被销毁，其中的变量会被浏览器回收。<br><strong>事件队列</strong>：<br>js引擎遇到异步事件后并不会一直等待其返回结果，而会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列中，被放入的事件不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于空闲时，主线程会取查找事件队列是否又任务，如果有，那么主线程会取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码。如此反复，这样就形成一个无限循环。这个过程被称为事件循环（event loop）</p><h4 id="2-macro-task与micro-task"><a href="#2-macro-task与micro-task" class="headerlink" title="2.macro task与micro task"></a>2.macro task与micro task</h4><p>不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p><p>以下事件属于宏任务：</p><ul><li>setInterval()</li><li>setTimeout()  </li></ul><p>以下事件属于微任务:  </p><ul><li>new Promise()</li><li>new MutaionObserver()</li></ul><p>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</p><h4 id="node环境下的事件循环机制"><a href="#node环境下的事件循环机制" class="headerlink" title="node环境下的事件循环机制"></a>node环境下的事件循环机制</h4><p>node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。</p><h5 id="事件循环各阶段详解"><a href="#事件循环各阶段详解" class="headerlink" title="事件循环各阶段详解"></a>事件循环各阶段详解</h5><p>node中的事件循环的顺序：<br>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p><ul><li>timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。</li><li>I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。</li><li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li><li>poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。</li><li>check: setImmediate()的回调会在这个阶段执行。</li><li>close callbacks: 例如socket.on(‘close’, …)这种close事件的回调。</li></ul><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。  </p><p>有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。</p><h5 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a>check阶段</h5><p>check阶段专门用来执行setImmediate()方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。</p><h5 id="close阶段"><a href="#close阶段" class="headerlink" title="close阶段"></a>close阶段</h5><p>当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。</p><h5 id="timer阶段"><a href="#timer阶段" class="headerlink" title="timer阶段"></a>timer阶段</h5><p>这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。</p><h5 id="I-O-callback阶段"><a href="#I-O-callback阶段" class="headerlink" title="I/O callback阶段"></a>I/O callback阶段</h5><p>这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。</p><h4 id="process-nextTick-setTimeout与setImmediate的区别与使用场景"><a href="#process-nextTick-setTimeout与setImmediate的区别与使用场景" class="headerlink" title="process.nextTick,setTimeout与setImmediate的区别与使用场景"></a>process.nextTick,setTimeout与setImmediate的区别与使用场景</h4><p>在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate</p><h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环。。直到内存泄漏。</p><h5 id="setTimeout-和setImmediate"><a href="#setTimeout-和setImmediate" class="headerlink" title="setTimeout()和setImmediate()"></a>setTimeout()和setImmediate()</h5><p>setTimeout()方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。</p><p>setImmediate()方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的process.nextTick()方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v8垃圾回收机制</title>
    <link href="/my-hexo-blog/2021/06/23/v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/my-hexo-blog/2021/06/23/v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1、为何需要垃圾回收"><a href="#1、为何需要垃圾回收" class="headerlink" title="1、为何需要垃圾回收"></a>1、为何需要垃圾回收</h3><p>在v8引擎执行js代码的过程中，当遇到函数的情况时，会为其创建一个函数执行的上下文，并添加到调用堆栈的栈顶，函数的作用域中包含了该函数中声明的所以变量，当函数执行完毕后，对面的执行上下文会从栈顶弹出，函数的作用域随之销毁，其包括的所以变量也会统一释放并自动回收。如果不回收，必然导致内存暴增，引发内存泄漏。</p><h3 id="2、v8引擎的内存限制"><a href="#2、v8引擎的内存限制" class="headerlink" title="2、v8引擎的内存限制"></a>2、v8引擎的内存限制</h3><p>由于js的单线程机制和垃圾回收机制，<br>V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个G内存这样的场景</p><h3 id="3、v8的垃圾回收策略"><a href="#3、v8的垃圾回收策略" class="headerlink" title="3、v8的垃圾回收策略"></a>3、v8的垃圾回收策略</h3><p>V8的垃圾回收策略主要是基于<strong>分代式垃圾回收机制</strong>，其根据<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p><h4 id="v8的内存结构"><a href="#v8的内存结构" class="headerlink" title="v8的内存结构"></a>v8的内存结构</h4><p>主要了解新生代和老生代</p><ul><li>新生代(new_space)：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。（Scavenge算法）</li><li>老生代(old_space)：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。Mark-Sweep(标记清除)和Mark-Compact(标记整理)</li></ul><h3 id="4、如何避免内存泄漏"><a href="#4、如何避免内存泄漏" class="headerlink" title="4、如何避免内存泄漏"></a>4、如何避免内存泄漏</h3><ul><li>尽可能少地创建全局变量</li><li>手动清除定时器</li><li>少用闭包</li><li>清除DOM引用</li><li>弱引用<br>在ES6中为我们新增了两个有效的数据结构WeakMap和WeakSet，就是为了解决内存泄漏的问题而诞生的。其表示弱引用</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this、call、apply、bind</title>
    <link href="/my-hexo-blog/2021/06/17/this%E3%80%81call%E3%80%81apply%E3%80%81bind/"/>
    <url>/my-hexo-blog/2021/06/17/this%E3%80%81call%E3%80%81apply%E3%80%81bind/</url>
    
    <content type="html"><![CDATA[<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在JavaScript中，this的指向是调用时决定的，而不是创建时决定的，<strong>this永远指向最后调用它的那个对象。</strong></p><h4 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h4><p>在全局上下文中，this指全局对象</p><ul><li>this等价于window对象</li><li>var === this. === window.<br>在浏览器里面this等价于window对象，如果你声明一些全局变量，这些变量都会作为this的属性。</li></ul><h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><p>在函数内部，this的值取决于函数被调用的方式</p><ul><li><p>直接调用<br>this指向window，严格模式下是undefined</p></li><li><p>作为对象的一个方法<br>当this所在的函数被以obj.fn()形式调用时，指向obj</p></li><li><p>call()、apply，(不同点：前者传的是若干个参数列表，后者是包含多个参数的数组)<br>this指向绑定的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Person = &#123;<br>    name: <span class="hljs-string">'YoLin'</span>,<br>    age: <span class="hljs-number">25</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params">job</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>，今天&#123;this.age&#125;,职业是<span class="hljs-subst">$&#123;job&#125;</span>`</span>)<br>&#125;<br>say.call(Person, <span class="hljs-string">"FE"</span>)<br>say.apply(Person, [<span class="hljs-string">"FE"</span>])<br></code></pre></td></tr></table></figure></li><li><p>bind()<br>this将永久地被绑定到了bind的第一个参数。<br>与call、apply相似，接受若干个参数列表并返回一个新的函数，不同的是需要我们手动调用。</p></li><li><p>箭头函数<br>所有的箭头函数都没有自己的this，都指向外层。<br>箭头函数会捕获其所在上下文的this值，作为自己的this值。<br>箭头函数的 this 始终指向函数定义时的 this，而非执行时<br>箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p></li><li><p>作为一个构造函数（new实例化一个对象）<br>this被绑定到正在构造的新对象。<br>通过构造函数创建一个对象其实执行这样几个步骤：<br>1、创建新对象<br>2、将this指向这个对象<br>3、给对象赋值（属性、方法）<br>4、返回this  </p><h4 id="new的过程"><a href="#new的过程" class="headerlink" title="new的过程"></a>new的过程</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">myFunction</span>(<span class="hljs-string">"Li"</span>,<span class="hljs-string">"Cherry"</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-type">myFunction</span>&#123;<br>    <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>    obj.__proto__ = myFunction.prototype;<br>    <span class="hljs-keyword">var</span> result = myFunction.call(obj,<span class="hljs-string">"Li"</span>,<span class="hljs-string">"Cherry"</span>);<br>    <span class="hljs-keyword">return</span> typeof result === <span class="hljs-string">'obj'</span>? result : <span class="hljs-type">obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、创建一个空对象 obj;<br>2、将新创建的空对象的隐式原型指向其构造函数的显示原型。<br>3、使用 call 改变 this 的指向<br>4、如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果要判断一个函数的this绑定，就需要找到这个函数的直接调用位置。然后可以顺序按照下面四条规则来判断this的绑定对象：</p><ul><li>由new调用：绑定到新创建的对象</li><li>由call或apply、bind调用：绑定到指定的对象</li><li>由上下文对象调用：绑定到上下文对象</li><li>默认：全局对象<br>注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定this，继承外层函数调用的this绑定。</li></ul><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>手写call的思路：</p><ul><li>1、将函数设置为对象的一个属性</li><li>2、执行该函数</li><li>3、删除该函数<br>通过Arguments 对象中取值，然后放入一个数组里<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 以上个例子为例，此时的arguments为：</span><br><span class="hljs-comment">// arguments = &#123;</span><br><span class="hljs-comment">//      0: foo,</span><br><span class="hljs-comment">//      1: 'kevin',</span><br><span class="hljs-comment">//      2: 18,</span><br><span class="hljs-comment">//      length: 3</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 因为arguments是类数组对象，所以可以用for循环</span><br><span class="hljs-keyword">var</span> args = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span> = arguments.length; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;<br>    args.push(<span class="hljs-string">'arguments['</span> + i + <span class="hljs-string">']'</span>);<br>&#125;<br><br><span class="hljs-comment">// 执行后 args为 [foo, 'kevin', 18]</span><br></code></pre></td></tr></table></figure>把这个参数数组放到要执行的函数的参数里面去  </li></ul><p>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-string">'context.fn('</span> + args +<span class="hljs-string">')'</span>)</span></span><br></code></pre></td></tr></table></figure><p>这里 args 会自动调用 Array.toString() 这个方法。<br>最终代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.call2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span>;<br>    context.fn = <span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">var</span> args = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>        args.push(<span class="hljs-string">'arguments['</span> + i + <span class="hljs-string">']'</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">'context.fn('</span> + args +<span class="hljs-string">')'</span>);<br><br>    <span class="hljs-keyword">delete</span> context.fn<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>apply与call类似，只是传入的参数是一个数组</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Function.prototype.<span class="hljs-built_in">apply</span> = function (<span class="hljs-built_in">context</span>, arr) &#123;<br>    <span class="hljs-built_in">var</span> <span class="hljs-built_in">context</span> = Object(<span class="hljs-built_in">context</span>) || window;<br>    <span class="hljs-built_in">context</span>.fn = this;<br><br>    <span class="hljs-built_in">var</span> result;<br>    <span class="hljs-keyword">if</span> (!arr) &#123;<br>        result = <span class="hljs-built_in">context</span>.fn();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">var</span> <span class="hljs-built_in">args</span> = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> i = <span class="hljs-number">0</span>, len = arr.<span class="hljs-built_in">length</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-built_in">args</span>.<span class="hljs-built_in">push</span>('arr[' + i + ']');<br>        &#125;<br>        result = <span class="hljs-built_in">eval</span>('<span class="hljs-built_in">context</span>.fn(' + <span class="hljs-built_in">args</span> + ')')<br>    &#125;<br><br>    <span class="hljs-built_in">delete</span> <span class="hljs-built_in">context</span>.fn<br>    <span class="hljs-built_in">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><ul><li>返回一个函数</li><li>可以传入参数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Function.prototype.bind - what is trying to be bound is not callable'</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>,<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span><br>    <span class="hljs-keyword">var</span> fNOP = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> fBound = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> bingArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>    self.apply(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> fNOP.prototype ? <span class="hljs-keyword">this</span> : context, args.concat(bindArgs))<br>    &#125;<br>    fNOP.prototype = <span class="hljs-keyword">this</span>.prototype<br>    fBound.prototype = <span class="hljs-keyword">new</span> fNOP()<br>    <span class="hljs-keyword">return</span> fBound<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h4><p>具备与数组特征类似的对象  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">let <span class="hljs-built_in">array</span>Like = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,<br>    length: <span class="hljs-number">3</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>获取 DOM 节点的方法<br>方法中的 arguments 都是类数组<br>可以通过for循环进行遍历,类数组无法使用 forEach、splice、push 等数组原型链上的方法</p><p>call的使用场景：</p><ul><li>对象的继承<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent.call(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>借用方法<br>类数组想用使用数组的方法<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">let</span> domNodes = <span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.slice.call(arr)<br></code></pre></td></tr></table></figure>apply的一些妙用:<br>1、获取数组中数字最大最小值<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.max</span><span class="hljs-selector-class">.apply</span>(<span class="hljs-selector-tag">null</span>, <span class="hljs-selector-tag">arr</span>)<br><span class="hljs-selector-tag">Math</span><span class="hljs-selector-class">.min</span><span class="hljs-selector-class">.apply</span>(<span class="hljs-selector-tag">null</span>, <span class="hljs-selector-tag">arr</span>)<br></code></pre></td></tr></table></figure>2、合并两个数组<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Array</span><span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.push</span><span class="hljs-selector-class">.apply</span>(<span class="hljs-selector-tag">arr1</span>,<span class="hljs-selector-tag">arr2</span>)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>instanceof、typeof</title>
    <link href="/my-hexo-blog/2021/06/17/instanceof%E3%80%81typeof/"/>
    <url>/my-hexo-blog/2021/06/17/instanceof%E3%80%81typeof/</url>
    
    <content type="html"><![CDATA[<h3 id="typeof实现原理"><a href="#typeof实现原理" class="headerlink" title="typeof实现原理"></a>typeof实现原理</h3><p>typeof用于判断变量的类型，可以判断number、string、object、undefined、function、boolean、symbol 这7种类型，判断不是object类型的时候可以比较清楚的告诉我们具体是哪一类，但不能明确告诉我们object是哪一种。<br>由于js底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息。</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数  </li></ul><p>对于null和undefined比较特殊，<br>undefined： 用 −2^30 整数来表示<br>null：所以机器码都为0，因此通过typeof判断时候会被当作object<br>使用instanceof判断的话，null直接判断为不是object。<br>因此在使用typeof判断变量类型的时候，最好用来判断基本数据类型（包括symbol），避免对null的判断</p><p>还有一个不错的判断类型的方法，Object.prototype.toString,可以利用这个方法来对一个变量类型来进行比较准确的判断</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">1</span>) // "[object Number]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-string">'hi'</span>) // "[object String]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&#123;a:<span class="hljs-string">'hi'</span>&#125;) // "[object Object]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([<span class="hljs-number">1</span>,<span class="hljs-string">'a'</span>]) // "[object Array]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>) // "[object Boolean]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(() =&gt; &#123;&#125;) // "[object Function]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>) // "[object Null]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined) // "[object Undefined]"<br><br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(Symbol(<span class="hljs-number">1</span>)) // "[object Symbol]"<br></code></pre></td></tr></table></figure><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>instanceof主要的作用是判断一个实例是否属于某种类型，也可以判断一个实例是否是其父类型或者祖先类型的实例。</p><p>instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。</p><p>因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p><p>总结：<br>简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型、继承</title>
    <link href="/my-hexo-blog/2021/06/17/%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/"/>
    <url>/my-hexo-blog/2021/06/17/%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在规范里，prototype 被定义为：给其它对象提供共享属性的对象。 </p><p>JS是通过函数来模拟类，当我们创建一个函数的时候，js会给这个函数自动添加prototype属性，值是一个包含constructor属性的对象，不是空对象。当我们把函数当成构造函数通过new关键词调用的时候，js会帮我们创建该构造函数的实例，实例继承构造函数prototype的所以属性和方法（实例通过设置自己的<code>__proto__</code>指向构造函数的prototype来实现继承）</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor属性也是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数。</p><h4 id="所有-object-对象都有一个隐式引用"><a href="#所有-object-对象都有一个隐式引用" class="headerlink" title="所有 object 对象都有一个隐式引用"></a>所有 object 对象都有一个隐式引用</h4><p>什么叫隐式引用？<br>所谓的隐式，是指不是由开发者(你和我)亲自创建/操作。<code>__proto__</code></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>原型链的概念，仅仅是在原型这个概念基础上所作的直接推论。<br>既然 prototype 只是恰好作为另一个对象的隐式引用的普通对象。那么，它也是对象，也符合一个对象的基本特征。<br>也就是说，prototype 对象也有自己的隐式引用，有自己的 prototype 对象。</p><p>如此，构成了对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>所谓的原型继承，就是指设置某个对象为另一个对象的原型（塞进该对象的隐式引用位置）。<br>在 JavaScript 中，有两类原型继承的方式：显式继承和隐式继承。</p><h4 id="显式原型继承"><a href="#显式原型继承" class="headerlink" title="显式原型继承"></a>显式原型继承</h4><p>所谓的显式原型继承，就是指我们亲自将某个对象设置为另一个对象的原型。<br>通过调用<strong>Object.setPrototypeOf</strong> 方法  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">obj1</span>, <span class="hljs-params">obj2</span>)</span> <span class="hljs-comment">//将obj2设置为obj1的原型对象</span><br></code></pre></td></tr></table></figure><p>还有另一种途径。即是通过 Object.create 方法，直接继承另一个对象。<br><strong>Object.setPropertyOf 和 Object.create 的差别在于：</strong>  </p><ul><li>1）Object.setPropertyOf，给我两个对象，我把其中一个设置为另一个的原型。  </li><li>2）Object.create，给我一个对象，它将作为我创建的新对象的原型。</li></ul><h4 id="隐式原型继承"><a href="#隐式原型继承" class="headerlink" title="隐式原型继承"></a>隐式原型继承</h4><p>通过 new 去创建 user 对象，可以通过 user.consturctor 访问到它的构造函数。</p><h4 id="函数对象和普通对象"><a href="#函数对象和普通对象" class="headerlink" title="函数对象和普通对象"></a>函数对象和普通对象</h4><p>通过字面量或构造函数new的方式来创建对象</p><p>将对象分为函数对象和普通对象，所谓的函数对象，其实就是 JavaScript 的用函数来模拟的类实现</p><h3 id="ES5-中的继承实现方法"><a href="#ES5-中的继承实现方法" class="headerlink" title="ES5 中的继承实现方法"></a>ES5 中的继承实现方法</h3><h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h4><h5 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = myFunction(<span class="hljs-string">'Deng'</span>, <span class="hljs-string">'yongling'</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> obj = &#123;&#125;<br>    obj.__proto__ = myFunction.prototype<br>    <span class="hljs-keyword">var</span> result = myFunction.call(obj, ...arguments)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个空对象</li><li>将该对象的隐式原型指向构造函数的显式原型</li><li>使用call改变this指向</li><li>如果无返回值或者返回值是非对象，则返回这个新建的obj，否则直接返回该返回值对象。</li></ul><hr><h3 id="继承的多种方式和优缺点"><a href="#继承的多种方式和优缺点" class="headerlink" title="继承的多种方式和优缺点"></a>继承的多种方式和优缺点</h3><h4 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'YoLin'</span><br>&#125;<br>Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;<br><br>Child.prototype = <span class="hljs-keyword">new</span> Parent()<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child()<br>child.getName() <span class="hljs-comment">// YoLin</span><br></code></pre></td></tr></table></figure><p>存在问题：</p><ul><li>1、引用类型得属性被所有实例共享</li><li>2、在创建Child实例得时候，不能向Parent传参</li></ul><h4 id="2、借用构造函数（经典继承）"><a href="#2、借用构造函数（经典继承）" class="headerlink" title="2、借用构造函数（经典继承）"></a>2、借用构造函数（经典继承）</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">funtion Parent() &#123;<br>    <span class="hljs-built_in">this</span>.names = [<span class="hljs-string">'YoLin'</span>,<span class="hljs-string">'Deng'</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span></span>() &#123;<br>    Parent.call(<span class="hljs-built_in">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Child</span>()<br>child1.names.push(<span class="hljs-string">'123'</span>)<span class="hljs-comment">// ['YoLin', 'Deng', '123']</span><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Child</span>()<br>child2.names <span class="hljs-comment">// ['YoLin', 'Deng']</span><br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>1、避免了引用类型的属性被所有实例共享</li><li>2、可以在Child中向Parent传参<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span><span class="hljs-params">(name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span><span class="hljs-params">(name)</span> </span>&#123;<br>    Parent.call(<span class="hljs-keyword">this</span>, name)<br>&#125;<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'YoLin'</span>)<br>child.name <span class="hljs-comment">// YoLin</span><br></code></pre></td></tr></table></figure>缺点：<br>方法都在构造函数中定义，每次创建实例都会创建一遍方法</li></ul><h4 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h4><p>原型链继承和经典继承的结合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue, green'</span>]<br>&#125;<br>Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    Parent.call(<span class="hljs-keyword">this</span>, name)<br>    <span class="hljs-keyword">this</span>.age = age<br>&#125;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent()<br>Child.prototype.constructor = Child<br></code></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数继承的优点，是javascript中最常用的继承模式</p><p>组合继承最大的缺点是会调用两次父构造函数。</p><ul><li>一次是设置子类型实例的原型时</li><li>一次在创建子类型实例的时候</li></ul><h4 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Obj(<span class="hljs-params">o</span>)</span> &#123;<br>    funtion <span class="hljs-constructor">F()</span> &#123;&#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype = o<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。<br>缺点：包含引用类型的属性始终都会共享相应的值</p><h4 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span><span class="hljs-params">(o)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">clone</span> = Object.create(o)<br>    <span class="hljs-keyword">clone</span>.sayName = fucntion() &#123;<br>        console.log(<span class="hljs-string">'hi'</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">clone</span><br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h4 id="6、寄生组合式继承"><a href="#6、寄生组合式继承" class="headerlink" title="6、寄生组合式继承"></a>6、寄生组合式继承</h4><p>为了避免重复调用父构造函数</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>];<br>&#125;<br><br>Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>    Parent.call(<span class="hljs-keyword">this</span>, name);<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    F.prototype = o<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prototpe</span>(<span class="hljs-params">child, parent</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> prototype = object(<span class="hljs-built_in">parent</span>.prototype)<br>    prototype.constructor = child<br>    child.prototype = prototype<br>&#125;<br>prototype(Child, Parent)<br></code></pre></td></tr></table></figure><p>将组合式继承中的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Parent()</span><br></code></pre></td></tr></table></figure><p>变成调用object重新创建一个新的Parent的原型实例，并赋值给Child的prototype来实现</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">prototype</span><span class="hljs-params">(Child, Parent)</span></span><br></code></pre></td></tr></table></figure><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js执行上下文、作用域链、闭包</title>
    <link href="/my-hexo-blog/2021/05/25/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/"/>
    <url>/my-hexo-blog/2021/05/25/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>是评估和执行 JavaScript 代码的环境的抽象概念，每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。<br>执行上下文包括：</p><ul><li>1、全局执行上下文  </li><li>2、函数执行上下文  </li><li>3、Eval函数执行上下文  </li></ul><p>三个重要属性</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>用来存储代码运行时创建的所有上下文（先进后出）<br>但javascript引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文，并压入到当前的执行栈中，每当遇到函数调用会创建一个新的执行上下文并压入到栈顶，当函数执行结束时，执行上下文会从栈中弹出，控制流程到下一个执行上下文，直到所以代码执行完毕后从当前栈中移除全局执行上下文。<br><strong>创建执行上下文有两个阶段</strong></p><p>1) 创建阶段 </p><ul><li>This 绑定</li><li>创建词法环境组件<br>内部有两个组件：  (1) 环境记录器和 (2) 一个外部环境的引用。<br>两种类型：全局和函数（this不同，外部环境引用不同）<br>在全局环境中，环境记录器是对象环境记录器。<br>在函数环境中，环境记录器是声明式环境记录器。</li><li>创建变量环境组件<br>2) 执行阶段</li></ul><p>在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。</p><p>词法（静态）作用域与动态作用域区别<br>javascript采用的是词法作用域，函数的作用域在函数定义的时候就确定了<br>动态作用域的函数作用域取决于函数调用的时候。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>每一个执行上下文都会分配一个变量对象(variable object)，变量对象的属性由 变量(variable) 和 函数声明(function declaration) 构成。在函数上下文情况下，参数列表(parameter list)也会被加入到变量对象(variable object)中作为属性。变量对象与当前作用域息息相关。不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。<br>有一点特殊就是只有 函数声明(function declaration) 会被加入到变量对象中，而 <strong>函数表达式(function expression)</strong>则不会。看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">// function</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">// function</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> _a) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h3><p>当函数被激活，那么一个活动对象(activation object)就会被创建并且分配给执行上下文。活动对象由特殊对象 arguments 初始化而成。随后，他被当做变量对象(variable object)用于变量初始化</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>由多个执行上下文的变量对象构成的链表就叫做作用域链。<br>以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p><ul><li>函数创建<br>函数的作用域在函数定义的时候就决定了。</li></ul><p>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><ul><li>函数激活<br>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端<br>Scope = [AO].concat([[Scope]]);</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束<br>闭包的外部作用域是在其定义的时候已决定，而不是执行的时候（词法作用域）</p><p>当外部作用域执行完后，内部函数还存活时，闭包才真正发挥它的作用<br>譬如一下几种情况：</p><ul><li>异步任务（定时器，事件处理，ajax请求中的回调）</li><li>被外部函数作为返回结果，或者返回结果对象中引用该内部函数</li></ul><p><strong>闭包与封装性</strong><br>封装意味着信息隐藏<br>函数与私有状态：通过闭包，可以创建拥有私有状态的函数，闭包使得状态被封装起来。</p><p>工厂模式与私有原型对象<br>我们可以通过闭包，只用创建原型对象一次，也能够被所有 Todo 函数调用所公用，并且保证其私有性。示例如下：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">let</span> Todo = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTodoFactory</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> todoPrototype = &#123;<br>    <span class="hljs-attribute">toString</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.userName + <span class="hljs-string">": "</span> + <span class="hljs-keyword">this</span>.title;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">todo</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> newTodo = <span class="hljs-built_in">Object</span>.create(todoPrototype);<br>    <span class="hljs-built_in">Object</span>.assign(newTodo, todo);<br>    <span class="hljs-keyword">return</span> newTodo;<br>  &#125;<br>&#125;)();<br><span class="hljs-keyword">let</span> todo = Todo(&#123;<span class="hljs-attribute">id :</span><span class="hljs-string"> 1, title</span>: <span class="hljs-string">"This is a title"</span>, <span class="hljs-attribute">userName</span>: <span class="hljs-string">"Cristi"</span>, <span class="hljs-attribute">completed</span>: <span class="hljs-literal">false</span> &#125;);<br></code></pre></td></tr></table></figure><p>工厂模式与私有构造函数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let Todo = (<span class="hljs-keyword">function</span> createTodoFactory()&#123;<br> <span class="hljs-keyword">function</span> Todo(spec)&#123;<br>   <span class="hljs-keyword">Object</span>.assign(this, spec);<br> &#125;<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(spec)&#123;<br>   let todo = <span class="hljs-built_in">new</span> Todo(spec);<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">freeze</span>(todo);<br> &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>这里，Todo() 工厂函数就是一个闭包。通过它，不管是否使用 new ，我们都可以创建不可变对象，原型对象也只用创建一次，并且它是私有的。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>在 Javascript中，局部变量会随着函数的执行完毕而被销毁，除非还有指向他们的引用。当闭包本身也被垃圾回收之后，这些闭包中的私有状态随后也会被垃圾回收。通常我们可以通过切断闭包的引用来达到这一目的。<br>将闭包函数置为 null</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>闭包是一个可以访问外部作用域中变量的内部函数。</p><p>这些被引用的变量直到闭包被销毁时才会被销毁。</p><p>闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。</p><p>可以通过闭包来达到封装性。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的ES6优化升级内容</title>
    <link href="/my-hexo-blog/2021/05/24/%E5%B8%B8%E7%94%A8%E7%9A%84ES6%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E5%86%85%E5%AE%B9/"/>
    <url>/my-hexo-blog/2021/05/24/%E5%B8%B8%E7%94%A8%E7%9A%84ES6%E4%BC%98%E5%8C%96%E5%8D%87%E7%BA%A7%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="一、let-和-const-命令"><a href="#一、let-和-const-命令" class="headerlink" title="一、let 和 const 命令"></a>一、let 和 const 命令</h4><p>let具有自己的块级作用域，且修复了var声明带来的变量提升问题。使用const声明常量，是不可更改的。  </p><h4 id="二、对String字符串类型做的常用升级优化"><a href="#二、对String字符串类型做的常用升级优化" class="headerlink" title="二、对String字符串类型做的常用升级优化"></a>二、对String字符串类型做的常用升级优化</h4><ul><li>模板字符串（``）</li><li>在String的原型上新增includes()方法，取代传统的indexof，语义更清晰</li><li>另外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法  </li><li><em>1、startsWith: str.startsWith(searchString[, position])*</em><br>以什么开头，接受两个参数，一个是要搜索的字符串，第二个是搜索开始的位置，默认为0，找到为true，否则为fasle。  </li><li><em>2、endsWith：str.endsWith(searchString[, length])*</em><br>以什么结尾，第一个参数也是搜索的字符串，第二个则是被搜索的字符串长度，默认是str.length  </li><li><em>3、padStart:str.padStart(targetLength [, padString])*</em><br>在原字符串开头填充字符串，直到达到目标长度<br>第一个参数是目标长度，第二个参数是填充字符串，如果字符串太长，则保留左侧  </li><li><em>4、padEnd：str.padEnd(targetLength [, padString])*</em><br>在原字符串末尾填充指定字符串，直到目标长度。与padStart参数相同  </li><li><em>5、str.repeat(count)*</em><br>repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。<br>count：重复的次数，表示新构造的字符串中重复了多少遍原字符串。<h4 id="三、对Array数组类型做的常用升级优化"><a href="#三、对Array数组类型做的常用升级优化" class="headerlink" title="三、对Array数组类型做的常用升级优化"></a>三、对Array数组类型做的常用升级优化</h4></li><li>数组解构赋值:<br><code>let [a,b,c] = [1,2,3]</code></li><li>扩展运算符:  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = [...a]<br></code></pre></td></tr></table></figure></li><li>find和findIndex方法<br>1、find：数组实例find方法，它可接收一个回调函数作为参数，该回调函数可传3个参数分别是当前值、当前位置、原数组。<br><code>[1,2,3].find((value, index, arr) =&gt; value &gt; 1)</code><br>执行结果会返回符合条件的首个成员，若没有符合的则返回undefined<br>2、findIndex：与find使用方法类似，不同的是返回符合条件成员位置，没有符合则返回-1</li></ul><p>这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-literal">NaN</span>].indexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br>[<span class="hljs-literal">NaN</span>].find(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, x)) <span class="hljs-comment">// NaN</span><br>[<span class="hljs-literal">NaN</span>].findIndex(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, x)) <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><ul><li><p>copyWithin<br>方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。<br><code>arr.copyWithin(target[, start[, end]])</code><br>可传如三个参数：<br>1、target表示目标位置，从这个位置开始复制并替换，如果是负数则从尾部开始算，如果target大于arr.length，则不拷贝，若target在start后面，那么复制序列会被修改以符合arr.length<br>2、start表示开始复制元素的起始位置，负数表示从末尾开始算,若不穿start，将从0开始复制<br>3、end表示开始复制元素的结束位置，会拷贝到这个位置，但不包括它，如果是负数，则是从末尾开始算。若不传将复制到数组结尾（默认是arr.length）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">例子</span><br><span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">].copyWithin(-2)</span><br><span class="hljs-string">//</span> <span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">2</span><span class="hljs-string">]</span><br><br><span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">].copyWithin(0,</span> <span class="hljs-number">3</span><span class="hljs-string">)</span><br><span class="hljs-string">//</span> <span class="hljs-string">[4,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">]</span><br><br><span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">].copyWithin(0,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">)</span><br><span class="hljs-string">//</span> <span class="hljs-string">[4,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">]</span><br><br><span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">].copyWithin(-2,</span> <span class="hljs-number">-3</span><span class="hljs-string">,</span> <span class="hljs-number">-1</span><span class="hljs-string">)</span><br><span class="hljs-string">//</span> <span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">]</span><br></code></pre></td></tr></table></figure></li><li><p>includes<br><code>arr.includes(valueToFind[, fromIndex])</code></p></li></ul><p>valueToFind: 需要查找的元素<br>fromIndex：从fromIndex索引开始查找，可以是负数，表示从末尾开始<br>若着找到对应元素，则返回true，否则返回false<br><code>[1,2,3].includes(1) // true</code></p><ul><li><p>fill<br>fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<br><code>arr.fill(value[, start[, end]])</code><br>value: 填充的值<br>start：起始位置索引，默认为0<br>end：结束位置所以，默认是数组长度<br><code>[1,2,3].fill(6,1) // [1, 6, 6]</code></p></li><li><p>flat<br>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回<br><code>var newArray = arr.flat([depth])</code><br>depth: 指定要提取嵌套数组的结构深度，默认值为 1 </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]].flat(<span class="hljs-number">2</span>) <span class="hljs-comment">// [1,2,3,4,5,6]</span><br></code></pre></td></tr></table></figure><h4 id="四、对Number数字类型做的常用升级优化"><a href="#四、对Number数字类型做的常用升级优化" class="headerlink" title="四、对Number数字类型做的常用升级优化"></a>四、对Number数字类型做的常用升级优化</h4></li><li><p>Number原型上新增isFinite(),isNaN()方法，用于优化传统的全局isFinite(), isNaN()，会把非数值类型转为Number类型再判断，而ES6中不会转化类型。分别用于检测数值是否有限、是否是NaN。</p></li><li><p>Math对象上新增Math.cbrt()，trunc()，hypot()等科学计数法运算方法</p></li></ul><h4 id="五、对Object类型做的常用升级优化"><a href="#五、对Object类型做的常用升级优化" class="headerlink" title="五、对Object类型做的常用升级优化"></a>五、对Object类型做的常用升级优化</h4><ul><li>对象属性变量式声明</li></ul><p>如果对象属性的值的一个变量，且键值相同，则可省略值的书写</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let &#123; <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,c &#125; = obj<br>let newObj = &#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>:b&#125; <span class="hljs-comment">//等价于下面的式子</span><br>let newObj = &#123;<span class="hljs-selector-tag">a</span>,b&#125;<br></code></pre></td></tr></table></figure><p>方法也可以简化为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span></span>() &#123;<br>        <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对象解构赋值<br><code>let { a,b } = { a:1, b:2 }</code>  </li><li>对象扩展运算符  </li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let &#123; <span class="hljs-selector-tag">a</span>,..<span class="hljs-selector-class">.rest</span> &#125; = &#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span>:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span> &#125; <span class="hljs-comment">// rest = &#123; b:2, c:3 &#125;</span><br>let obj1 = &#123; <span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span>:<span class="hljs-number">2</span> &#125;<br>let obj2 = &#123;..<span class="hljs-selector-class">.obj1</span>, c: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>super 关键字：ES6在Class类里新增了类似this的关键字super。同this总是指向当前函数所在的对象不同，super关键字总是指向当前函数所在对象的原型对象。</li><li>在Object原型上新增is()方法，修复了‘===’ 无法比较NaN</li><li>新增assign()方法，用于对象新增属性或者对象的合并。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">let obj1 = &#123;a: <span class="hljs-number">1</span>, b:<span class="hljs-number">2</span> &#125;<br>let obj2 = &#123;c: <span class="hljs-number">3</span>, d: <span class="hljs-number">4</span> &#125;<br>Object.assign(obj1, obj2) <span class="hljs-comment">/// &#123; a:1,b:2,c:3,d:4 &#125;</span><br></code></pre></td></tr></table></figure><code>Object.assign(target, ...sources)</code><br>将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。<br>target是目标对象，将sources源对象分配到该目标对象中。</li><li>在Object原型上新增了getPrototypeOf()和setPrototypeOf()方法，用来获取或设置当前对象的prototype对象。</li><li>在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组。</li></ul><h4 id="六、对Function函数类型做的常用升级优化"><a href="#六、对Function函数类型做的常用升级优化" class="headerlink" title="六、对Function函数类型做的常用升级优化"></a>六、对Function函数类型做的常用升级优化</h4><ul><li>箭头函数<br>改变了this的指向，为函数定义时所在的对象，而不是执行时。</li><li>函数默认赋值<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">(a = 1, b)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://mp.weixin.qq.com/s/EzDHz5_SVUmyD0YUIAC9cw" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Proxy实现简易的vue双向数据绑定</title>
    <link href="/my-hexo-blog/2021/05/21/%E4%BD%BF%E7%94%A8Proxy%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/my-hexo-blog/2021/05/21/%E4%BD%BF%E7%94%A8Proxy%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>在实现vue双向数据绑定之前，先了解Proxy相关的概念和用法</p><h3 id="proxy概念"><a href="#proxy概念" class="headerlink" title="proxy概念"></a>proxy概念</h3><p><code>Proxy</code> 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。</p><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul><li>handle<br>包含捕捉器（trap）的占位符对象，可译为处理器对象</li><li>traps<br>提供属性访问的方法。这类似于操作系统中捕获器的概念。</li><li>target<br>被 Proxy 代理虚拟化的对象。<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><code>const p = new Proxy(target, handler)</code></li><li>target<br>要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li>handle<br>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li></ul><h3 id="使用proxy实现数据劫持"><a href="#使用proxy实现数据劫持" class="headerlink" title="使用proxy实现数据劫持"></a>使用proxy实现数据劫持</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = &#123;<br>    name: YoLinDeng,<br>    height: <span class="hljs-string">'176cm'</span><br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, &#123;<br>    <span class="hljs-keyword">get</span>(target, prop) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments)<br>    &#125;,<br>    <span class="hljs-keyword">set</span>(target, prop, newValue) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(...arguments)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="关于vue中数据响应式的原理"><a href="#关于vue中数据响应式的原理" class="headerlink" title="关于vue中数据响应式的原理"></a>关于vue中数据响应式的原理</h3><h4 id="对数据进行侦测"><a href="#对数据进行侦测" class="headerlink" title="对数据进行侦测"></a>对数据进行侦测</h4><ul><li>在vue2.X中，实现一个<code>observe</code>类，对于对象数据，通过<code>Object.defineProperty</code>来劫持对象的属性，实现<code>getter</code>和<code>setter</code>方法，这样就可以在getter的时候知道谁（订阅者）读取了数据，即谁依赖了当前的数据，将它通过<code>Dep类</code>（订阅器）收集统一管理，在setter的时候调用Dep类中的<code>notify</code>方法通知所以相关的订阅者进行更新视图。如果对象的属性也是一个对象的话，则需要递归调用<code>observe</code>进行处理。</li><li>对于数组则需要另外处理，通过实现一个拦截器类，并将它挂载到数组数据的原型上，当调用<code>push/pop/shift/unshift/splice/sort/reverse</code>修改数组数据时候，相当于调用的是拦截器中重新定义的方法，这样在拦截器中就可以侦测到数据改变了，并通知订阅者更新视图。</li><li>vue3中使用Proxy替代了Object.defineProperty，优点在于可以直接监听对象而非属性、可以直接监听数组的变化、多达13种拦截方法。缺点是兼容性还不够好。Proxy作为新标准将受到浏览器厂商重点持续的性能优化。<h4 id="对模板字符串进行编译"><a href="#对模板字符串进行编译" class="headerlink" title="对模板字符串进行编译"></a>对模板字符串进行编译</h4></li><li>实现Compile解析器类，将<code>template</code>中的模板字符串通过正则等方式进行处理生成对应的ast（抽象语法树），通过调用定义的不同钩子函数进行处理，包括开始标签（<code>start</code>）并判断是否自闭和以及解析属性、结束标签（<code>end</code>）、文本（<code>chars</code>）、注释（<code>comment</code>）</li><li>将通过html解析与文本解析的ast进行优化处理，在静态节点上打标记，为后面<code>dom-diff</code>算法中性能优化使用，即在对比前后vnode的时候会跳过静态节点不作对比。</li><li>最后根据处理好的ast生产<code>render</code>函数，在组件挂载的时候调用<code>render</code>函数就可以得到虚拟dom。<h4 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h4></li><li>vnode的类型包括注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点，<code>VNode</code>可以描述的多种节点类型，它们本质上都是<code>VNode</code>类的实例，只是在实例化的时候传入的属性参数不同而已。</li><li>通过将模板字符串编译生成虚拟dom并缓存起来，当数据发生变化时，通过对比变化前后虚拟dom，以变化后的虚拟dom为基准，更新旧的虚拟dom，使它和新的一样。把dom-diff过程叫做<code>patch</code>的过程，其主要做了三件事，分别是创建/删除/更新节点。</li><li>对于子节点的更新策略，vue中为了避免双重循环数据量大时候造成时间复杂度高带来的性能问题，而选择先从子节点数组中4个特殊位置进行对比，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。如果四种情况都没有找到相同的节点，则再通过循环方式查找。<h3 id="实现简易的vue双向数据绑定"><a href="#实现简易的vue双向数据绑定" class="headerlink" title="实现简易的vue双向数据绑定"></a>实现简易的vue双向数据绑定</h3>vue的双向数据绑定主要是指，数据变化更新视图变化，视图变化更新数据。</li><li><em>实现代码如下*</em><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width= , initial-scale=1.0"</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"myVue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;name&#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"test"</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;test&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    let vm = new vue(&#123;</span><br><span class="xml">      el: '#app',</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        name: 'YoLinDeng',</span><br><span class="xml">        message: '打篮球',</span><br><span class="xml">        test: '双向绑定数据'</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;)</span><br><span class="xml">    // console.log(vm._data)</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">vue</span> <span class="hljs-title">extends</span> <span class="hljs-title">EventTarget</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(option) &#123;<br>    <span class="hljs-keyword">super</span>()<br>    <span class="hljs-keyword">this</span>.option = option<br>    <span class="hljs-keyword">this</span>._data = <span class="hljs-keyword">this</span>.option.<span class="hljs-keyword">data</span><br>    <span class="hljs-keyword">this</span>.el = document.querySelector(<span class="hljs-keyword">this</span>.option.el)<br>    <span class="hljs-keyword">this</span>.compileNode(<span class="hljs-keyword">this</span>.el)<br>    <span class="hljs-keyword">this</span>.observe(<span class="hljs-keyword">this</span>._data)<br>  &#125;<br>  <span class="hljs-comment">// 实现监听器方法</span><br>  observe(<span class="hljs-keyword">data</span>) &#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>    <span class="hljs-comment">// 使用proxy代理，劫持数据</span><br>    <span class="hljs-keyword">this</span>._data = new Proxy(<span class="hljs-keyword">data</span>, &#123;<br>      <span class="hljs-keyword">set</span>(target, prop, newValue) &#123;<br>        <span class="hljs-comment">// 自定义事件</span><br>        let event = new CustomEvent(prop, &#123;<br>          detail: newValue<br>        &#125;)<br>        <span class="hljs-comment">// 发布自定义事件</span><br>        context.dispatchEvent(event) <br>        <span class="hljs-keyword">return</span> Reflect.<span class="hljs-keyword">set</span>(...arguments)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 实现解析器方法，解析模板</span><br>  compileNode(el) &#123;<br>    let child = el.childNodes<br>    let childArr = [...child]<br>    childArr.forEach(node =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span>) &#123;<br>        let text = node.textContent<br>        let reg = /\&#123;\&#123;\s*([^\s\&#123;\&#125;]+)\s*\&#125;\&#125;/g<br>        <span class="hljs-keyword">if</span> (reg.test(text)) &#123;<br>          let $<span class="hljs-number">1</span> = RegExp.$<span class="hljs-number">1</span><br>          <span class="hljs-keyword">this</span>._data[$<span class="hljs-number">1</span>] &amp;&amp; (node.textContent = text.replace(reg, <span class="hljs-keyword">this</span>._data[$<span class="hljs-number">1</span>]))<br>          <span class="hljs-comment">// 监听数据更改事件</span><br>          <span class="hljs-keyword">this</span>.addEventListener($<span class="hljs-number">1</span>, e =&gt; &#123;<br>            node.textContent = text.replace(reg, e.detail)<br>          &#125;)<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果是元素节点</span><br>        let attr = node.attributes<br>        <span class="hljs-comment">// 判断属性中是否含有v-model</span><br>        <span class="hljs-keyword">if</span> (attr.hasOwnProperty(<span class="hljs-string">'v-model'</span>)) &#123;<br>          let keyName = attr[<span class="hljs-string">'v-model'</span>].nodeValue<br>          node.value = <span class="hljs-keyword">this</span>._data[keyName]<br>          node.addEventListener(<span class="hljs-string">'input'</span>, e =&gt; &#123;<br>            <span class="hljs-keyword">this</span>._data[keyName] = node.value<br>          &#125;)<br>        &#125;<br>        <span class="hljs-comment">// 递归调用解析器方法</span><br>        <span class="hljs-keyword">this</span>.compileNode(node)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写防抖与节流函数</title>
    <link href="/my-hexo-blog/2021/05/21/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/"/>
    <url>/my-hexo-blog/2021/05/21/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>我们经常会绑定一些持续触发的事件，比如resize、scroll、mousemove等等，如果事件调用无限制，会加重浏览器负担，导致用户体验差，我们可以使用debounce(防抖)和throttle(节流)的方式来减少频繁的调用，同时也不会影响实际的效果。</p><h3 id="防抖的概念"><a href="#防抖的概念" class="headerlink" title="防抖的概念"></a>防抖的概念</h3><p>触发事件后n秒后才执行函数，如果在n秒内触发了事件，则会重新计算函数执行时间<br>防抖函数可以分为立即执行，和非立即执行两个版本</p><ul><li><p>非立即执行版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        timer &amp;&amp; clearTimeout(timer)<br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            fn.apply(context, args)   <br>        &#125;, wait)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此函数一开始不会马上执行，而是等到用户操作结束之后等待wait秒后才执行，如果在wait之内用户又触发了事件，则会重新计算</p></li><li><p>立即执行版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">const</span> now = !timer<br>        timer &amp;&amp; clearTimeout(timer)<br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            timer = <span class="hljs-literal">null</span><br>        &#125;, wait)<br>        <span class="hljs-keyword">if</span> (now) &#123;<br>            fn.apply(<span class="hljs-keyword">this</span>, args)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>立即执行就是触发事件后马上先执行一次，直到用户停止执行事件等待wait秒后再执行一次</p></li></ul><p>我们可以将两种版本合并成一种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc </span>函数防抖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>wait 延迟执行毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>immediate true 表立即执行，false 表示非立即执行</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait, immediate</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        timer &amp;&amp; clearTimeout(timer)<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-keyword">const</span> now = !timer<br>            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                timer = <span class="hljs-literal">null</span><br>            &#125;, wait)<br>            now &amp;&amp; fn.apply(context, args)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                fn.apply(context, args)<br>            &#125;, wait)<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="节流的概念"><a href="#节流的概念" class="headerlink" title="节流的概念"></a>节流的概念</h3><p>连续触发事件但在n秒内只执行一次函数<br>对于节流有时间戳和定时器两种版本</p><ul><li>时间戳版本<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> prev = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now()<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>            fn.apply(context, args)<br>            prev = now<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在持续触发事件的过程中，函数会立即执行，用户在wait秒内不管执行多少次事件，都会等待wait秒后再执行。</li><li>定时器版本<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (!timer) &#123;<br>            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                timer = <span class="hljs-literal">null</span><br>                fn.apply(context, args)<br>            &#125;, wait)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在触发事件的过程中，不会立即执行，并且每wait秒执行一次，在停止触发事件后还会再执行一次。</li></ul><p>时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p><p>将两种方式合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc </span>函数节流</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>wait 延迟执行毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>type 1 表时间戳版，2 表定时器版</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait, type</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (type === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">var</span> prev = <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span><br>    &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>         <span class="hljs-keyword">if</span> (type === <span class="hljs-number">2</span>) &#123;<br>             <span class="hljs-keyword">if</span> (!timer) &#123;<br>                 timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                   timer = <span class="hljs-literal">null</span><br>                   fn.apply(context, args) <br>                 &#125;, wait)<br>             &#125;<br>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">const</span> now = <span class="hljs-built_in">Date</span>.now()<br>            <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>                fn.apply(context, args)<br>                prev = now<br>            &#125;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><a href="https://juejin.im/post/6844903651278848014" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react中实现导航栏状态与地址绑定</title>
    <link href="/my-hexo-blog/2021/05/21/react%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%8A%B6%E6%80%81%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A/"/>
    <url>/my-hexo-blog/2021/05/21/react%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%8A%B6%E6%80%81%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="一、项目初始化"><a href="#一、项目初始化" class="headerlink" title="一、项目初始化"></a>一、项目初始化</h3><h4 id="1-安装与运行"><a href="#1-安装与运行" class="headerlink" title="1. 安装与运行"></a>1. 安装与运行</h4><p>构建项目：<code>yarn create react-app my-app</code><br>启动：<code>yarn start</code><br>当然也可以使用npm：</p><ul><li>全局安装：<code>npm install -g create-react-app</code></li><li>构建项目：<code>npx create-react-app my-app</code></li><li>启动：<code>npm start</code></li></ul><h3 id="2-安装路由依赖"><a href="#2-安装路由依赖" class="headerlink" title="2.安装路由依赖"></a>2.安装路由依赖</h3><p>在项目中执行：<code>npm install react-router-dom --save</code></p><h3 id="3-在App-js中引入router"><a href="#3-在App-js中引入router" class="headerlink" title="3.在App.js中引入router"></a>3.在App.js中引入router</h3><p>由于简单演示，就不单独对router进行封装了。<br>安装完成后，我们在App.js中引入路由相关组件<code>BrowserRouter</code>、<code>Route</code>、<code>Switch</code>、<code>Redirect</code><br>在顶部引入：<code>import { BrowserRouter as Router, Route, Switch, Redirect } from &#39;react-router-dom&#39;</code><br>详细代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/home'</span><br><span class="hljs-keyword">import</span> Study <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/study'</span><br><span class="hljs-keyword">import</span> Type <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/type'</span><br><span class="hljs-keyword">import</span> Label <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/label'</span><br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/about'</span><br><span class="hljs-keyword">import</span> &#123; Layout &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span><br><span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Header'</span><br><span class="hljs-keyword">import</span> Persional <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Persional'</span><br><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Switch, Redirect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span><br><span class="hljs-keyword">const</span> &#123; Footer, Content, Sider&#125; = Layout;<br><span class="hljs-comment">// 导入子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">"App"</span> &gt;<br>        &lt;Layout&gt;<br>          &lt;Sider&gt;<br>            &lt;Persional /&gt;<br>          &lt;<span class="hljs-regexp">/Sider&gt;</span><br><span class="hljs-regexp">          &lt;Content&gt;</span><br><span class="hljs-regexp">            &lt;Router&gt;</span><br><span class="hljs-regexp">              &lt;Header /</span>&gt;<br>              &lt;Switch&gt;<br>                &lt;Route path=<span class="hljs-string">"/home"</span> exact component=&#123;Home&#125;&gt;&lt;<span class="hljs-regexp">/Route&gt;</span><br><span class="hljs-regexp">                &lt;Route path="/</span>study<span class="hljs-string">" component=&#123;Study&#125;&gt;&lt;/Route&gt;</span><br><span class="hljs-string">                &lt;Route path="</span>/type<span class="hljs-string">" component=&#123;Type&#125;&gt;&lt;/Route&gt;</span><br><span class="hljs-string">                &lt;Route path="</span>/label<span class="hljs-string">" component=&#123;Label&#125;&gt;&lt;/Route&gt;</span><br><span class="hljs-string">                &lt;Route path="</span>/about<span class="hljs-string">" component=&#123;About&#125;&gt;&lt;/Route&gt;</span><br><span class="hljs-string">                &lt;Redirect from="</span><span class="hljs-comment">/*" to="/home"&gt;&lt;/Redirect&gt;</span><br><span class="hljs-comment">              &lt;/Switch&gt;</span><br><span class="hljs-comment">              &lt;Footer&gt;Footer&lt;/Footer&gt;</span><br><span class="hljs-comment">            &lt;/Router&gt;</span><br><span class="hljs-comment">          &lt;/Content&gt; </span><br><span class="hljs-comment">        &lt;/Layout&gt;</span><br><span class="hljs-comment">      &lt;/div&gt;</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">export default App;</span><br></code></pre></td></tr></table></figure><p>这里用到了antd的<code>Layout</code>布局组件进行布局<br>首先我们将我们的视图组件引入进来（<code>import Home from &#39;@/views/home&#39;</code>），并在Route标签中配置：（以home为例）<code>&lt;Route path=&quot;/home&quot; exact component={Home}&gt;&lt;/Route&gt;</code></p><h3 id="4-编写Header头部导航组件"><a href="#4-编写Header头部导航组件" class="headerlink" title="4.编写Header头部导航组件"></a>4.编写Header头部导航组件</h3><p>在components目录下新建Header目录，并在其目录下新建index.js及index.scss文件，这里使用scss进行编写。<br>安装命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> --save-dev <br>npm install sass-loader --save-dev<br></code></pre></td></tr></table></figure><p>为了实现导航栏状态与地址联动，关键是要实现组件初始化时的处理逻辑，也就是组件挂载的时候，即在生命周期函数<code>componentDidMount</code>中实现。<br>要实现以下两点：</p><ul><li>修改当前地址对应导航栏状态</li><li>监听浏览器前进后退，即监听history对象<br>关键代码如下：<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mel">componentDidMount = () =&gt; &#123;<br>    let moren = this.props.location.pathname<br>    let <span class="hljs-keyword">text</span> = moren.<span class="hljs-keyword">substring</span>(moren.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>, moren.length)<br>    <span class="hljs-comment">// 当访问的目录不在这个数组里时候，当前状态是home，即重定向到home页面</span><br>    ![<span class="hljs-string">'home'</span>, <span class="hljs-string">'study'</span>, <span class="hljs-string">'type'</span>, <span class="hljs-string">'label'</span>, <span class="hljs-string">'about'</span>, <span class="hljs-string">'search'</span>].includes(<span class="hljs-keyword">text</span>) &amp;&amp; (<span class="hljs-keyword">text</span> = <span class="hljs-string">'home'</span>)<br>    this.<span class="hljs-keyword">setState</span>(&#123;<br>      current: <span class="hljs-keyword">text</span><br>    &#125;)<br>    <span class="hljs-comment">// 监听history变化</span><br>    history.listen((<span class="hljs-keyword">event</span>) =&gt; &#123;<br>      let test = <span class="hljs-keyword">event</span>.pathname<br>      let <span class="hljs-keyword">text</span> = test.<span class="hljs-keyword">substring</span>(test.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>, test.length)<br>      this.<span class="hljs-keyword">setState</span>(&#123;<br>        current: <span class="hljs-keyword">text</span><br>      &#125;)<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure>组件完整代码如下：<br>index.js:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125;  <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<br><span class="hljs-keyword">import</span> &#123; Row, Col, Menu  &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span>;<br><span class="hljs-keyword">import</span> &#123; Link, withRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span><br><span class="hljs-keyword">import</span> &#123; HomeOutlined, FolderOpenOutlined, AppstoreOutlined, PushpinOutlined, UserOutlined, SearchOutlined &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@ant-design/icons'</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">'./index.scss'</span><br><span class="hljs-keyword">import</span> &#123; createBrowserHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'history'</span>;<br><span class="hljs-keyword">const</span> history = createBrowserHistory() <span class="hljs-comment">// history模式</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      logo: <span class="hljs-string">''</span>,<br>      current: <span class="hljs-string">'home'</span><br>    &#125;<br>  &#125;<br>  handleClick = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">this</span>.setState(&#123; <span class="hljs-attr">current</span>: e.key &#125;);<br>  &#125;<br>  componentDidMount = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> moren = <span class="hljs-keyword">this</span>.props.location.pathname<br>    <span class="hljs-keyword">let</span> text = moren.substring(moren.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>, moren.length)<br>    ![<span class="hljs-string">'home'</span>, <span class="hljs-string">'study'</span>, <span class="hljs-string">'type'</span>, <span class="hljs-string">'label'</span>, <span class="hljs-string">'about'</span>, <span class="hljs-string">'search'</span>].includes(text) &amp;&amp; (text = <span class="hljs-string">'home'</span>)<br>    <span class="hljs-keyword">this</span>.setState(&#123;<br>      current: text<br>    &#125;)<br>    history.listen(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> test = event.pathname<br>      <span class="hljs-keyword">let</span> text = test.substring(test.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>, test.length)<br>      <span class="hljs-keyword">this</span>.setState(&#123;<br>        current: text<br>      &#125;)<br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">const</span> &#123; current &#125; = <span class="hljs-keyword">this</span>.state;<br>    <span class="hljs-keyword">return</span>(<br>      &lt;div className=<span class="hljs-string">"header-wrapper"</span>&gt;<br>         &lt;Row&gt;<br>          &lt;Col span=&#123;<span class="hljs-number">18</span>&#125; push=&#123;<span class="hljs-number">6</span>&#125; className=<span class="hljs-string">"right-box"</span>&gt;<br>            &lt;Menu onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125; selectedKeys=&#123;[current]&#125; mode=<span class="hljs-string">"horizontal"</span>&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"home"</span> icon=&#123;&lt;HomeOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/home"</span>&gt;首页&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"study"</span> icon=&#123;&lt;FolderOpenOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/study"</span>&gt;学习&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"type"</span> icon=&#123;&lt;AppstoreOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/type"</span>&gt;分类&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"label"</span> icon=&#123;&lt;PushpinOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/label"</span>&gt;标签&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"about"</span> icon=&#123;&lt;UserOutlined /&gt;&#125;&gt;<br>                &lt;Link to=<span class="hljs-string">"/about"</span>&gt;关于&lt;<span class="hljs-regexp">/Link&gt;</span><br><span class="hljs-regexp">              &lt;/</span>Menu.Item&gt;<br>              &lt;Menu.Item key=<span class="hljs-string">"search"</span> icon=&#123;&lt;SearchOutlined /&gt;&#125;&gt;<br>                搜索<br>              &lt;<span class="hljs-regexp">/Menu.Item&gt;</span><br><span class="hljs-regexp">            &lt;/</span>Menu&gt;<br>          &lt;<span class="hljs-regexp">/Col&gt;</span><br><span class="hljs-regexp">          &lt;Col span=&#123;6&#125; pull=&#123;18&#125; className="left-box"&gt;</span><br><span class="hljs-regexp">            &lt;strong className="logo-name"&gt;Deng&lt;/</span>strong&gt;<br>          &lt;<span class="hljs-regexp">/Col&gt;</span><br><span class="hljs-regexp">        &lt;/</span>Row&gt;<br>      &lt;<span class="hljs-regexp">/div&gt;</span><br><span class="hljs-regexp">    )</span><br><span class="hljs-regexp">  &#125;</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp">export default withRouter(Header)</span><br></code></pre></td></tr></table></figure>注意：为了能够拿到<code>this.props.location.pathname</code>,需要使用<code>withRouter</code>处理组件，并把Header组件放在<code>BrowserRouter</code>标签中。<br>这样就能够实现导航栏状态与地址绑定了</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sass常用方法</title>
    <link href="/my-hexo-blog/2021/05/21/sass%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/my-hexo-blog/2021/05/21/sass%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是sass"><a href="#一、什么是sass" class="headerlink" title="一、什么是sass"></a>一、什么是sass</h3><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，提供了许多便利的写法，大大提高的开发效率。下面总结了SASS的主要用法，想要了解更多可以查阅<a href="https://www.sass.hk/docs/" target="_blank" rel="noopener">文档</a></p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><p>1、由于sass依赖于Ruby，因此需要先<a href="http://www.ruby-lang.org/zh_cn/downloads/" target="_blank" rel="noopener">安装Ruby</a>，然后执行<code>gem install sass</code><br>2、若在vue-cli或react-create-app中使用，在项目中安装依赖：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> --save-dev<br>npm install sass-loader --save-dev<br></code></pre></td></tr></table></figure><h3 id="三、基础用法"><a href="#三、基础用法" class="headerlink" title="三、基础用法"></a>三、基础用法</h3><h4 id="3-1-变量"><a href="#3-1-变量" class="headerlink" title="3.1 变量"></a>3.1 变量</h4><p>SASS允许使用变量，所有变量以$开头</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$color</span>: <span class="hljs-number">#ccc</span>;<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果变量需要镶嵌在属性中之中，就必须需要写在#{}之中</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$side</span>: right;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$side</span>&#125;-radius: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-计算能力"><a href="#3-2-计算能力" class="headerlink" title="3.2 计算能力"></a>3.2 计算能力</h4><p>SASS允许在代码中使用算式</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$var: <span class="hljs-number">10</span>px;<br>div &#123;<br>  width：(<span class="hljs-number">20</span>px/<span class="hljs-number">2</span>);<br>  top: <span class="hljs-number">10</span>px + <span class="hljs-number">20</span>px;<br>  left: $var * <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-嵌套能力"><a href="#3-3-嵌套能力" class="headerlink" title="3.3 嵌套能力"></a>3.3 嵌套能力</h4><p>一般我们写多个选择器时，一般这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span> &#123;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用sass可以写成：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-class">div </span>&#123;<br>  <span class="hljs-class">h2 </span>&#123;<br><span class="hljs-symbol">    border:</span><span class="hljs-number">1</span>px solid <span class="hljs-meta">#ccc;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性也可以嵌套,比如font-size属性，可以写成</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">div</span> &#123;<br>  font：&#123;<br>    <span class="hljs-keyword">size</span>：<span class="hljs-number">18</span>px;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用&amp;引用父元素</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">div</span> &#123;<br> &amp;::<span class="hljs-keyword">after</span> &#123;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、代码重用"><a href="#四、代码重用" class="headerlink" title="四、代码重用"></a>四、代码重用</h3><h4 id="4-1-继承"><a href="#4-1-继承" class="headerlink" title="4.1 继承"></a>4.1 继承</h4><p>SASS允许一个选择器，继承另一个选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class1</span> &#123;<br>   <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要继承class1，需要使用@extend命令</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.class2</span> &#123;<br>  <span class="hljs-keyword">@extend</span> .class1;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-Mixin-混合"><a href="#4-2-Mixin-混合" class="headerlink" title="4.2 Mixin(混合)"></a>4.2 Mixin(混合)</h4><p>使用@mixin声明代码块，达到重用代码块的作用，在需要用的地方使用@include调用</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">mixin</span> right &#123;<br> margin-right: <span class="hljs-number">20</span>px;<br>&#125;<br>div &#123;<br>  @include right;<br>&#125;<br></code></pre></td></tr></table></figure><p>@minxin可以设置参数以及参数默认值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@<span class="hljs-keyword">mixin</span> left($value: <span class="hljs-number">20</span>px) &#123;<br>  margin-left: $value;<br>&#125;<br>div &#123;<br>  @include left(<span class="hljs-number">10</span>px)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-颜色函数"><a href="#4-3-颜色函数" class="headerlink" title="4.3 颜色函数"></a>4.3 颜色函数</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lighten</span><span class="hljs-params">(<span class="hljs-number">#cc3</span>, <span class="hljs-number">10%</span>)</span></span> <span class="hljs-comment">// #d6d65c  </span><br><span class="hljs-function"><span class="hljs-title">darken</span><span class="hljs-params">(<span class="hljs-number">#cc3</span>, <span class="hljs-number">10%</span>)</span></span> <span class="hljs-comment">// #a3a329  </span><br><span class="hljs-function"><span class="hljs-title">grayscale</span><span class="hljs-params">(<span class="hljs-number">#cc3</span>)</span></span> <span class="hljs-comment">// #808080  </span><br><span class="hljs-function"><span class="hljs-title">complement</span><span class="hljs-params">(<span class="hljs-number">#cc3</span>)</span></span> <span class="hljs-comment">// #33c</span><br></code></pre></td></tr></table></figure><h4 id="4-4-引入文件"><a href="#4-4-引入文件" class="headerlink" title="4.4 引入文件"></a>4.4 引入文件</h4><p>使用@import命令，用来引入外部文件<br>@import 文件路径</p><h3 id="五、进阶用法"><a href="#五、进阶用法" class="headerlink" title="五、进阶用法"></a>五、进阶用法</h3><h4 id="5-1-条件语句"><a href="#5-1-条件语句" class="headerlink" title="5.1 条件语句"></a>5.1 条件语句</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-variable">@if</span> computed($width) &gt; <span class="hljs-number">10</span> &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span> &#125;<br>  <span class="hljs-variable">@if</span> computed($height) &gt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;<br>  &#125; <span class="hljs-variable">@else</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-循环语句"><a href="#5-2-循环语句" class="headerlink" title="5.2 循环语句"></a>5.2 循环语句</h4><p>for循环:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> to <span class="hljs-number">10</span> &#123;  <br> <span class="hljs-selector-class">.content-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123;  <br>    <span class="hljs-attribute">width</span>: #&#123;<span class="hljs-variable">$i</span>&#125;px;  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>while循环:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">　<span class="hljs-variable">$x</span>: <span class="hljs-number">6</span>;<br>　　<span class="hljs-keyword">@while</span> <span class="hljs-variable">$x</span> &gt; <span class="hljs-number">0</span> &#123;  <br>　　　　<span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$x</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-variable">$x</span> + <span class="hljs-number">10px</span>; &#125;  <br>　　　　<span class="hljs-variable">$x</span>: <span class="hljs-variable">$x</span> - <span class="hljs-number">1</span>;  <br>　　&#125;z<br></code></pre></td></tr></table></figure><p>each:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$member</span> in a, b, c, d &#123;  <br> .#&#123;<span class="hljs-variable">$member</span>&#125; &#123;  <br>    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">"/image/#&#123;$member&#125;.jpg"</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">　<span class="hljs-keyword">@function</span> count($n) &#123;  <br>　　　　<span class="hljs-keyword">@return</span> $n + <span class="hljs-number">1</span>;  <br>　　&#125;<br><br>　　<span class="hljs-selector-tag">div</span> &#123;  <br>　　　　<span class="hljs-attribute">width</span>: <span class="hljs-built_in">count</span>(<span class="hljs-number">5px</span>);  <br>　　&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-cli中使用svgIcon</title>
    <link href="/my-hexo-blog/2021/05/21/vue-cli%E4%B8%AD%E4%BD%BF%E7%94%A8svgIcon/"/>
    <url>/my-hexo-blog/2021/05/21/vue-cli%E4%B8%AD%E4%BD%BF%E7%94%A8svgIcon/</url>
    
    <content type="html"><![CDATA[<h3 id="一、安装依赖包"><a href="#一、安装依赖包" class="headerlink" title="一、安装依赖包"></a>一、安装依赖包</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npm install svg-sprite-loader -D<br>或者<br>yarn <span class="hljs-keyword">add</span><span class="bash"> svg-sprite-loader -D</span><br></code></pre></td></tr></table></figure><h3 id="二、配置vue-config-js文件"><a href="#二、配置vue-config-js文件" class="headerlink" title="二、配置vue.config.js文件"></a>二、配置vue.config.js文件</h3><p>在顶部写入</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span> <span class="hljs-params">(dir)</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">path</span>.join(__dirname, dir)<br>&#125;<br></code></pre></td></tr></table></figure><p>在chainWebpack中增加下列配置</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">chainWebpack</span> (config) &#123;<br>    <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.rule</span>(<span class="hljs-string">'svg'</span>)<br>      <span class="hljs-selector-class">.exclude</span><span class="hljs-selector-class">.add</span>(resolve(<span class="hljs-string">'src/icons'</span>))<br>    <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.rule</span>(<span class="hljs-string">'icons'</span>)<br>      <span class="hljs-selector-class">.test</span>(/\.svg$/)<br>      <span class="hljs-selector-class">.include</span><span class="hljs-selector-class">.add</span>(resolve(<span class="hljs-string">'./src/icons'</span>))<span class="hljs-selector-class">.end</span>()<br>      <span class="hljs-selector-class">.use</span>(<span class="hljs-string">'svg-sprite-loader'</span>)<br>      <span class="hljs-selector-class">.loader</span>(<span class="hljs-string">'svg-sprite-loader'</span>)<br>      <span class="hljs-selector-class">.options</span>(&#123; <span class="hljs-attribute">symbolId</span>: <span class="hljs-string">'icon-[name]'</span> &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="三、实现SvgIcon组件"><a href="#三、实现SvgIcon组件" class="headerlink" title="三、实现SvgIcon组件"></a>三、实现SvgIcon组件</h3><p>组件结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"svgClass"</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">"$listeners"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">:xlink:href</span>=<span class="hljs-string">"iconName"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br>    iconClass: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="actionscript">      required: <span class="hljs-literal">true</span></span><br>    &#125;,<br>    className: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="actionscript">      <span class="hljs-keyword">default</span>: <span class="hljs-string">''</span></span><br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    iconName () &#123;<br><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-string">`#icon-<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.iconClass&#125;</span>`</span></span><br>    &#125;,<br>    svgClass () &#123;<br><span class="actionscript">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.className) &#123;</span><br><span class="actionscript">        <span class="hljs-keyword">return</span> <span class="hljs-string">'svg-icon '</span> + <span class="hljs-keyword">this</span>.className</span><br><span class="actionscript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="actionscript">        <span class="hljs-keyword">return</span> <span class="hljs-string">'svg-icon'</span></span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.svg-icon</span> &#123;</span><br>  width: 1em;<br>  height: 1em;<br><span class="css">  <span class="hljs-selector-tag">vertical-align</span>: <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.15em</span>;</span><br>  fill: currentColor;<br>  overflow: hidden;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="四、根目录下创建icons-svg目录"><a href="#四、根目录下创建icons-svg目录" class="headerlink" title="四、根目录下创建icons/svg目录"></a>四、根目录下创建icons/svg目录</h3><p> 用于存放我们所需要用的svg文件</p><h3 id="五、新建plugins目录及index-js文件"><a href="#五、新建plugins目录及index-js文件" class="headerlink" title="五、新建plugins目录及index.js文件"></a>五、新建plugins目录及index.js文件</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> SvgIcon <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/SvgIcon'</span><br><br><span class="hljs-keyword">const</span> req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">'@/icons/svg'</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.svg$/</span>)<br>req.keys().<span class="hljs-keyword">map</span>(req)<br><br>Vue.component(<span class="hljs-string">'svg-icon'</span>, SvgIcon)<br></code></pre></td></tr></table></figure><p>其作用是在Vue实例上创建SvgIcon组件，其中require.context的作用是获取一个特定的上下文,遍历文件夹中的指定文件，主要用来实现自动化导入模块</p><ul><li>最后在main.js中引入plugins, <code>import &#39;@/plugins&#39;</code></li></ul><h3 id="六、SvgIcon-组件的使用"><a href="#六、SvgIcon-组件的使用" class="headerlink" title="六、SvgIcon 组件的使用"></a>六、SvgIcon 组件的使用</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cs">&lt;svg-icon icon-<span class="hljs-keyword">class</span>=<span class="hljs-string">"icon-name"</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">"down"</span>&gt;&lt;/svg-icon&gt;<br></code></pre></td></tr></table></figure><p>其中icon-class为svg文件名， class为类名</p>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
      <tag>vue</tag>
      
      <tag>组件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中组件通信之findComponents</title>
    <link href="/my-hexo-blog/2021/05/21/vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8BfindComponents/"/>
    <url>/my-hexo-blog/2021/05/21/vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B9%8BfindComponents/</url>
    
    <content type="html"><![CDATA[<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 向上查找组件 context为当前组件上下文对象，componentName为组件名</span><br><span class="hljs-keyword">const</span> findUpwardComponent = (context, componentName) =&gt; &#123;<br>    let <span class="hljs-keyword">parent</span> = context.$parent<br>    let name = <span class="hljs-keyword">parent</span>.$options.name<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">parent</span> &amp;&amp; (!name || !name.includes(componentName))) &#123;<br>        <span class="hljs-keyword">parent</span> = <span class="hljs-keyword">parent</span>.$parent<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">parent</span>) name = <span class="hljs-keyword">parent</span>.$options.name<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">parent</span><br>&#125;<br><br><span class="hljs-comment">// 查找兄弟组件</span><br><span class="hljs-keyword">const</span> findBrotherComponents = (ctx, componentName, exceptMe = <span class="hljs-keyword">true</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> $brothers = ctx.$parent.$children.filter(item =&gt; &#123;<br>        <span class="hljs-keyword">return</span> item.$options.name &amp;&amp; item.$options.name.includes(componentName)<br>    &#125;)<br>    <span class="hljs-keyword">const</span> index = $brothers.findIndex(item =&gt; item._uid === ctx._uid)<br>    <span class="hljs-keyword">if</span> (exceptMe &amp;&amp; index &gt; <span class="hljs-number">-1</span>) $brothers.splice(index, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> $brothers<br>&#125;<br><br><span class="hljs-comment">// 向下查找</span><br><span class="hljs-keyword">const</span> findDownwardComponent = (context, componentName) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> $children = context.$children<br>    let bean = <span class="hljs-keyword">null</span><br>    <span class="hljs-keyword">if</span> ($children.length) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child of $children) &#123;<br>            <span class="hljs-keyword">const</span> name = child.$options.name<br>            <span class="hljs-keyword">if</span> (name &amp;&amp; name.includes(componentName)) &#123;<br>                bean = child<br>                <span class="hljs-keyword">break</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                bean = findDownwardComponent(child, componentName)<br>                <span class="hljs-keyword">if</span> (bean) <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scss实现retina屏1px边框</title>
    <link href="/my-hexo-blog/2021/05/21/scss%E5%AE%9E%E7%8E%B0retina%E5%B1%8F1px%E8%BE%B9%E6%A1%86/"/>
    <url>/my-hexo-blog/2021/05/21/scss%E5%AE%9E%E7%8E%B0retina%E5%B1%8F1px%E8%BE%B9%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br><span class="hljs-comment">// =======================</span><br><span class="hljs-comment">//  用法：  </span><br><span class="hljs-comment">//  @include retina-border(1,1,1,1);</span><br><span class="hljs-comment">//  数值 代表 各 边框的宽度  上右下左</span><br><span class="hljs-comment">// =======================</span><br><br><br><span class="hljs-keyword">@mixin</span> _border-scale(<span class="hljs-variable">$dpr</span>) &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span> * <span class="hljs-variable">$dpr</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span> * <span class="hljs-variable">$dpr</span>;<br><br>  -webkit-<span class="hljs-attribute">transform</span>: scale(<span class="hljs-number">1</span> / <span class="hljs-variable">$dpr</span>);<br>  -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">transform</span>: scale(<span class="hljs-number">1</span> / <span class="hljs-variable">$dpr</span>);<br>  <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> _border-base() &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">pointer-events</span>: none;<br>&#125;<br><br><span class="hljs-keyword">@mixin</span> retina-border(<span class="hljs-variable">$top</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">$right</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">$bottom</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">$left</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">$cor</span>: <span class="hljs-number">#000000</span>) &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br><br>  &amp;<span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">border-top</span>: #&#123;<span class="hljs-variable">$top</span>&#125;px solid <span class="hljs-variable">$cor</span>;<br>    <span class="hljs-attribute">border-right</span>: #&#123;<span class="hljs-variable">$right</span>&#125;px solid <span class="hljs-variable">$cor</span>;<br>    <span class="hljs-attribute">border-bottom</span>: #&#123;<span class="hljs-variable">$bottom</span>&#125;px solid <span class="hljs-variable">$cor</span>;<br>    <span class="hljs-attribute">border-left</span>: #&#123;<span class="hljs-variable">$left</span>&#125;px solid <span class="hljs-variable">$cor</span>;<br><br>    <span class="hljs-keyword">@include</span> _border-base();<br><br>    <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">@include</span> _border-scale(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">1.5</span>) &#123;<br>      <span class="hljs-keyword">@include</span> _border-scale(<span class="hljs-number">1.5</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">@include</span> _border-scale(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-keyword">@include</span> _border-scale(<span class="hljs-number">3</span>);<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的git命令操作</title>
    <link href="/my-hexo-blog/2021/05/21/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/my-hexo-blog/2021/05/21/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用git之前需要先安装它<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载git</a></p><p>以windows系统为例子，安装完成后，鼠标右键点击桌面，出现Git Bash Here和 Git GUI Here 说明安装成功。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">""</span>  <br>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">""</span><br></code></pre></td></tr></table></figure><h4 id="克隆远程仓库与代码提交"><a href="#克隆远程仓库与代码提交" class="headerlink" title="克隆远程仓库与代码提交"></a>克隆远程仓库与代码提交</h4><p>1、在github上新建项目new repositories后，复制https地址或ssh<br>2、在相应的目录，右键选择 git bash here 进入 git操作界面<br>3、输入 git clone “复制的仓库地址”<br>4、对仓库内存进行修改<br>5、cd 文件夹名称（进入文件夹）<br>6、git add .（或git add –all）<br>7、git commit -m “需要写的提交说明”<br>8、git push</p><p>其中git add . 与git add –all的区别是:<br>（1）.git add –all可以提交未跟踪、修改和删除文件。<br>（2）.git add .可以提交未跟踪和修改文件，但是不处理删除文件。</p><h4 id="创建新的分支"><a href="#创建新的分支" class="headerlink" title="创建新的分支"></a>创建新的分支</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b </span>分支名称 （创建并切换至该分支）<br></code></pre></td></tr></table></figure><p>注：新建的分支第一次push： git push -u origin 分支名</p><h4 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git branch<span class="hljs-comment"> // 本地分支</span><br>git branch -<span class="hljs-keyword">a</span><span class="hljs-comment"> // 所以分支,包括线上</span><br></code></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">git branch -D 分支名 <span class="hljs-comment">// 删除本地分支</span><br>git <span class="hljs-keyword">push</span> origin --<span class="hljs-keyword">delete</span> 分支名 <span class="hljs-comment">// 删除远程分支</span><br></code></pre></td></tr></table></figure><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> checkout 分支名<br></code></pre></td></tr></table></figure><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>、先切换到<span class="hljs-literal">master</span>分支 git checkout <span class="hljs-literal">master</span><br><br><span class="hljs-number">2</span>、拉取最新代码 git pull<br><br><span class="hljs-number">3</span>、切换到自己的分支 并将<span class="hljs-literal">master</span>分支与自己的分支合并，然后解决冲突<br><br>git merge <span class="hljs-keyword">master</span> <span class="hljs-title">解决完冲突后，git</span> add --all git commit -m<span class="hljs-string">""</span><br><br>git fetch origin <span class="hljs-literal">master</span>// 虚拟的更新远程的<span class="hljs-literal">master</span><br><br>git merge origin/<span class="hljs-keyword">master</span> <span class="hljs-title">//合并远程master</span><br><br>git push 推到自己的远程分支<br><br><span class="hljs-number">4</span>、切换到 <span class="hljs-keyword">master</span> <span class="hljs-title">分支</span><br><span class="hljs-title"></span><br><span class="hljs-title">5</span>、将自己的分子合并到<span class="hljs-keyword">master</span> <span class="hljs-title">分支</span><br><span class="hljs-title"></span><br><span class="hljs-title">git</span> merge 分支名<br></code></pre></td></tr></table></figure><h4 id="跟踪到远程名字相同的分支"><a href="#跟踪到远程名字相同的分支" class="headerlink" title="跟踪到远程名字相同的分支"></a>跟踪到远程名字相同的分支</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/分支名 分支名<br></code></pre></td></tr></table></figure><h4 id="将更改加入暂存区"><a href="#将更改加入暂存区" class="headerlink" title="将更改加入暂存区"></a>将更改加入暂存区</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git stash <span class="hljs-built_in">save</span> <span class="hljs-string">"描述信息"</span><br><br>git stash list : 显示保存列表。<br><br>git stash <span class="hljs-built_in">pop</span>  恢复最近保存的记录并把恢复的记录从保存列表中删除<br></code></pre></td></tr></table></figure><h4 id="查看与生成公钥"><a href="#查看与生成公钥" class="headerlink" title="查看与生成公钥"></a>查看与生成公钥</h4><p>进入该目录并列出其中内容：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br><br><span class="hljs-keyword">ls</span><br><br>cat id_rsa.pub <span class="hljs-string">//</span> 查看公钥<br></code></pre></td></tr></table></figure><p>设置邮箱与用户名</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">""</span><br><br>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">""</span><br></code></pre></td></tr></table></figure><p>清理之前的公钥</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mkdir</span> <span class="hljs-string">key_backup</span><br><br><span class="hljs-attr">cp</span> <span class="hljs-string">id_rsa* key_backup</span><br><br><span class="hljs-attr">rm</span> <span class="hljs-string">id_rsa*</span><br></code></pre></td></tr></table></figure><p>生成</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ssh-keygen -t rsa -C <span class="hljs-string">"邮箱号"</span> <span class="hljs-comment">// C是大写</span><br></code></pre></td></tr></table></figure><p>查看</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">cat</span> <span class="hljs-selector-tag">id_rsa</span><span class="hljs-selector-class">.pub</span><br></code></pre></td></tr></table></figure><h4 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h4><p>查看版本</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">log</span> -<span class="hljs-built_in">num</span><span class="hljs-comment"> // num: 版本数量</span><br></code></pre></td></tr></table></figure><p>回滚到指定的版本</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">git reset --hard<span class="hljs-built_in"> id</span> //<span class="hljs-built_in"> id</span>: 版<span class="hljs-built_in">本id</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中实现倒计时组件与毫秒效果</title>
    <link href="/my-hexo-blog/2021/05/21/vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%AF%AB%E7%A7%92%E6%95%88%E6%9E%9C/"/>
    <url>/my-hexo-blog/2021/05/21/vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%AF%AB%E7%A7%92%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="时分秒倒计时组件"><a href="#时分秒倒计时组件" class="headerlink" title="时分秒倒计时组件"></a>时分秒倒计时组件</h3><h4 id="template"><a href="#template" class="headerlink" title="template"></a>template</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 倒计时组件 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"downTime-wrapper"</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 这里是显示还未结束时的内容，这里只是我这得布局，你可以随意。 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"time"</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"!isShow"</span>&gt;</span></span><br><span class="xml">      <span class="hljs-comment">&lt;!-- &lt;span class="hour"&gt;</span></span><span class="hljs-template-variable">&#123;&#123;myDay&#125;&#125;</span><span class="xml"><span class="hljs-comment">&lt;/span&gt; : --&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"hour"</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getHours1 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getHours2 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dian"</span>&gt;</span>:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"minute"</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getMinutes1 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getMinutes2 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dian"</span>&gt;</span>:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"second"</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getSeconds1 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; getSeconds2 &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 这里是显示结束后的内容 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"second"</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"isShow"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;clocker&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;script&gt;<br>export <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">'downTime'</span>,<br><br>  props: &#123; <span class="hljs-comment">// 接收父组件传递过来的参数,这里传了  结束时间 - 开始时间 - 结束后显示的内容</span><br>    endTime: &#123;<br>      type: Number<br>    &#125;,<br>    startTime: &#123;<br>      type: Number<br>    &#125;,<br>    endMsg: &#123;<br>      type: String<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-keyword">data</span> () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      isShow: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 控制显示结束或还未结束显示的内容</span><br>      clocker: <span class="hljs-string">''</span>, <span class="hljs-comment">// 结束后显示的内容</span><br>      timeObj: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 时间对象,下方会用到</span><br>      myDay: <span class="hljs-number">0</span>, <span class="hljs-comment">// 我定义来接收计算出来的 天 的</span><br>      myHours: <span class="hljs-number">0</span>, <span class="hljs-comment">// 我定义来接收计算出来的 小时 的</span><br>      myMinutes: <span class="hljs-number">0</span>, <span class="hljs-comment">// 我定义来接收计算出来的 分钟 的</span><br>      mySeconds: <span class="hljs-number">0</span><span class="hljs-comment">// 我定义来接收计算出来的 秒钟 的</span><br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    getHours1 () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myHours &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> : parseInt((<span class="hljs-keyword">this</span>.myHours % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<br>    &#125;,<br>    getHours2 () &#123;<br>      <span class="hljs-keyword">return</span> parseInt(<span class="hljs-keyword">this</span>.myHours % <span class="hljs-number">10</span>)<br>    &#125;,<br>    getMinutes1 () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myMinutes &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> : parseInt((<span class="hljs-keyword">this</span>.myMinutes % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<br>    &#125;,<br>    getMinutes2 () &#123;<br>      <span class="hljs-keyword">return</span> parseInt(<span class="hljs-keyword">this</span>.myMinutes % <span class="hljs-number">10</span>)<br>    &#125;,<br>    getSeconds1 () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mySeconds &lt; <span class="hljs-number">10</span> ? <span class="hljs-number">0</span> : parseInt((<span class="hljs-keyword">this</span>.mySeconds % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>)<br>    &#125;,<br>    getSeconds2 () &#123;<br>      <span class="hljs-keyword">return</span> parseInt(<span class="hljs-keyword">this</span>.mySeconds % <span class="hljs-number">10</span>)<br>    &#125;<br>  &#125;,<br>  mounted () &#123;<br>  &#125;,<br>  methods: &#123;<br>    option () &#123;<br>      <span class="hljs-comment">// 计算时间差</span><br>      let timeLag = (<span class="hljs-keyword">this</span>.endTime - <span class="hljs-keyword">this</span>.startTime) / <span class="hljs-number">1000</span><br>      <span class="hljs-comment">// 判断当前是否时分秒的值是否大于10</span><br>      <span class="hljs-keyword">const</span> add = num =&gt; &#123;<br>        <span class="hljs-keyword">return</span> num &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">'0'</span> + num : num<br>      &#125;<br>      <span class="hljs-comment">// 时间倒计时运算的方法</span><br>      <span class="hljs-keyword">const</span> timeFunction = () =&gt; &#123;<br>        <span class="hljs-keyword">const</span> time = timeLag--<br>        <span class="hljs-keyword">this</span>.timeObj = &#123; <span class="hljs-comment">// 时间对象</span><br>          seconds: Math.floor(time % <span class="hljs-number">60</span>),<br>          minutes: Math.floor(time / <span class="hljs-number">60</span>) % <span class="hljs-number">60</span>,<br>          hours: Math.floor(time / <span class="hljs-number">60</span> / <span class="hljs-number">60</span>) % <span class="hljs-number">24</span>,<br>          days: Math.floor(time / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>)<br>        &#125;<br>        <span class="hljs-comment">// 计算出时分秒</span><br>        <span class="hljs-keyword">this</span>.myDay = `$&#123;add(<span class="hljs-keyword">this</span>.timeObj.days)&#125;`<br>        <span class="hljs-keyword">this</span>.myHours = `$&#123;add(<span class="hljs-keyword">this</span>.timeObj.hours)&#125;`<br>        <span class="hljs-keyword">this</span>.myMinutes = `$&#123;add(<span class="hljs-keyword">this</span>.timeObj.minutes)&#125;`<br>        <span class="hljs-keyword">this</span>.mySeconds = `$&#123;add(<span class="hljs-keyword">this</span>.timeObj.seconds)&#125;`<br>        <span class="hljs-comment">// 当时间差小于等于0时,停止倒计时</span><br>        <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">this</span>.isShow = <span class="hljs-literal">true</span><br>          <span class="hljs-keyword">this</span>.clocker = <span class="hljs-keyword">this</span>.endMsg<br>          clearInterval(go)<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 开始执行倒计时</span><br>      timeFunction()<br>      <span class="hljs-comment">// 每一秒执行一次</span><br>      <span class="hljs-keyword">const</span> go = setInterval(() =&gt; &#123;<br>        timeFunction()<br>      &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>  &#125;,<br>    watch: &#123;<br>        endTime: &#123;<br>          handler (newName, oldName) &#123;<br>            <span class="hljs-keyword">this</span>.option()<br>          &#125;,<br>          immediate: <span class="hljs-literal">true</span>,<br>          deep: <span class="hljs-literal">true</span><br>        &#125;<br>     &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>备注：我将时分秒使用计算属性分成了个位和十位两部分展示，在watch中深度监听endTime属性的变化并重新调用定时器</p><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;style lang=<span class="hljs-string">"scss"</span> scoped&gt;<br>.downTime-wrapper&#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-selector-class">.dian</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">top</span>: -<span class="hljs-number">5px</span>;<br>  &#125;<br>  .hour&#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>;<br>    <span class="hljs-selector-tag">span</span> &#123;<br>      <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">6px</span>;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;<br>      <span class="hljs-attribute">background</span>:rgba(<span class="hljs-number">27</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">1</span>);<br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">1px</span> <span class="hljs-number">10px</span>;<br>      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span>;<br>    &#125;<br>  &#125;<br>  .minute&#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>;<br>    <span class="hljs-selector-tag">span</span> &#123;<br>      <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">6px</span>;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;<br>      <span class="hljs-attribute">background</span>:rgba(<span class="hljs-number">27</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">1</span>);<br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">1px</span> <span class="hljs-number">10px</span>;<br>      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-selector-class">.second</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">5px</span>;<br>    <span class="hljs-selector-tag">span</span> &#123;<br>      <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">6px</span>;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;<br>      <span class="hljs-attribute">background</span>:rgba(<span class="hljs-number">27</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">1</span>);<br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">1px</span> <span class="hljs-number">10px</span>;<br>      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span>;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在页面中引入并注册后即可使用</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;timer<br>  <span class="hljs-symbol">:endTime=<span class="hljs-string">"item.endTime"</span></span><br>  <span class="hljs-symbol">:startTime=<span class="hljs-string">"new Date().getTime()"</span></span><br>  <span class="hljs-symbol">:endMsg=<span class="hljs-string">"item.endMsg"</span>&gt;</span><br>&lt;<span class="hljs-regexp">/timer&gt;</span><br></code></pre></td></tr></table></figure><h3 id="毫秒倒计时效果"><a href="#毫秒倒计时效果" class="headerlink" title="毫秒倒计时效果"></a>毫秒倒计时效果</h3><p>在template中加入<br><code>&lt;b id=&quot;timehs&quot;&gt;:00&lt;/b&gt;</code></p><p>声明timeDt方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">methods: &#123;<br>    timeDt () &#123;<br>      <span class="hljs-keyword">this</span>.timer1 = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> haomiao = <span class="hljs-number">99</span><br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'timehs'</span>).innerHTML = <span class="hljs-string">':'</span> + haomiao<br>        <span class="hljs-keyword">this</span>.timer2 = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">const</span> timehs = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'timehs'</span>)<br>          <span class="hljs-keyword">if</span> (timehs) &#123;<br>            timehs.innerHTML = <span class="hljs-string">`:<span class="hljs-subst">$&#123;haomiao &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">`0<span class="hljs-subst">$&#123;haomiao&#125;</span>`</span> : haomiao&#125;</span>`</span><br>          &#125;<br>          haomiao--<br>          <span class="hljs-keyword">if</span> (haomiao &lt; <span class="hljs-number">0</span>) &#123;<br>            haomiao = <span class="hljs-number">99</span><br>          &#125;<br>        &#125;, <span class="hljs-number">10</span>)<br>      &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>在create生命周期函数中调用timeDt方法</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">created () &#123;<br>    <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">this</span>.timeDt()<br>    &#125;)<br>  &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>组件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mongoose在egg中的运用</title>
    <link href="/my-hexo-blog/2021/05/21/Mongoose%E5%9C%A8egg%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <url>/my-hexo-blog/2021/05/21/Mongoose%E5%9C%A8egg%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Mongoose是什么？"><a href="#Mongoose是什么？" class="headerlink" title="Mongoose是什么？"></a>Mongoose是什么？</h3><p>Mongoose是MongoDB的一个对象模型工具，封装了许多MongoDB对文档的的增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。<br>###在egg项目中如何使用？</p><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><p><code>npm i egg-mongoose --save</code></p><h4 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h4><p>在根目录下的/config/plugin.js中配置插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">exports</span>.mongoose = &#123;<br>  enable: <span class="hljs-keyword">true</span>,<br>  <span class="hljs-keyword">package</span>: <span class="hljs-string">'egg-mongoose'</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3、连接数据库"><a href="#3、连接数据库" class="headerlink" title="3、连接数据库"></a>3、连接数据库</h4><p>在根目录下的/config/config.default.js增加配置，其中url为我们的数据库地址，可通过环境变量来区分开发环境还是生产环境，并且确定是否使用用户名密码的数据库<br><code>const prod = process.env.npm_config_server_prod;</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">mongoose</span>: &#123;<br>      <span class="hljs-attribute">client</span>: &#123;<br>        <span class="hljs-attribute">url</span>: prod ? <span class="hljs-string">'mongodb:eggadmin:123456@localhost:27017/DbName'</span> : <span class="hljs-string">'mongodb://127.0.0.1:27017/DbName'</span>,<br>        <span class="hljs-attribute">options</span>: &#123;<br>          <span class="hljs-attribute">useUnifiedTopology</span>: true,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br></code></pre></td></tr></table></figure><h4 id="4、配置与使用"><a href="#4、配置与使用" class="headerlink" title="4、配置与使用"></a>4、配置与使用</h4><h5 id="（1）数据表配置"><a href="#（1）数据表配置" class="headerlink" title="（1）数据表配置"></a>（1）数据表配置</h5><p>在app目录下新建model文件夹，在model文件夹下新建JS文件作为数据表的配置内容，下面以书籍表的配置为例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: Mongoose book Schema,</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> mongoose = app.mongoose;<br>  <span class="hljs-keyword">const</span> Schema = mongoose.Schema;<br>  <span class="hljs-keyword">const</span> BookSchema = <span class="hljs-keyword">new</span> Schema(&#123;<br>    desc: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 书籍描述 */</span><br>    name: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 书籍名称 */</span><br>    press: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 出版社 */</span><br>    author: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 作者 */</span><br>    image: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">Array</span> &#125;, <span class="hljs-comment">/* 书籍图片列表*/</span><br>    price: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 价格 */</span><br>    book_type: &#123; <span class="hljs-comment">/* 书籍分类id */</span><br>      <span class="hljs-keyword">type</span>: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'BookClassify'</span>,<br>    &#125;,<br>    user: &#123; <span class="hljs-comment">/* 书籍发布者id */</span><br>      <span class="hljs-keyword">type</span>: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'User'</span>,<br>    &#125;,<br>    create_time: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 创建时间 */</span><br>    status: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 状态，1：待购买，2：已购买*/</span><br>    look: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">Number</span> &#125; <span class="hljs-comment">/* 浏览数量 */</span><br>  &#125;);<br>  <span class="hljs-keyword">return</span> mongoose.model(<span class="hljs-string">'Book'</span>, BookSchema);<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到我们可以通过Schema来定义表结构，可以指定字段的类型及关联，设置完字段后就可以生成model了，这里算是非常简单的配置，更多配置方法可参考<a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">文档</a></p><h5 id="2-、使用mongoose方法"><a href="#2-、使用mongoose方法" class="headerlink" title="(2)、使用mongoose方法"></a>(2)、使用mongoose方法</h5><p>配置完数据表结构后，我们就可以再service层中调用mongoose的方法对文档进行增删查改了，已书籍列表的处理逻辑为例子</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs stata">async findbookList(data) &#123;<br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">type</span>, page, pageSize, <span class="hljs-keyword">desc</span>, status, userId &#125; = data;<br>  <span class="hljs-keyword">const</span> searchVal = &#123;&#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span>) &#123;<br>    searchVal.book_type = mongoose.Types.ObjectId(<span class="hljs-keyword">type</span>)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (status) &#123;<br>    searchVal.status = status<br>  &#125;<br>  <span class="hljs-keyword">if</span> (userId) &#123;<br>    searchVal.user = mongoose.Types.ObjectId(userId)<br>  &#125;<br>  <span class="hljs-keyword">const</span> search_term = &#123;<br>    <span class="hljs-variable">$or</span>: [<br>      &#123; <span class="hljs-keyword">desc</span>: &#123; <span class="hljs-variable">$regex</span>: <span class="hljs-keyword">desc</span> ? <span class="hljs-keyword">desc</span> : '', <span class="hljs-variable">$options</span>: '<span class="hljs-variable">$i</span>' &#125; &#125;,<br>      &#123; name: &#123; <span class="hljs-variable">$regex</span>: <span class="hljs-keyword">desc</span> ? <span class="hljs-keyword">desc</span> : '', <span class="hljs-variable">$options</span>: '<span class="hljs-variable">$i</span>' &#125; &#125;,<br>      &#123; author: &#123; <span class="hljs-variable">$regex</span>: <span class="hljs-keyword">desc</span> ? <span class="hljs-keyword">desc</span> : '', <span class="hljs-variable">$options</span>: '<span class="hljs-variable">$i</span>' &#125; &#125;,<br>      &#123; press: &#123; <span class="hljs-variable">$regex</span>: <span class="hljs-keyword">desc</span> ? <span class="hljs-keyword">desc</span> : '', <span class="hljs-variable">$options</span>: '<span class="hljs-variable">$i</span>' &#125; &#125;,<br>    ],<br>  &#125;;<br>  <span class="hljs-keyword">const</span> totalNum = await this.ctx.model.Book.find(searchVal).and(search_term).countDocuments();<br>  <span class="hljs-keyword">const</span> result = await this.ctx.model.Book.find(searchVal)<br>    .populate(&#123;<br>      path: 'user',<br>      select: &#123; name: 1, image: 1 &#125;<br>    &#125;)<br>    .populate(&#123;<br>      path: 'book_type'<br>    &#125;)<br>    .and(search_term)<br>    .<span class="hljs-keyword">sort</span>(&#123; create_time: -1 &#125;)<br>    .skip((parseInt(page) - 1) * parseInt(pageSize))<br>    .limit(parseInt(pageSize));<br>    <span class="hljs-keyword">return</span> result ? &#123; bean: &#123;<br>      records: result,<br>      current: page,<br>      size: result.length,<br>      <span class="hljs-keyword">total</span>: totalNum,<br>    &#125;, ...<span class="hljs-keyword">app</span>.config.msg.GET_SUCCESS &#125; : <span class="hljs-keyword">app</span>.config.msg.GET_ERR;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，通过this.ctx.model.Book就可以获取到Book的model并且可以调用mongoose需要的方法，例如populate、find、and、sort、skip、limit 等等。</p><h4 id="5、egg-Mongoose常用的方法"><a href="#5、egg-Mongoose常用的方法" class="headerlink" title="5、egg-Mongoose常用的方法"></a>5、egg-Mongoose常用的方法</h4><h5 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.create</span>(<span class="hljs-selector-tag">data</span>,<span class="hljs-selector-tag">callback</span>);<br></code></pre></td></tr></table></figure><p>其中data为json数据结构，callback为操作后的回调函数</p><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><h6 id="获取所有数据，返回是一个数组"><a href="#获取所有数据，返回是一个数组" class="headerlink" title="获取所有数据，返回是一个数组"></a>获取所有数据，返回是一个数组</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.find</span>()<br></code></pre></td></tr></table></figure><h6 id="获取一个数据，返回是一个对象"><a href="#获取一个数据，返回是一个对象" class="headerlink" title="获取一个数据，返回是一个对象"></a>获取一个数据，返回是一个对象</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.findOne</span>()<br></code></pre></td></tr></table></figure><h6 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Article</span><span class="hljs-selector-class">.find</span>(<span class="hljs-selector-tag">conditions</span>,<span class="hljs-selector-tag">callback</span>);<br></code></pre></td></tr></table></figure><p>其中conditions为查询的条件，callback为回调函数<br>conditions有一下几种情况：</p><p> 具体数据：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">this.ctx.model.Book.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-variable">_id</span>：<span class="hljs-number">5</span>c4a19fb87ba4002a47ac4d, <span class="hljs-built_in">name</span>: <span class="hljs-string">"射雕英雄传"</span> &#125;, callback);<br></code></pre></td></tr></table></figure><p>条件查询：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-string">"<span class="hljs-variable">$lt</span>"</span>小于<br><span class="hljs-string">"<span class="hljs-variable">$lte</span>"</span>小于等于<br><span class="hljs-string">"<span class="hljs-variable">$gt</span>"</span>大于<br><span class="hljs-string">"<span class="hljs-variable">$gte</span>"</span>大于等于<br><span class="hljs-string">"<span class="hljs-variable">$ne</span>"</span>不等于<br><span class="hljs-comment">// 查询价格大于100小于200的书籍数组</span><br><span class="hljs-keyword">this</span>.ctx.model.Book.find(&#123; <span class="hljs-string">"price"</span>: &#123; $<span class="hljs-keyword">get</span>:<span class="hljs-number">100</span> , $lte:<span class="hljs-number">200</span> &#125;);<br></code></pre></td></tr></table></figure><p>或查询 OR</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">"<span class="hljs-variable">$in</span>"</span> 一个键对应多个值<br><span class="hljs-string">"<span class="hljs-variable">$nin</span>"</span> 同上取反, 一个键不对应指定值<br><span class="hljs-string">"<span class="hljs-variable">$or</span>"</span> 多个条件匹配, 可以嵌套 <span class="hljs-variable">$in</span> 使用<br><span class="hljs-string">"<span class="hljs-variable">$not</span>"</span>同上取反, 查询与特定模式不匹配的文档<br><br>this.ctx.model.Book.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">"name"</span>:&#123; <span class="hljs-variable">$in</span>: [<span class="hljs-string">"射雕"</span>,<span class="hljs-string">"倚天"</span>]&#125; );<br></code></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.remove</span>(<span class="hljs-selector-tag">conditions</span>,<span class="hljs-selector-tag">callback</span>);<br></code></pre></td></tr></table></figure><h5 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.update</span>(<span class="hljs-selector-tag">conditions</span>, <span class="hljs-selector-tag">update</span>, <span class="hljs-selector-tag">callback</span>)<br></code></pre></td></tr></table></figure><p>conditions为条件，update是更新的值对象</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.sort</span>(&#123; <span class="hljs-attribute">create_time</span>: -<span class="hljs-number">1</span> &#125;);<br></code></pre></td></tr></table></figure><p>其中-1表示降序返回。 1表示升序返回</p><h5 id="限制数量"><a href="#限制数量" class="headerlink" title="限制数量"></a>限制数量</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.limit</span>(<span class="hljs-selector-tag">number</span>);<br></code></pre></td></tr></table></figure><p>number表示限制的个数</p><h5 id="跳过文档返回"><a href="#跳过文档返回" class="headerlink" title="跳过文档返回"></a>跳过文档返回</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.skip</span>(<span class="hljs-selector-tag">number</span>);<br></code></pre></td></tr></table></figure><p>number表示跳过的个数,skip经常搭配limit实现分页的功能</p><h5 id="条件数组and"><a href="#条件数组and" class="headerlink" title="条件数组and"></a>条件数组and</h5><p>在find后面可使用and对查询结果进行进一步条件筛选，相当于并且的意思。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">const search_term = &#123;<br><span class="hljs-symbol">        $or:</span> [<br>          &#123; <span class="hljs-string">desc:</span> &#123; <span class="hljs-string">$regex:</span> desc ? desc : <span class="hljs-string">''</span>, <span class="hljs-string">$options:</span> <span class="hljs-string">'$i'</span> &#125; &#125;,<br>          &#123; <span class="hljs-string">name:</span> &#123; <span class="hljs-string">$regex:</span> desc ? desc : <span class="hljs-string">''</span>, <span class="hljs-string">$options:</span> <span class="hljs-string">'$i'</span> &#125; &#125;,<br>          &#123; <span class="hljs-string">author:</span> &#123; <span class="hljs-string">$regex:</span> desc ? desc : <span class="hljs-string">''</span>, <span class="hljs-string">$options:</span> <span class="hljs-string">'$i'</span> &#125; &#125;,<br>          &#123; <span class="hljs-string">press:</span> &#123; <span class="hljs-string">$regex:</span> desc ? desc : <span class="hljs-string">''</span>, <span class="hljs-string">$options:</span> <span class="hljs-string">'$i'</span> &#125; &#125;,<br>        ],<br>      &#125;;<br>   <span class="hljs-keyword">this</span>.ctx.model.Book.find().and(search_term)<br></code></pre></td></tr></table></figure><h5 id="关联查询populate"><a href="#关联查询populate" class="headerlink" title="关联查询populate"></a>关联查询populate</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 在model中配置字段时候指定关联的表名，就可以通过populate来进行表的关联查询</span><br><span class="hljs-attribute">user</span>: &#123; <span class="hljs-comment">/* 书籍发布者id */</span><br>      <span class="hljs-attribute">type</span>: Schema.Types.ObjectId,<br>      <span class="hljs-attribute">ref</span>: <span class="hljs-string">'User'</span>,<br>    &#125;,<br>  <br>  <br><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.ctx</span><span class="hljs-selector-class">.model</span><span class="hljs-selector-class">.Book</span><span class="hljs-selector-class">.find</span>()<br>        <span class="hljs-selector-class">.populate</span>(&#123;<br>          <span class="hljs-attribute">path</span>: <span class="hljs-string">'user'</span>,<br>          <span class="hljs-attribute">select</span>: &#123; <span class="hljs-attribute">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attribute">image</span>: <span class="hljs-number">1</span> &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><h5 id="聚合管道Aggregate"><a href="#聚合管道Aggregate" class="headerlink" title="聚合管道Aggregate"></a>聚合管道Aggregate</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">this</span>.ctx.model.Template.aggregate([<br>        &#123; <span class="hljs-string">$match:</span> &#123; name &#125; &#125;,<br>        &#123; <span class="hljs-string">$sort:</span> &#123; <span class="hljs-string">create_time:</span> <span class="hljs-number">-1</span> &#125; &#125;,<br>        &#123; <span class="hljs-string">$group:</span> &#123; <span class="hljs-string">_id:</span> <span class="hljs-string">'$name'</span>, <span class="hljs-string">user_id:</span> &#123; <span class="hljs-string">$first:</span> <span class="hljs-string">'$modifier'</span> &#125; &#125; &#125;,<br>      ]);<br></code></pre></td></tr></table></figure><p>Mongoose聚合管道aggregate常用的操作有$project 、$match 、$group、$sort、$limit、$skip、$lookup 表关联</p><h4 id="批量操作bulkWrite"><a href="#批量操作bulkWrite" class="headerlink" title="批量操作bulkWrite"></a>批量操作bulkWrite</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">const template_list = await ctx.model.Template.aggregate([<br>     &#123; <span class="hljs-string">$sort:</span> &#123; <span class="hljs-string">create_time:</span> <span class="hljs-number">-1</span> &#125; &#125;,<br>     &#123; <span class="hljs-string">$group:</span> &#123; <span class="hljs-string">_id:</span> <span class="hljs-string">'$name'</span>, <span class="hljs-string">template_id:</span> &#123; <span class="hljs-string">$first:</span> <span class="hljs-string">'$_id'</span> &#125;, <span class="hljs-string">label:</span> &#123; <span class="hljs-string">$first:</span> <span class="hljs-string">'$label'</span> &#125; &#125; &#125;,<br>   ]);<br>   const update_value = [];<br>   template_list.forEach(item =&gt; &#123;<br>     <span class="hljs-keyword">if</span> (!item.label) &#123;<br>       update_value.push(&#123;<br><span class="hljs-symbol">         updateOne:</span> &#123;<br><span class="hljs-symbol">           filter:</span> &#123; <span class="hljs-string">_id:</span> item.template_id &#125;,<br><span class="hljs-symbol">           update:</span> &#123; <span class="hljs-string">label:</span> <span class="hljs-string">''</span> &#125;,<br>         &#125;,<br>       &#125;);<br>     &#125;<br>   &#125;);<br>   await ctx.model.Template.bulkWrite(update_value);<br></code></pre></td></tr></table></figure><p>可以进行一系列批量增加、删除、更新等操作。</p><p>mongoose还有非常多的方法可以提供给我的灵活使用，我们在使用的时候可以结合业务逻辑选择合适的方法来提高我们操作数据库的效率。在我们使用它之前可以认真的阅读<a href="https://mongoosejs.com/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>egg.js+mongoose实现二级评论</title>
    <link href="/my-hexo-blog/2021/05/21/egg-js-mongoose%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA/"/>
    <url>/my-hexo-blog/2021/05/21/egg-js-mongoose%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>1、首先我们先在model目录下新建comment.js文件，这里使用<strong>egg-mongoose</strong>进行配置表以及字段，这里关键需要parent_id作为父级字段，若默认为0则是第一级评论，如果为id，则是二级评论。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: Mongoose comment Schema,</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> mongoose = app.mongoose;<br>  <span class="hljs-keyword">const</span> Schema = mongoose.Schema;<br>  <span class="hljs-keyword">const</span> CommentSchema = <span class="hljs-keyword">new</span> Schema(&#123;<br>    <span class="hljs-keyword">from</span>: &#123; <span class="hljs-comment">/* 评论人id */</span><br>      type: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'User'</span>,<br>    &#125;,<br>    to: &#123; <span class="hljs-comment">/* 被评论人id */</span><br>      type: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'User'</span>,<br>    &#125;,<br>    content: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 内容 */</span><br>    create_time: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> &#125;, <span class="hljs-comment">/* 评论时间 */</span><br>    book: &#123; <span class="hljs-comment">/* 书籍id */</span><br>      type: Schema.Types.ObjectId,<br>      ref: <span class="hljs-string">'Book'</span>,<br>    &#125;,<br>    parent_id: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">0</span> &#125; <span class="hljs-comment">/* 父级 */</span><br>  &#125;);<br>  <span class="hljs-keyword">return</span> mongoose.model(<span class="hljs-string">'Comment'</span>, CommentSchema);<br>&#125;;<br></code></pre></td></tr></table></figure><p>2、在controller 目录下新建comment.js 用于编写 评论相关的控制器方法，这里我定义了新增评论和查询评论，使用<strong>egg-validate</strong>进行请求参数验证如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">'egg'</span>).Controller;<br><span class="hljs-comment">// 定义新增评论请求参数规则</span><br><span class="hljs-keyword">const</span> createCommentRule = &#123;<br>  <span class="hljs-keyword">from</span>: <span class="hljs-string">'string'</span>,<br>  to: &#123;<br>    type: <span class="hljs-string">'string'</span>,<br>    required: <span class="hljs-literal">false</span>,<br>  &#125;,<br>  content: <span class="hljs-string">'string'</span>,<br>  book: <span class="hljs-string">'string'</span>,<br>  parentId: &#123;<br>    type: <span class="hljs-string">'string'</span>,<br>    required: <span class="hljs-literal">false</span>,<br>  &#125;,<br>&#125;<br><span class="hljs-comment">// 定义查询评论请求参数规则</span><br><span class="hljs-keyword">const</span> findCommentRule = &#123;<br>  book: <span class="hljs-string">'string'</span>,<br>  page: <span class="hljs-string">'string'</span>,<br>  pageSize: <span class="hljs-string">'string'</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  <span class="hljs-keyword">async</span> create() &#123;<br>    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-keyword">this</span>;<br>    ctx.validate(createCommentRule, ctx.request.body);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.service.comment.createComment(ctx.request.body);<br>    ctx.body = result;<br>  &#125;<br>  <span class="hljs-keyword">async</span> find() &#123;<br>    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-keyword">this</span>;<br>    ctx.validate(findCommentRule, ctx.query);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.service.comment.findComment(ctx.query);<br>    ctx.body = result;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = CommentController;<br></code></pre></td></tr></table></figure><p>在对应的控制器方法调用service层里面的方法，在service的方法进行数据库操作与逻辑处理。</p><p>3、在service目录下新建comment.js用于编写评论相关service方法。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">'use strict'</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 评论相关Service</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> Service = <span class="hljs-built_in">require</span>(<span class="hljs-string">'egg'</span>).Service;<br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);<br><span class="hljs-keyword">const</span> dayjs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dayjs'</span>);<br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增评论</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Object&#125;</span> </span>data 包括评论人id，被评论人id，书籍id， 评论父级id，评论内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">async</span> createComment(data) &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">from</span>, to, content, book, parentId &#125; = data;<br>      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.model.Comment.create(&#123;<br>        <span class="hljs-keyword">from</span>,<br>        to,<br>        content,<br>        book,<br>        parent_id: parentId ? mongoose.Types.ObjectId(parentId) : <span class="hljs-number">0</span>,<br>        create_time: dayjs().unix(),<br>      &#125;);<br>      <span class="hljs-keyword">return</span> result ? app.config.msg.CREARE_SUCCESS : app.config.msg.CREARE_ERR;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询评论</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Object&#125;</span> </span>data 包括书籍id，页码，页数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">async</span> findComment(data) &#123;<br>      <span class="hljs-keyword">const</span> &#123; book, page, pageSize &#125; = data<br>      <span class="hljs-keyword">const</span> totalNum = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.model.Comment.find(&#123; <span class="hljs-attr">book</span>: mongoose.Types.ObjectId(book), <span class="hljs-attr">parent_id</span>: <span class="hljs-number">0</span> &#125;).countDocuments();<br>      <span class="hljs-keyword">const</span> oneList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ctx.model.Comment.find(&#123; <span class="hljs-attr">book</span>: mongoose.Types.ObjectId(book), <span class="hljs-attr">parent_id</span>: <span class="hljs-number">0</span> &#125;)<br>        .populate(&#123;<br>          path: <span class="hljs-string">'from'</span>,<br>          select: &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">image</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;<br>        &#125;)<br>        .populate(&#123;<br>          path: <span class="hljs-string">'to'</span>,<br>          select: &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">image</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;<br>        &#125;)<br>        .sort(&#123; <span class="hljs-attr">create_time</span>: <span class="hljs-number">1</span>&#125;)<br>        .skip((<span class="hljs-built_in">parseInt</span>(page) - <span class="hljs-number">1</span>) * <span class="hljs-built_in">parseInt</span>(pageSize))<br>        .limit(<span class="hljs-built_in">parseInt</span>(pageSize)).lean();<br>        <span class="hljs-keyword">const</span> Comment = <span class="hljs-keyword">this</span>.ctx.model.Comment<br>        <span class="hljs-keyword">var</span> promises = oneList.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> Comment.find(&#123;<br>              book: mongoose.Types.ObjectId(book),<br>              parent_id: item._id<br>          &#125;)<br>          .populate(&#123;<br>            path: <span class="hljs-string">'from'</span>,<br>            select: &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">image</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;<br>          &#125;)<br>          .populate(&#123;<br>            path: <span class="hljs-string">'to'</span>,<br>            select: &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">image</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span> &#125;<br>          &#125;)<br>          .sort(&#123; <span class="hljs-attr">create_time</span>: <span class="hljs-number">1</span>&#125;)<br>          .select(<span class="hljs-string">'-__v'</span>).lean()<br>      &#125;);<br>      <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises)<br>      oneList.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        item.items = []<br>        list.forEach(<span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (code.length &gt; <span class="hljs-number">0</span> &amp;&amp; item._id == code[<span class="hljs-number">0</span>].parent_id) &#123;<br>              item.items = code<br>          &#125;<br>        &#125;)<br>      &#125;)<br>      <span class="hljs-keyword">return</span> oneList ? &#123; <span class="hljs-attr">bean</span>: &#123;<br>        records: oneList,<br>        current: page,<br>        size: oneList.length,<br>        total: totalNum,<br>      &#125;, ...app.config.msg.GET_SUCCESS &#125; : app.config.msg.GET_ERR;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> CommentService;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注：首先我们需要查询一级评论的分页数据，然后用map遍历一级评论列表，返回一个promises数组，数组的每一项是查询该一级评论下的所有二级评论，我这里没有进行分页，也可以加上分页。使用Promise.all异步执行所有的查询函数，完成后的结果赋值为list，最后遍历一级评论列表与二级评论列表，当一级评论id 等于 二级评论列表中parent_id时候 给当前一级评论列表增加 items属性用于存放它的二级评论。</p><p>最后在router.js中定义接口路径与请求类型，如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// 新建评论</span><br>router.post(<span class="hljs-string">'/api/comment/create'</span>, controller.<span class="hljs-built_in">comment</span>.create);<br><span class="hljs-comment">// 查询评论</span><br>router.get(<span class="hljs-string">'/api/comment/find'</span>, controller.<span class="hljs-built_in">comment</span>.<span class="hljs-built_in">find</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目使用axios拦截器封装api</title>
    <link href="/my-hexo-blog/2021/05/21/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B0%81%E8%A3%85api/"/>
    <url>/my-hexo-blog/2021/05/21/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8axios%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B0%81%E8%A3%85api/</url>
    
    <content type="html"><![CDATA[<p>在api目录下新建一个http.js，实现代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> Qs <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store'</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils'</span> <span class="hljs-comment">//工具类</span><br><span class="hljs-keyword">import</span> &#123; Toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'mand-mobile'</span><br><br><span class="hljs-keyword">const</span> instance = axios.create(&#123;<br>  baseURL: <span class="hljs-string">''</span>, <span class="hljs-comment">// 后端接口根目录</span><br>  message: <span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-comment">// 错误控制</span><br><span class="hljs-keyword">const</span> errorHandle = <span class="hljs-function">(<span class="hljs-params">status, message</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (status) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:<br>      <span class="hljs-comment">// store.dispatch('logout')</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>      Toast.failed(message)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// axios请求拦截器</span><br><span class="hljs-comment">/* 拦截器一般做什么？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">　　　　1. 修改请求头的一些配置项</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">　　　　2. 给请求的过程添加一些请求的图标</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">　　　　3. 给请求添加参数 */</span><br>instance<br>  .interceptors<br>  .request<br>  .use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = utils.env !== <span class="hljs-string">'dev'</span> ? store.state.auth.token : <span class="hljs-string">''</span><br>    token &amp;&amp; (config.headers.common.token = token)<br>    <span class="hljs-keyword">if</span> (config.method === <span class="hljs-string">'post'</span> &amp;&amp; config.data) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(config.data) !== <span class="hljs-string">'[object FormData]'</span>) &#123;<br>        config.data = Qs.stringify(config.data)<br>      &#125;<br>      config.headers.common[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'multipart/form-data'</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> config<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>  &#125;)<br><span class="hljs-comment">// 响应拦截器，接受响应接口后的统一处理</span><br>instance<br>  .interceptors<br>  .response<br>  .use(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    response.success = response.data.success<br>    <span class="hljs-keyword">if</span> (response.config.message) &#123;<br>      <span class="hljs-keyword">if</span> (!response.success) &#123;<br>        response.data.message &amp;&amp; Toast.failed(response.data.message)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        response.config.method === <span class="hljs-string">'post'</span> &amp;&amp; Toast.succeed(response.data.message || <span class="hljs-string">'操作成功'</span>)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> response<br>  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; response &#125; = error<br>    response<br>      ? errorHandle(response.status, response.data.message || <span class="hljs-string">'网络连接失败，请稍后重试！'</span>)<br>      : Toast.info(<span class="hljs-string">'网络连接失败，请稍后重试！'</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)<br>  &#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createAPI = <span class="hljs-function">(<span class="hljs-params">url, method, params, config = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (method === <span class="hljs-string">'get'</span>) &#123;<br>    config.params = params<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    config.data = params<br>  &#125;<br>  <span class="hljs-keyword">return</span> instance(&#123;<br>    url,<br>    method,<br>    ...config<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance<br></code></pre></td></tr></table></figure><p>配置接口方式：<br>在api目录下新建个index.js<br><code>import { createAPI } from &#39;./http&#39;</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>&#123;<br>  wxOuth: params =&gt; createAPI(<span class="hljs-string">'/wechat/getOauthUrl'</span>, <span class="hljs-string">'get'</span>, params)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在我们的vue组件中引入即可 <code>import * as api from &#39;@/api&#39;</code><br>调用方式为： api.wxOuth(params).then(res=&gt; {}).catch(err =&gt; {})</p>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web端的微信支付可分为JSAPI与H5</title>
    <link href="/my-hexo-blog/2021/05/21/web%E7%AB%AF%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%AF%E5%88%86%E4%B8%BAJSAPI%E4%B8%8EH5/"/>
    <url>/my-hexo-blog/2021/05/21/web%E7%AB%AF%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%8F%AF%E5%88%86%E4%B8%BAJSAPI%E4%B8%8EH5/</url>
    
    <content type="html"><![CDATA[<h3 id="web端的微信支付可分为JSAPI与H5"><a href="#web端的微信支付可分为JSAPI与H5" class="headerlink" title="web端的微信支付可分为JSAPI与H5"></a>web端的微信支付可分为JSAPI与H5</h3><p>JSAPI使用场景为微信内部，而H5支付则是使用在非微信下的外部浏览器。</p><h4 id="1-JSAPI"><a href="#1-JSAPI" class="headerlink" title="1.JSAPI"></a>1.JSAPI</h4><p>在微信内部可以直接唤起微信浏览器的内置对象<code>WeixinJSBridge</code><br>废话不多说直接上代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 调用后端接口拿到JSAPI支付所需参数，我在beforeRouteEnter的时候调用。</span><br>api.apply.jsApiPay(obj).then(res =&gt; &#123;<br>          <span class="hljs-keyword">if</span> (res.data.code === <span class="hljs-string">'0000'</span>) &#123;<br>            vm.<span class="hljs-keyword">params</span> = res.data.bean<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            alert(<span class="hljs-string">'微信支付调起失败！'</span>)<br>          &#125;<br>        &#125;).<span class="hljs-keyword">catch</span>(err =&gt; &#123;<br>          alert(err)<br>        &#125;)<br><br><span class="hljs-comment">// 点击支付时候调用</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> WeixinJSBridge === <span class="hljs-string">'undefined'</span>) &#123;<br>        <span class="hljs-keyword">if</span> (document.addEventListener) &#123;<br>          document.addEventListener(<span class="hljs-string">'WeixinJSBridgeReady'</span>, <span class="hljs-keyword">this</span>.onBridgeReady(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">params</span>), <span class="hljs-literal">false</span>)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (document.attachEvent) &#123;<br>          document.attachEvent(<span class="hljs-string">'WeixinJSBridgeReady'</span>, <span class="hljs-keyword">this</span>.onBridgeReady(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">params</span>))<br>          document.attachEvent(<span class="hljs-string">'onWeixinJSBridgeReady'</span>, <span class="hljs-keyword">this</span>.onBridgeReady(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">params</span>))<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.onBridgeReady(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">params</span>)<br>      &#125;<br><br><br>onBridgeReady (<span class="hljs-keyword">params</span>) &#123;<br>      <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span><br>      WeixinJSBridge.invoke(<br>        <span class="hljs-string">'getBrandWCPayRequest'</span>,<br>        &#123;<br>          appId: <span class="hljs-keyword">params</span>.appId, <span class="hljs-comment">// 公众号名称，由商户传入</span><br>          timeStamp: <span class="hljs-keyword">params</span>.timeStamp, <span class="hljs-comment">// 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符</span><br>          nonceStr: <span class="hljs-keyword">params</span>.nonceStr, <span class="hljs-comment">// 支付签名随机串，不长于 32 位</span><br>          package: <span class="hljs-keyword">params</span>.prepay_id, <span class="hljs-comment">// 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*）</span><br>          signType: <span class="hljs-keyword">params</span>.signType, <span class="hljs-comment">// 签名方式，默认为'SHA1'，使用新版支付需传入'MD5'</span><br>          paySign: <span class="hljs-keyword">params</span>.paySign <span class="hljs-comment">// 支付签名</span><br>        &#125;,<br>        function (res) &#123;<br>          <span class="hljs-keyword">if</span> (res.err_msg === <span class="hljs-string">'get_brand_wcpay_request:ok'</span>) &#123;<br>            that.queryOrder() <span class="hljs-comment">// 这里是查询订单是否支付完成，然后执行成功和失败的业务逻辑</span><br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.err_msg === <span class="hljs-string">'get_brand_wcpay_request:fail'</span>) &#123;<br>            alert(<span class="hljs-string">'支付失败！'</span>)<br>          &#125;<br>        &#125;<br>      )<br>    &#125;,<br></code></pre></td></tr></table></figure><p>在微信支付的回调函数中，当res.err_msg 为<br>get_brand_wcpay_request:ok 时，支付状态不一定准确，因此需要调用后端的查询订单接口，查询是否支付完成，然后再执行相应的逻辑。</p><h4 id="2、H5支付"><a href="#2、H5支付" class="headerlink" title="2、H5支付"></a>2、H5支付</h4><p>h5相对简单，前端只需要跳转到后端返回的链接即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">api.apply.h5Pay(&#123;<br>            title: <span class="hljs-string">''</span><br>            orderNum: <span class="hljs-string">''</span>,<br>            expireMinute: <span class="hljs-number">10</span>,<br>            redirectUrl: <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">window</span>.location.origin&#125;</span>/pay/card?orderId=<span class="hljs-subst">$&#123;vm.orderId&#125;</span>`</span><br>          &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>            vm.h5PayUrl = res.data.bean<br>            <span class="hljs-comment">// 查询订单</span><br>          &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>            alert(err)<br>          &#125;)<br></code></pre></td></tr></table></figure><p>第一步，请求后端接口，需要传支付的标题，订单号，支付时间，重定向链接。</p><p>第二部，们只需要点击支付按钮时候跳转至后端返回链接即可。<br><code>window.location.href = this.h5PayUrl</code><br>需要注意的是H5支付查询订单需要用户去手动触发，因此需要增加一个确定订单的弹层。如图：<br><img src="https://i.ibb.co/PYzh0ZC/confirm-pay-layer.png" alt="image.png"><br>查询订单是否支付成功与JSAPI一致~</p>]]></content>
    
    
    <categories>
      
      <category>日常开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>微信体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础知识积累</title>
    <link href="/my-hexo-blog/2020/10/17/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <url>/my-hexo-blog/2020/10/17/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="一、从输入url地址栏到所有内容显示在界面上发生了什么？"><a href="#一、从输入url地址栏到所有内容显示在界面上发生了什么？" class="headerlink" title="一、从输入url地址栏到所有内容显示在界面上发生了什么？"></a>一、从输入url地址栏到所有内容显示在界面上发生了什么？</h3><ul><li>1、浏览器向dns服务器请求解析该URL中的域名所对应的IP地址</li><li>2、建立TCP链接（三次握手）</li><li>3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li><li>4、服务器对浏览器请求作出响应，并把对应的html文本发送给浏览器</li><li>5、浏览器将该html文本显示内容</li><li>6、释放TCP连接（四次挥手）</li></ul><h3 id="二、TCP的三次握手和四次挥手"><a href="#二、TCP的三次握手和四次挥手" class="headerlink" title="二、TCP的三次握手和四次挥手"></a>二、TCP的三次握手和四次挥手</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">ack <span class="hljs-comment">--- 确认号码</span><br>seq <span class="hljs-comment">--- 顺序号码</span><br>ISN <span class="hljs-comment">--- 初始序列号</span><br>ACK <span class="hljs-comment">--- 确认，使得确认号有效（握手使用）</span><br>SYN <span class="hljs-comment">--- 用于初始化一个连接的序列号，建立联机(同步序列编号)</span><br>FIN <span class="hljs-comment">--- 该报文的发送方已经结束向对方发送数据</span><br></code></pre></td></tr></table></figure><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>第一次握手（SYN=1，ACK=0，seq=x）</li></ul><p>Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等 待Server确认。</p><ul><li>第二次握手（SYN=1, ACK=1, seq=y, ack=x+1）</li></ul><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p><ul><li>第三次握手：(ACK=1，seq=x+1，ack=y+1)</li></ul><p>Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><ul><li>第一次挥手(FIN=1，seq=u)</li></ul><p>Client 想要关闭连接，Client 会发送一个FIN标志位置为1，当前序列号为u的包，表示需要关闭连接了。Client进入 FIN_WAIT_1 状态。</p><ul><li>第二次挥手(ACK=1，seq=v，ack=u+1)</li></ul><p>Server收到Client的FIN包之后，会发送一个确认序号为收到的序列号u+1的包，表明自己接受到了Client关闭连接的请求，但还未准备好关闭连接。Server进入 CLOSE_WAIT 状态，Client进入 FIN_WAIT_2 状态。</p><ul><li>第三次挥手(FIN=1，ACK=1，seq=w，ack=u+1)</li></ul><p>当Server将剩余数据发送完之后，会发送一个自己的FIN包，序列号为u+1。Server进入 LAST_ACK 状态，等待来自Client的最后一个ACK。</p><ul><li>第四次挥手(ACK=1，seq=u+1，ack=w+1)</li></ul><p>Client接收到来自Server端的关闭请求之后，发送最后一个ACK确认包，确认序号设置为收到序号加1。Client进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。Server接收到这个确认包之后，关闭连接，进入CLOSED状态。(Client会等待2MSL之后，没有收到Server的ACK ，就确认Server进入CLOSED状态，自己也关闭进入CLOSED状态。)</p><h3 id="三、for-in-与-for-of-的区别"><a href="#三、for-in-与-for-of-的区别" class="headerlink" title="三、for in 与 for of 的区别"></a>三、for in 与 for of 的区别</h3><ul><li>for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合，得到的是value值，<strong>for of不能对象用</strong></li><li>for in遍历对象得到key值，遍历数组得到下标</li></ul><h3 id="四、九种跨域方式实现原理"><a href="#四、九种跨域方式实现原理" class="headerlink" title="四、九种跨域方式实现原理"></a>四、九种跨域方式实现原理</h3><p>严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。</p><h4 id="同源策略："><a href="#同源策略：" class="headerlink" title="同源策略："></a>同源策略：</h4><p>所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><strong>同源策略限制内容有：</strong></p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求发送后，结果被浏览器拦截了</li></ul><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong></p><h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h4><p><strong>1.jsonp</strong>（<strong>优点是简单兼容性好，缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击</strong>）</p><p>原理：利用<code>&lt;script&gt;</code>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据，JSONP请求一定需要对方的服务器做支持才可以。</p><p>实现jsonp函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>)<br>    params = &#123; ...params, callback &#125;<br>    <span class="hljs-keyword">let</span> arrs = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;<br>      arrs.push(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>`</span>)<br>    &#125;<br>    script.src = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;arrs.join(<span class="hljs-string">'&amp;'</span>)&#125;</span>`</span><br>    <span class="hljs-built_in">document</span>.body.appendChild(script)<br>    <span class="hljs-built_in">window</span>[callback] = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>      resolve(data)<br>      <span class="hljs-built_in">document</span>.body.removeChild(script)<br>    &#125;<br>  &#125;)<br>&#125;<br><br>jsonp(&#123;<br>  url: <span class="hljs-string">'http://localhost:3000/say'</span>,<br>  params: &#123; <span class="hljs-attr">wd</span>: <span class="hljs-string">'ILoveYou'</span> &#125;,<br>  callback: <span class="hljs-string">'show'</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>服务端实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)<br><span class="hljs-keyword">let</span> app = express()<br>app.get(<span class="hljs-string">'/say'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> &#123; wd, callback &#125; = req.query<br>  <span class="hljs-built_in">console</span>.log(wd) <span class="hljs-comment">// Iloveyou</span><br>  <span class="hljs-built_in">console</span>.log(callback) <span class="hljs-comment">// show</span><br>  res.end(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>('我不爱你')`</span>)<br>&#125;)<br>app.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p><strong>Jquery 的jsonp形式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">$.ajax(&#123;<br>url:<span class="hljs-string">"http://crossdomain.com/jsonServerResponse"</span>,<br>dataType:<span class="hljs-string">"jsonp"</span>,<br>type:<span class="hljs-string">"get"</span>,<span class="hljs-comment">//可以省略</span><br>jsonpCallback:<span class="hljs-string">"show"</span>,<span class="hljs-comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><br>jsonp:<span class="hljs-string">"callback"</span>,<span class="hljs-comment">//-&gt;把传递函数名的那个形参callback，可省略</span><br>success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(data);&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>2.cors</strong></p><p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</p><p>浏览器如果支持会自动进行CORS通信，实现的关键在于后端</p><p>服务端设置<strong>Access-Control-Allow-Origin</strong>就开启了CORS,该属性表示哪些域名可以访问资源，设置通配符表示所有都可以访问。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><p><strong>简单请求</strong>:</p><p>条件1：使用下列方法之一：GET/HEAD/POST</p><p>条件2：Content-Type 的值仅限于下列三者之一：</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p><strong>复杂请求</strong>:</p><p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p><strong>3.postMessage</strong></p><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li><p>页面和其打开的新窗口的数据传递</p></li><li><p>多窗口之间消息传递</p></li><li><p>页面与嵌套的iframe消息传递</p></li><li><p>上面三个场景的跨域数据传递</p><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">otherWindow.post<span class="hljs-constructor">Message(<span class="hljs-params">message</span>, <span class="hljs-params">targetOrigin</span>, [<span class="hljs-params">transfer</span>])</span>;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">// a.html<br>  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://localhost:4000/b.html"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame"</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"load()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span> //等它加载完触发一个事件<br>  //内嵌在http://localhost:3000/a.html<br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="actionscript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'frame'</span>)</span><br><span class="actionscript">        frame.contentWindow.postMessage(<span class="hljs-string">'我爱你'</span>, <span class="hljs-string">'http://localhost:4000'</span>) <span class="hljs-comment">//发送数据</span></span><br><span class="javascript">        <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-comment">//接受返回数据</span></span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">//我不爱你</span></span><br>        &#125;<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// b.html</span><br>  <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">//我爱你</span><br>    e.source.postMessage(<span class="hljs-string">'我不爱你'</span>, e.origin)<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>4.websocket</strong></p><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>使用Socket.io</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">// socket.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">'ws://localhost:3000'</span>);</span><br><span class="actionscript">    socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="actionscript">      socket.send(<span class="hljs-string">'我爱你'</span>);<span class="hljs-comment">//向服务器发送数据</span></span><br>    &#125;<br><span class="actionscript">    socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(e.data);<span class="hljs-comment">//接收服务器返回的数据</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);<br><span class="hljs-keyword">let</span> app = express();<br><span class="hljs-keyword">let</span> WebSocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ws'</span>);<span class="hljs-comment">//记得安装ws</span><br><span class="hljs-keyword">let</span> wss = <span class="hljs-keyword">new</span> WebSocket.Server(&#123;<span class="hljs-attr">port</span>:<span class="hljs-number">3000</span>&#125;);<br>wss.on(<span class="hljs-string">'connection'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ws</span>) </span>&#123;<br>  ws.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>    ws.send(<span class="hljs-string">'我不爱你'</span>)<br>  &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>5.Node中间件代理(两次跨域)</strong></p><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong></p><p>实现一个node服务作为中间件，浏览器访问node 代理服务器，node代理服务器转发请求给目标服务器，目标服务器返回响应给node服务，node服务再转发响应给浏览器</p><p><strong>6.nginx反向代理</strong></p><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p><strong>7.window.name + iframe</strong></p><p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><p><strong>8.location.hash + iframe</strong></p><p>a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p><strong>9.document.domain + iframe</strong></p><p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><h3 id="五、http和https的区别及优缺点"><a href="#五、http和https的区别及优缺点" class="headerlink" title="五、http和https的区别及优缺点"></a>五、http和https的区别及优缺点</h3><ul><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li><li>http 协议的默认端口为 80，https 的默认端口为 443。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https 缓存不如 http 高效，会增加数据开销。</li><li>Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。</li><li>SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h3 id="六、Cookie、sessionStorage、localStorage-的区别"><a href="#六、Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="六、Cookie、sessionStorage、localStorage 的区别"></a>六、Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点：</strong> </p><ul><li>都是客户端缓存</li></ul><p><strong>不同点</strong></p><ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul><h3 id="七、浏览器重绘和重排的区别？"><a href="#七、浏览器重绘和重排的区别？" class="headerlink" title="七、浏览器重绘和重排的区别？"></a>七、浏览器重绘和重排的区别？</h3><ul><li>重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li><li>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li></ul><p><strong>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</strong></p><h3 id="浏览器缓存原理"><a href="#浏览器缓存原理" class="headerlink" title="浏览器缓存原理"></a>浏览器缓存原理</h3><p>强缓存：Cache-Control优先于Expires, 协商缓存：ETag优先于Last-Modified<br><strong>总结：</strong><br>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存</p><h3 id="八、进程、线程和协程"><a href="#八、进程、线程和协程" class="headerlink" title="八、进程、线程和协程"></a>八、进程、线程和协程</h3><p>进程: 是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。<br>线程: 是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成<br>协程: 是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><h3 id="九、HTML5-新特性、语义化"><a href="#九、HTML5-新特性、语义化" class="headerlink" title="九、HTML5 新特性、语义化"></a>九、HTML5 新特性、语义化</h3><p>HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构</p><p><strong>语义化标签</strong><br>header nav section main article aside footer<br><strong>语义化的优点</strong></p><ul><li>在没CSS样式的情况下，页面整体也会呈现很好的结构效果</li><li>代码结构清晰，易于阅读</li><li>利于开发和维护</li><li>有利于搜索引擎优化（SEO）</li></ul><h3 id="十、盒子模型"><a href="#十、盒子模型" class="headerlink" title="十、盒子模型"></a>十、盒子模型</h3><ul><li>标准盒子模型：width是指content部分的高度</li><li>ie盒子模型：width表示 content + padding + border 三个部分组成</li></ul><h3 id="十一、BFC（块级格式化上下文）"><a href="#十一、BFC（块级格式化上下文）" class="headerlink" title="十一、BFC（块级格式化上下文）"></a>十一、BFC（块级格式化上下文）</h3><p>BFC是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。</p><p><strong>如何创建bfc</strong></p><ul><li>根元素，即HTML元素</li><li>float的值不为none</li><li>position 为absolute或fixed</li><li>display的值为inline-block、table-cell、table-caption</li><li>overflow的值不为visible</li></ul><h3 id="十二、JS中数据类型及区别"><a href="#十二、JS中数据类型及区别" class="headerlink" title="十二、JS中数据类型及区别"></a>十二、JS中数据类型及区别</h3><ul><li>基本数据类型: Number、String、Boolean、 undefined、null、 Symbol, 在内存中占据固定大小，保存在栈内存中</li><li>引用数据类型： Object(对象)、Function(函数)，其他还有Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。</li></ul><h3 id="十三、JS中的数据类型检测方案"><a href="#十三、JS中的数据类型检测方案" class="headerlink" title="十三、JS中的数据类型检测方案"></a>十三、JS中的数据类型检测方案</h3><ul><li>1、typeof<br>能快速区分基本数据类型，不能区分Object、Array、Null，都返回object</li><li>2、instanceof<br>能够区分Array、Object和Function，适合用于判断自定义的类实例对象，Number，Boolean，String基本数据类型不能判断</li><li>3、Object.prototype.toString.call()<br>精准判断数据类型</li></ul><h3 id="十四、var-amp-amp-let-amp-amp-const"><a href="#十四、var-amp-amp-let-amp-amp-const" class="headerlink" title="十四、var &amp;&amp; let &amp;&amp; const"></a>十四、var &amp;&amp; let &amp;&amp; const</h3><p><strong>三者的区别</strong></p><ul><li>1、var定义变量，没有块的概念，可以跨块访问，但不能跨函数访问。let定义变量，只能在块作用域中访问，不能跨块访问，也不能跨函数访问。const用于定义常量，使用时候必须初始化（必须赋值），只能在块作用域中访问，且不能修改</li><li>2、var可以先试用后声明，因为存在变量提升；let必须先声明后使用</li><li>3、var是允许在相同作用域内重复声明同一个变量的，而let与const不允许这一现象。</li><li>4、在全局上下文中，基于let声明的全局变量和全局对象globel（window）没有任何关系 ; var声明的变量会和globel有映射关系；</li><li>5、会产生暂时性死区</li><li>6、let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决</li></ul><h3 id="十五、JS垃圾回收机制"><a href="#十五、JS垃圾回收机制" class="headerlink" title="十五、JS垃圾回收机制"></a>十五、JS垃圾回收机制</h3><p>1、项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。<br>浏览器垃圾回收机制/内存回收机制:<br>浏览器的Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。    </p><ul><li>标记清除: </li><li>谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。</li><li>IE浏览器：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。<br>2、内存泄漏<br>在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</li></ul><h3 id="十六、作用域和作用域链"><a href="#十六、作用域和作用域链" class="headerlink" title="十六、作用域和作用域链"></a>十六、作用域和作用域链</h3><p>定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成  </p><ul><li>1、全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</li><li>2、函数作用域：在固定的代码片段才能被访问<br>作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突<br>一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</li></ul><h3 id="十七、闭包的两大作用：保存-保护"><a href="#十七、闭包的两大作用：保存-保护" class="headerlink" title="十七、闭包的两大作用：保存/保护"></a>十七、闭包的两大作用：保存/保护</h3><ul><li>闭包是一个可以访问外部作用域中变量的内部函数。</li><li>这些被引用的变量直到闭包被销毁时才会被销毁。</li><li>闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。</li><li>可以通过闭包来达到封装性。</li></ul><p>（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；<br>（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；  </p><p>闭包形成的条件：</p><ul><li>1、函数的嵌套</li><li>2、内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ul><p>闭包的用途：</p><ul><li>1、模仿块级作用域</li><li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>封装私有化变量</li><li>创建模块</li></ul><p>闭包的优点：延长局部变量的生命周期<br>闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p><h3 id="十八、JS-中-this-的五种情况"><a href="#十八、JS-中-this-的五种情况" class="headerlink" title="十八、JS 中 this 的五种情况"></a>十八、JS 中 this 的五种情况</h3><ul><li>1、作为普通函数执行时，非严格模式（window）、严格模式（undefined）</li><li>2、当函数作为对象的方法被调用时，this就会指向这个对象</li><li>3、构造器调用，this指向返回的这个对象</li><li>4、箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象。如果有嵌套的情况，则this绑定到最近的一层对象上。</li><li>5、基于Function.prototype上的 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。apply接收参数的是数组，call接受参数列表， bind方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this指向除了使用new 时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</li></ul><h3 id="十九、原型-amp-amp-原型链"><a href="#十九、原型-amp-amp-原型链" class="headerlink" title="十九、原型 &amp;&amp; 原型链"></a>十九、原型 &amp;&amp; 原型链</h3><p>在规范里，prototype 被定义为：给其它对象提供共享属性的对象。  </p><p>JS是通过函数来模拟类，当我们创建一个函数的时候，js会给这个函数自动添加prototype属性，值是一个包含constructor属性的对象，不是空对象。当我们把函数当成构造函数通过new关键词调用的时候，js会帮我们创建该构造函数的实例，实例继承构造函数prototype的所以属性和方法（实例通过设置自己的<strong>proto</strong>指向构造函数的prototype来实现继承）</p><p>原型链的概念，仅仅是在原型这个概念基础上所作的直接推论。<br>既然 prototype 只是恰好作为另一个对象的隐式引用的普通对象。那么，它也是对象，也符合一个对象的基本特征。 也就是说，prototype 对象也有自己的隐式引用，有自己的 prototype 对象。<br>如此，构成了对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。  </p><h3 id="二十、new运算符的实现机制"><a href="#二十、new运算符的实现机制" class="headerlink" title="二十、new运算符的实现机制"></a>二十、new运算符的实现机制</h3><p>1、创建一个新的空对象<br>2、设置新对象的隐式原型（<strong>proto</strong>）为构造函数的显式原型（prototype）<br>3、使用apply改变构造函数this指向新的对象<br>4、根据函数apply的返回值，判断返回值，如果值是一个对象，则返回这个对象，若不是，则返回这个新创建的对象。</p><p><strong>手写实现new</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>  Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>)<br>  obj.__proto__ = Constructor.prototype<br>  <span class="hljs-keyword">const</span> result = Constructor.apply(obj, <span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二一、EventLoop-事件循环"><a href="#二一、EventLoop-事件循环" class="headerlink" title="二一、EventLoop 事件循环"></a>二一、EventLoop 事件循环</h3><p>js是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以将同步代码压入执行栈中，依次执行，将异步代码推入异步队列中，异步队列分为宏任务和微任务队列。微任务队列优先于宏任务队列，微任务的代表：Promise.then，MutationObserver，宏任务的代表：setImmediate setTimeout setInterval。  </p><p><strong>浏览器的事件循环</strong><br>事件环的运行机制是：先会执行执行栈中的内容，然后执行当前上下文的微任务队列，微任务队列执行完毕后，再执行宏任务，然后执行其中的同步代码。如此反复，这样就形成一个循环。这个过程被称为事件循环（event loop）</p><p>事件循环可以简单的描述为以下四个步骤:</p><ul><li>1、函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>2、此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>3、执行栈为空时，Event Loop把微任务队列执行清空；</li><li>4、微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ul><p><strong>node环境的事件环</strong><br>执行顺序如下：  </p><ul><li>timers: 计时器，执行setTimeout和setInterval的回调</li><li>pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调</li><li>idle, prepare: 队列的移动，仅系统内部使用</li><li>poll轮询: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li><li>check: 执行setImmediate回调，setImmediate在这里执行</li><li>close callbacks: 执行close事件的callback，一些关闭的回调函数，如：socket.on(‘close’, …)</li></ul><h3 id="二二、setTimeout、Promise、Async-Await-的区别"><a href="#二二、setTimeout、Promise、Async-Await-的区别" class="headerlink" title="二二、setTimeout、Promise、Async/Await 的区别"></a>二二、setTimeout、Promise、Async/Await 的区别</h3><ul><li>setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行</li><li>Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行。</li><li>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</li></ul><h3 id="二三、介绍节流防抖原理、区别以及应用"><a href="#二三、介绍节流防抖原理、区别以及应用" class="headerlink" title="二三、介绍节流防抖原理、区别以及应用"></a>二三、介绍节流防抖原理、区别以及应用</h3><p>节流： 事件触发后，在一段时间内只会触发一次,包括时间戳版和定时器版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//时间戳版</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>      fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)<br>      prev = now<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定时器版</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;, wait)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>防抖：事件触发后，在一段时间后才会执行函数，如果在这段时间内再次触发，会重新计算函数的执行时间，分为非立即执行和立即执行两个版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 非立即执行版</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    timer &amp;&amp; clearTimeout(timer)<br>    timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;, wait)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 立即执行版</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> now = !timer<br>    timer &amp;&amp; clearTimeout(timer)<br>    timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, wait)<br>    <span class="hljs-keyword">if</span> (now) &#123;<br>      fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景： </p><ul><li>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……</li><li>索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端日常开发常用技巧与方法</title>
    <link href="/my-hexo-blog/2020/06/09/%E5%89%8D%E7%AB%AF%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/my-hexo-blog/2020/06/09/%E5%89%8D%E7%AB%AF%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h4 id="盒子边倾斜"><a href="#盒子边倾斜" class="headerlink" title="盒子边倾斜"></a>盒子边倾斜</h4><p>clip-path: polygon(12% 0, 100% 0, 100% 100%, 0 100%);</p><h4 id="禁止点击事件-鼠标事件“穿透”"><a href="#禁止点击事件-鼠标事件“穿透”" class="headerlink" title="禁止点击事件/鼠标事件“穿透”"></a>禁止点击事件/鼠标事件“穿透”</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> * &#123;<br>    <span class="hljs-attribute">pointer-events</span>: none;   <span class="hljs-comment">/*链接啊，点击事件啊，都没有效果了*/</span> <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用来控制元素在移动设备上使用滚动回弹效果"><a href="#用来控制元素在移动设备上使用滚动回弹效果" class="headerlink" title="用来控制元素在移动设备上使用滚动回弹效果"></a>用来控制元素在移动设备上使用滚动回弹效果</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.main</span>&#123;<br>    <span class="hljs-attribute">-webkit-overflow-scrolling</span>: touch;<br>&#125;<br></code></pre></td></tr></table></figure><p>可解决在IOS中使用overflow:auto 形成的滚动条，滚动不流畅的情况</p><h4 id="文字渐变效果"><a href="#文字渐变效果" class="headerlink" title="文字渐变效果"></a>文字渐变效果</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.text-gradient</span>&#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">135deg</span>, deeppink, deepskyblue);<br>    <span class="hljs-attribute">-webkit-background-clip</span>: text;<br>    <span class="hljs-attribute">color</span>: transparent;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="css三角形"><a href="#css三角形" class="headerlink" title="css三角形"></a>css三角形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#triangle-up</span> &#123;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br><br> <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br><br> <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br><br> <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><h4 id="JavaScript中检测数组的方法"><a href="#JavaScript中检测数组的方法" class="headerlink" title="JavaScript中检测数组的方法"></a>JavaScript中检测数组的方法</h4><p>(1)、typeof操作符</p><p>这种方法对一些常用的类型检查没有问题，但对array和null 都判断为object<br>(2)、instanceof操作符</p><p>这个操作符是检测对象的原型链是否指向构造函数的prototype对象的<br>(3)、对象的constructor属性</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> arr = []<br><br>console.log(arr<span class="hljs-function">.<span class="hljs-keyword">constructor</span> === <span class="hljs-title">Array</span>) <span class="hljs-comment">// true</span></span><br></code></pre></td></tr></table></figure><p>(4)、Object.prototype.toString</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> arr = []<br><br>console.<span class="hljs-built_in">log</span>(Object.prototype.toString.<span class="hljs-built_in">call</span>(arr) === <span class="hljs-string">'[object Array]'</span>) // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>(5)、Array.isArray()</p><h4 id="常用的字符串操作"><a href="#常用的字符串操作" class="headerlink" title="常用的字符串操作"></a>常用的字符串操作</h4><ol><li>字符串转化toString()</li><li>字符串分隔split()</li><li>字符串替换replace()</li><li>获取长度length</li><li>查询子字符串 indexOf</li><li>返回指定位置的字符串或字符串编码 charAt charCodeAt</li><li>字符串匹配 match</li><li>字符串拼接concat</li><li>字符串的切割或提取slice() substring() substr()</li><li>字符串大小写转化 toLowerCase toUpperCase</li><li>字符串去空格 trim() 用来删除字符串前后的空格</li></ol><p>其中第9中三者的区别如下：<br>（1）slice(), 参数可以是负数，负数表示从字符串最后一个位置开始切割到对应结束位置<br>（2）substring()，参数不可为负数，切割第一个位置到第二个位置的字符串<br>（3）substr()， 参数不可为负数，第一个参数是开始位置，第二个参数为切割的长度<br>字符串去重<br>const str = ‘11122223333’<br>const arr = str.split(‘’)<br>const uniqueStr = […new Set(arr)].join(‘’)</p><h4 id="常用的数组操作"><a href="#常用的数组操作" class="headerlink" title="常用的数组操作"></a>常用的数组操作</h4><p>1、Array.map()<br>此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组<br>2、Array.forEach()<br>此方法是将数组中的每个元素执行传进提供的函数，没有返回值，注意和map方法区分<br>3、Array.filter()<br>此方法是将满足条件的元素作为一个新数组返回<br>4、Array.every()<br>此方法将数组所有元素进行判断返回一个布尔值，如果所有元素都符合判断条件，则返回true，否则返回false<br>5、Array.some()<br>此方法将数组所有元素进行判断返回一个布尔值,如果有一个元素满足判断条件，则返回true，所有元素都不满足则返回false<br>6、Array.reduce()<br>此方法为所有元素调用返回函数<br>7、Array.push()<br>在数组最后面添加新元素<br>8、Array.shift()<br>删除数组第一个元素<br>9、Array.pop()<br>删除数组最后一个元素<br>10、Array.unshift()<br>在数组最前面增加元素<br>11、Array.isArray()<br>判断是否为一个数组<br>12、Array.concat()<br>数组拼接<br>13、Array.toString()<br>数组转化为字符串<br>14、Array.join()<br>数组转化为字符串，并用第一个参数作为连接符<br>15、Array.splice(开始位置，删除个数，元素)<br>####常用对象方法<br>1、Object.assign()<br>用于克隆，两个参数，将第二个对象分配到第一个中<br>2、Object.is()<br>用于判断两个值是否相同<br>//注意，该函数与==运算符不同，不会强制转换任何类型， 应该更加类似于===，但值得注意的是它会将+0和-0视作不同值<br>3、Object.keys()<br>用于返回对象可枚举的属性和方法的名称，返回一个属性或方法名称的字符串数组。<br>4、Object.defineProperty()<br>劫持变量的set和get方法,将属性添加到对象，或修改现有属性的特性</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">var</span> a = &#123;&#125;;<br>Object.defineProperty(a, <span class="hljs-string">'name'</span>, &#123;<br>    <span class="hljs-keyword">value</span> : <span class="hljs-string">'kong'</span>,<br>    enumerable : <span class="hljs-literal">true</span> <span class="hljs-comment">//该属性是否可枚举</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>5、Object.defineProperties()<br>可添加多个属性,与Object.defineProperty()对应,<br>6、isPrototypeOf</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> a();<br><span class="hljs-built_in">console</span>.log(a.prototype.isPrototypeOf(b));<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="安卓监听可视区域变化，让输入框移动至可视区域"><a href="#安卓监听可视区域变化，让输入框移动至可视区域" class="headerlink" title="安卓监听可视区域变化，让输入框移动至可视区域"></a>安卓监听可视区域变化，让输入框移动至可视区域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Android/gi</span>.test(navigator.userAgent)) &#123;<br>          <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.activeElement.tagName === <span class="hljs-string">'INPUT'</span> || <span class="hljs-built_in">document</span>.activeElement.tagName === <span class="hljs-string">'TEXTAREA'</span>) &#123;<br>              <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-built_in">document</span>.activeElement.scrollIntoViewIfNeeded();<br>              &#125;, <span class="hljs-number">0</span>);<br>            &#125;<br>          &#125;);<br>        &#125;;<br></code></pre></td></tr></table></figure><h4 id="vue中平滑滚动到某个位置"><a href="#vue中平滑滚动到某个位置" class="headerlink" title="vue中平滑滚动到某个位置"></a>vue中平滑滚动到某个位置</h4><p>this.$refs.rule.scrollIntoView({ block: ‘start’, behavior: ‘smooth’ })</p><h4 id="好用的JavaSrcipt库与模块（包）"><a href="#好用的JavaSrcipt库与模块（包）" class="headerlink" title="好用的JavaSrcipt库与模块（包）"></a>好用的JavaSrcipt库与模块（包）</h4><h5 id="日期时间处理库"><a href="#日期时间处理库" class="headerlink" title="日期时间处理库"></a>日期时间处理库</h5><p>1、<a href="http://momentjs.cn/" target="_blank" rel="noopener">monent.js</a><br>2、<a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener">day.js</a><br>day相对于monent要轻量许多</p><h5 id="高精度数学运算"><a href="#高精度数学运算" class="headerlink" title="高精度数学运算"></a>高精度数学运算</h5><p><a href="https://developer.aliyun.com/mirror/npm/package/number-precision" target="_blank" rel="noopener">number-precision</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>strip(num)         <span class="hljs-comment">// strip a number to nearest right number</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>plus(num1, num2, num3, ...)   <span class="hljs-comment">// addition, num + num2 + num3, two numbers is required at least.</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>minus(num1, num2, num3, ...)  <span class="hljs-comment">// subtraction, num1 - num2 - num3</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>times(num1, num2, num3, ...)  <span class="hljs-comment">// multiplication, num1 * num2 * num3</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>divide(num1, num2, num3, ...) <span class="hljs-comment">// division, num1 / num2 / num3</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NP</span>.</span></span>round(num, ratio)  <span class="hljs-comment">// round a number based on ratio</span><br></code></pre></td></tr></table></figure><h5 id="实用工具库"><a href="#实用工具库" class="headerlink" title="实用工具库"></a>实用工具库</h5><p><a href="https://www.lodashjs.com/" target="_blank" rel="noopener">Lodash</a><br>lodash 是一个 JavaScript 实用工具库，提供一致性，及模块化、性能和配件等功能。<br>Lodash 消除了处理数组的麻烦，从而简化了 JavaScript、 数字、对象、字符串等</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>javaScript</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的数据类型及深浅拷贝介绍</title>
    <link href="/my-hexo-blog/2020/06/09/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BB%8B%E7%BB%8D/"/>
    <url>/my-hexo-blog/2020/06/09/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><p>JS分为两种数据类型：<br><strong>基本数组类型</strong>： Number、String、Boolean、Null、Undefined、Symbol<br><strong>引用数组类型</strong>：Object(JS中除了基本数据类型，其他都是对象。例如数组、函数、正则表达式等)</p><h5 id="（1）基本数据类型（存放在栈中）"><a href="#（1）基本数据类型（存放在栈中）" class="headerlink" title="（1）基本数据类型（存放在栈中）"></a>（1）基本数据类型（存放在栈中）</h5><p>基本数据类型是指直接存放在栈中的简单数据段，数据大小确定，内存k空间可分配，按值存放和访问<br><strong>注：栈(stack)和堆（heap）</strong><br>stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放</p><h5 id="（2）引用数据类型（存放在堆内存中的对象）"><a href="#（2）引用数据类型（存放在堆内存中的对象）" class="headerlink" title="（2）引用数据类型（存放在堆内存中的对象）"></a>（2）引用数据类型（存放在堆内存中的对象）</h5><p>引用数据类型是存放在堆内存里的对象，而指向堆内存值的引用也就是指针是存在栈内存中的。</p><h3 id="2、浅拷贝"><a href="#2、浅拷贝" class="headerlink" title="2、浅拷贝"></a>2、浅拷贝</h3><p>当我们使用对象拷贝时，如果属性是对象或者数组时，我们只是拷贝的数组或对象的引用地址，因此两者的属性值会指向同一个内存空间。实现数组的片浅拷贝使用concat、slice<br>这个两个是技巧类，如何实现一个浅拷贝呢？简单的思路是遍历对象，把属性和属性值都放在一个新的对象中<br>如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> shallowCopy = <span class="hljs-function"><span class="hljs-keyword">function</span></span>(obj) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (typeof obj !== <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 根据obj的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span> = obj instanceof <span class="hljs-keyword">Array</span> ? [] : <span class="hljs-type"></span>&#123;&#125;;<br>  <span class="hljs-comment">// 遍历obj，并且判断是obj的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>      <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>          <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[key] = obj[key];<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let a = &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'456'</span> &#125;&#125;<br>const b = shallowCopy(a)<br>b.obj.name = <span class="hljs-string">'666'</span><br>console.log(b) // &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'666'</span> &#125; &#125;<br>console.log(a) // &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'666'</span> &#125; &#125;<br></code></pre></td></tr></table></figure><p>这样如果改变b中的对象，a中的对象也会同时改变。</p><h3 id="3、深拷贝"><a href="#3、深拷贝" class="headerlink" title="3、深拷贝"></a>3、深拷贝</h3><p>实现数组或对象的深拷贝，可以使用JSON.parse(JSON.stringify(obj))<br>如何手写一个深度拷贝呢？思路是通过递归调用拷贝函数</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> deepCopy = <span class="hljs-function"><span class="hljs-keyword">function</span></span>(obj) &#123;<br>  <span class="hljs-keyword">if</span> (typeof obj !== <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span> = obj instanceof <span class="hljs-keyword">Array</span> ? [] : <span class="hljs-type"></span>&#123;&#125;<br>  <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>      <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[key] = typeof obj[key] === <span class="hljs-string">'object'</span> ? deepCopy(obj[key]) : <span class="hljs-type">obj</span>[key]<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span><br><span class="hljs-type"></span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let a = &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'456'</span> &#125;&#125;<br>const b = deepCopy(a)<br>b.obj.name = <span class="hljs-string">'666'</span><br>console.log(b) // &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'666'</span> &#125; &#125;<br>console.log(a) // &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'123'</span>, obj: &#123; <span class="hljs-type">name</span>: <span class="hljs-string">'456'</span> &#125; &#125;<br></code></pre></td></tr></table></figure><p>这样就实现了深度拷贝，当改变b中对象值时，a没有发生变化。</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
